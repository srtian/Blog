# [《白帽子讲安全》](https://github.com/srtian/Blog/issues/25)


# 结构：
![](https://cdn.nlark.com/yuque/0/2022/jpeg/296173/1655191089154-1918e60a-b4f9-465e-8066-4cfc3d047347.jpeg)

# 一、安全世界观
**安全问题的本质的信任的问题**。

### 安全三要素：

- 机密性（Confidentiality）：保护数据内容不被泄漏，加密是实现机密性要求的常见手段。
- 完整性（Integrity）：保护数据内容是完整的，没有被篡改的。常见的手段是数字签名
- 可用性（Availability）：随需所得，这一方面主要需要防御 拒绝访问攻击（DOS）

### 安全评估的四个阶段

1. 资产等级划分：明确目标是什么，要保护什么。**互联网安全的核心问题，是数据安全的问题。**因此对于数据等级性质不同，确认不同等级构建对应的信任模型，很重要。
2. 威胁分析：我们把可能造成危害的来源称为威胁（Threat），而把可能会出现的损失称为风险（Risk）。需要构建威胁模型，并不断对模型进行更新
3. 风险分析：**Risk = Probability * Damage Potential**
4. 确认解决方案: 一个好的安全方案应该有以下特点：
   1. 能够有效解决问题
   2. 用户体验好
   3. 高性能
   4. 低耦合
   5. 易于扩展与升级

### 白帽子兵法，设计安全方案的方法论：

1. Secure By DefauIt原则，最为基本的原则，
   1. 可归纳为白名单、黑名单的思想，更多的使用白名单，系统会更加安全。
   2. 最小权限原则，要求系统只授予主体必要的权限，而不要过度授权。
2. 纵深防御原则：
   1. 要在各个不同的层面，方面实施安全方案，避免出现纰漏，不同方案之间需要相互配合，构建一个整体
   2. 要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。
3. 不可预测性原则：本质上就是产出一些攻击者无法预知的东西，比如 Token 的应用。

# 二、浏览器安全

## 2.1、同源策略
同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也最基本的安全功能。**浏览器的同源策略，限制了来自不同源的“document”或者脚本，对当前“document”读取或者设置某些属性。**<br />影响源的因素有：

- host
- 子域名
- 端口
- 协议

在浏览器中，<script>、<img>、<iframe>、<link>等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。

## 2.2、浏览器沙箱
这种在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被形象地称为“挂马”。<br />在Windows系统中，浏览器密切结合DEP、ASLR、SafeSEH等操作系统提供的保护技术，对抗内存攻击。与此同时，浏览器还发展出了多进程架构，从安全性上有了很大的提高。浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。<br />Google Chrome是第一个采取多进程架构的浏览器。Google Chrome的主要进程分为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程如flash、java、pdf等与浏览器进程严格隔离，因此不会互相影响。[插图]Google Chrome的架构渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程通信、与操作系统通信都需要通过IPC channel，在其中会进行一些安全检查。<br />Sandbox即沙箱，计算机技术发展到今天，Sandbox已经成为泛指“**资源隔离类模块**”的代名词。**Sandbox的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源**。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性。

## 2.3、恶意网址拦截
目前各个浏览器的拦截恶意网址的功能都是基于“黑名单”的。<br />恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。<br />常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含有恶意的脚本如JavaScript或Flash，通过利用浏览器的漏洞（包括一些插件、控件漏洞）执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。

# 三、跨站脚本攻击（XSS）
跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区别，所以在安全领域叫做“XSS”。<br />XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。由于XSS破坏力强大，且产生场景复杂，业内达成的共识是：针对各种不同场景产生的XSS，需要区分情景对待。

## 3.1、XSS简介

### 1、反射形XSS
反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”（Non-persistent XSS）。

### 2、存储型XSS
存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。比如：黑客在一篇 blog 中，写下了恶意代码，就可能会造成所有看到这篇 blog 的人都收到攻击

### 3、DOM Based XSS
实际上也是反射形 XSS，但由于形成原因比较特别，因此单独划分，即：通过修改页面的 DOM 节点形成的 XSS，即称为  DOM Based XSS


## 3.2、XSS攻击进阶

### 1. 初探 XSS Payload
XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload”。XSS Payload实际上就是JavaScript脚本（还可以是Flash或其他富客户端的脚本），所以任何JavaScript脚本能实现的功能，XSSPayload都能做到。

### 2. 强大的 XSS Payload

- 构造GET与POST请求
- XSS钓鱼：对于验证码，XSS Payload可以通过读取页面内容，将验证码的图片URL发送到远程服务器上来实施——攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。
- 识别用户浏览器
   - 攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS能够帮助攻击者快速达到收集信息的目的。
   - 浏览器的扩展和插件也能被XSS Payload扫描出来。比如对于Firefox的插件和扩展，有着不同的检测方法。
-  CSS History Hack： 其原理是利用style的visited属性——如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同
- 获取用户的真实IP地址：JavaScript本身并没有提供获取本地IP地址的能力，有没有其他办法？一般来说，XSS攻击需要借助第三方软件来完成。比如，客户端安装了Java环境（JRE），那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。
- XSS Worm
