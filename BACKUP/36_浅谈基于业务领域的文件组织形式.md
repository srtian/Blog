# [浅谈基于业务领域的文件组织形式](https://github.com/srtian/Blog/issues/36)

前段时间无意中翻了一个老外对于项目代码文件组织形式的讨论，谈到了自己在基于技术组织文件所遇到的一些问题（具体文章找不见了）。那什么是基于技术的代码组织方式呢，其实很简单：就是根据具体的技术范畴，对代码进行管理。在这里随便找一个开源的前端项目举例：<br />                                             ![image.png](https://cdn.nlark.com/yuque/0/2021/png/296173/1634129684336-c7d40c8b-45d9-4cce-a6df-6b075be46df9.png#clientId=u3bb9270c-e889-4&from=paste&height=596&id=u37946f3e&name=image.png&originHeight=1788&originWidth=592&originalType=binary&ratio=1&size=133958&status=done&style=none&taskId=u82e39ecb-3f6e-4f76-8825-350344d0c4b&width=197.33333333333334)<br />大家可以看到，其实这个项目的文件划分以及是非常清楚了：

- components 是组件存放的地方
- composable 则用于存放自定义的 hook
- pages 就是页面
- services 用于处理与后端先关联的逻辑
- store 用于存储前端数据与状态

可以说是一个前端 Vue 项目 MVVM 的代码组织的典范了。这要做的好处在于：

- 代码分工明确，可以很清楚的知道每个文件夹下的代码所负责的职责是什么
- 后缀统一，对强迫症患者比较友好（皮一下）

所以很多项目都会按照这种方式去进行代码的组织与管理（包括我自己），BPM在这方面同样也是如此：<br />                                                  ![image.png](https://cdn.nlark.com/yuque/0/2021/png/296173/1634130339257-396c3751-13a4-4e0c-94ed-bdf7276f962e.png#clientId=u6ae72d04-bfca-4&from=paste&height=359&id=ue03dc514&name=image.png&originHeight=1076&originWidth=526&originalType=binary&ratio=1&size=120874&status=done&style=none&taskId=u41487756-7996-4e9f-8595-709598f968b&width=175.33333333333334)<br />与上面也很类似：

- components 公共组件
- modules 存放前端的页面代码
- models 主要用于数据的存储，对应 react 中的 redux 之类的状态管理
- services 主要用于处理后端的交互

但其实这样的文件组织方式，同样也存在一些问题，主要有两方面：

1. 对于一个功能或者页面，我们无法直观的知道它相关的代码文件数量是多少，散落的哪些文件夹中。
2. 开发一个功能时，需要在多个文件夹中来回切换，也需要同时改动多个文件夹中的代码。当项目过于庞大时，往往招文件都会变成一件不容易的事情（对于这一点我深有体会）

这也引起了我对于现在项目文件有了一些反思，加之前段时间总结了一下领域驱动设计，又回想起当年学习 Angular 所带来的一些收获，所以也开始思考：或许直接使用业务领域去组织文件会更好一些，就比如这样：<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/296173/1634455409064-7ab6d177-cb2e-4440-8355-73fd99ed9147.png#clientId=u19b29901-62cc-4&from=paste&height=157&id=u9edcf112&name=image.png&originHeight=472&originWidth=562&originalType=binary&ratio=1&size=71770&status=done&style=none&taskId=u598b10e2-520d-48ad-bcf1-1f4a3c07df0&width=187.33333333333334)

其主要实践如下：

- 坚持根据业务领域来对目录进行命名
- 坚持为每个业务领域创建单一的 Module
- 坚持将该业务下的所有逻辑都放在这个文件夹下
- 坚持视图与逻辑的抽离，组件存放components里，主要负责数据驱动渲染，而逻辑通过自定义hooks的方式，放在hooks中。（需要注意的是当组件和 hooks 数目都不多时，不需要使用文件夹进行管理，直接扁平化管理会更好）

这样做的优点在于：

1. 做到模块在物理层面的内聚，当需要改动一个功能时，只需要修改一个文件即可。
2. 数据驱动的组件以及逻辑聚合的hooks更符合单一职责，也更有利于测试
3. 功能结构即文件，开发人员看一眼就知道对应的功能的相关代码会在那些地方

当然，也会存在一些缺点：

- 代码可能会有所冗余，文件结构也是

这里需要注意的是，有人会说，可能一个模块的组件被多个地方所引用，那么按照这种方式去做，岂不是也会存在一个领域下，存在其他文件的代码？这里又需要引入领域驱动设计的另外一个概念了：**通用域、支撑域、核心域**。虽然这个域在后端开发中，往往是很大的一个概念了，但引用至我们前端开发的范畴，我们依然可以用这个思路去思考我们模块的划分:

- 核心域就是我们的关键模块，对于这些模块，我们要重点关注这些模块的可用性、性能、埋点、测试用例的完备。
- 通用域则是被多个模块所共同需要的，对于通用域，如果涉及到有包含关系的我们可以进行有效的抽象和封装，将通用域的功能以组件或者自定义hooks的方式暴露给其他模块，从而降低耦合；而如果不存在包含关系，只是有联动关系的，我们可以定义一些领域事件，通过领域事件来更改相关状态或者使用发布订阅模式来实现相关模块的互动与关联。
- 支持域，这部分在前端会比较少。具体到前端，可以理解为一些权限的统一审核处理等。

