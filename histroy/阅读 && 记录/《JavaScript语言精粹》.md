
# 第一章 精华
javascript建立在一些非常优秀的想法和少数非常糟糕的想法之上，优秀的包括函数，弱类型，动态对象，和富有表现力的对象字面量表示法、而糟糕的想法包括基于全局变量的编程模型。

javascript的函数是主要基于词法作用域的顶级对象。

JavaScript的弱类型是自由的，无需建立复杂的类层次，不用做强制造型，也不用疲于应付类型系统已得到想要的行为。


# 第二章 语法
空白格能表现为被格式化的字符或者注释的形式。空白通常是没有意义的，但如果需要用它来分隔字符序列，否则他们就会被合并成一个符号。

要是用准确的注释来描述代码，如果不能这样，那么比没有注释还要糟糕。同时还要注意/*....*/ 可能会垂涎语法错误，所以可能会需要使用//来代替。

JS只有一个数字类型，它在内部被表示为64位的浮点数。它没有分离出整数类型，所以1和1.0的值相同。这样完全避免了短整型的溢出问题。

字符串字面量可以被包在一对单引号或双引号。（推荐使用单引号）字符串是不可变的，但可以通过+运算符链接其他字符串来穿件一个新字符串。两个包含完全相同的字符且字符顺序也相同的字符串被认为是同样的字符串。

对象字面量是一种可以方便地指定规格创建新对象的表示法。属性名可以是标识符或字符串。这些名字被当做字面量名而不是变量名来对待，所以对象的属性名在编译时才能知道。属性的值口水表达式。


# 第三章 对象
对象是属性的容器，其中每个属性都用名字和值。属性的名字可以是包括空字符串在内的任意字符串。属性值可以是除了undefined值之外的任何值。JS里的对象是无类型的。JS的原型链如果正确使用它可以减少对象初始化时消耗的时间和内存。

要检索对象库包含的值，可以采用在[]后缀中扩住一个字符串表达式的方式。如果是一个合法的js标识符且不是保留字，可用.代替。这样其实更紧凑且可读性更好。

对象里的值可以通过赋值语句来更新，如果已经存在，则替换。如果不存在，则该属性被扩充到对象中。

对象通过引用来传递，他们永远不会被复制。

原型关系是一种动态的关系，如果我们添加一个新的属性到原型中，该属性会立即对所有基于该原型创建的对象可见。

使用for in语句可以枚举对象中的所有属性。但属性出现的顺序是不确定的，如果需要属性以特定的顺序出现，最好的方法就是不使用for in语句，而是创建一个数组，在其中以正确的顺序包含属性名。

delete运算符可以用来删除对象的属性。它不会处理原型链中的任何对象。删除对象的属性可能会让来自原型链中的属性透现出来。

JS可以随意的定义全局变量来容纳你的应用得问所有资源。但全局变量削弱了程序的灵活性，应该避免使用。而最小化使用全局变量的方法之一是为你的应用值创建一个唯一的全局变量。

在处理对象中不需要的属性时有两种方法可以使用，第一种是让你的程序做检查并丢弃值为函数的属性；第二中是使用hasOwnProperty方法，如果是该对象所独有的属性，它会返回true，且该方法不会检查数据链。


# 第四章 函数
JS中的函数就是对象。对象是名/值对的集合并拥有一个连到原型对象的隐藏连接。每个函数在创建时会附加两个隐藏属性：函数的上下文和实现函数行为的代码。

每个函数对象在创建时也随配有一个prototype属性。它的值是一个拥有constructor属性且值即为该函数的对象。

函数字面量包括4个部分。

1. 第一部分是保留字function，
2. 第二部分是函数名，可以省略，如果没有名字，则被称为匿名函数。
3. 第三部分是括号所包含的的参数。
4. 第四部分是包围在花括号中的一组语句。这是函数的主题，在被调用时执行。

调用一个函数会暂停当前函数的执行，传递**控制权和参数**给新函数。除了声明时定义的形式参数，每个函数会接受两个附加的参数：this和arguement。参数this的值却绝于调用的模式。而在JS中一共有4中调用模式：

- 方法调用模式，
- 函数调用模式，
- 构造器调用模式
- apply调用模式.

这些模式在如何初始化关键参数this存在差异。


### 方法调用模式。
当一个函数被保存为对象的一个属性时，我们成它为一个方法。当一个方法被调用时，this被绑定到该对象。如果调用表达式包含一个提取属性的动作，那么它就是被当做一个方法来调用。方法可以使用this访问自己所属的对象，所以它能从对象中取值或对对象进行修改。this到对象的绑定发生在调用的时候、这个延迟绑定使得函数可以对this高度复用。通过this取得他们所属对象的上下文的方法称为公共方法。如下：
```javascript
var myObj = {
  val: 0,
  increment: function(inc) {
    this.val += typeof inc === 'number' ? inc : 1
  }
}
myObj.increment()
console.log(myObj.val) //1
myObj.increment(2)
console.log(myObj.val) //3
```

（当使用this时，可以对increment进行多次的数据绑定达到多次复用的效果。）


### 函数调用模式
使用函数调用模式时，this被绑定到全局对象。这是一个设计错误。如果是正确时，那么当内部函数被调用this时	应该仍然绑定到外部函数的this变量。但这个好纠结，如果该方法定义一个变量并给它赋值为this，那么内部函数就可以通过那个变量访问到this

JS是一门基于原型继承的语言（但在ES6中有了Class），是无类型的。这脱离的现在的主流编程语言的，因此它提供了一套和基于类的语言类似的对象构建语法。具体实现如下：
```javascript
var li = function(number){
  this.ages = number
}
li.prototype.getAges = function(){
  return this.age
}
const gao = new li(18)
console.log(gao.getAges()) // 18
```

在编程语言中，作用域控制着变量与参数的可见性及生命周期。对程序员来说这是很好的，因为它减少了名称成本，并且提供了自动内存管理。

我们可以使用函数和闭包来构造模块。模块是一个提供接口却影藏状态与实现的函数或对象。通过使用函数产生模块，我们几乎可以完全摒弃全局变量得问使用，从而缓解这个大问题。

柯里化允许我们把函数与传递给它的参数相结合，产生出一个新的函数。

函数可以将先前操作的结果记录在某个对象里，从而避免无谓的重复计算。这种优化叫做记忆。


# 第五章 继承
在那些基于类的语言中，继承（inheritance或者是extend）提供了两种有用的服务：

1. 它是代码重用的一种形式，如果编写显式转换的代码，一个新的类与一个已存在的类大部分相似，那么你只要说明其不同的的但就行了，这是很重要的，因为他可以显著的减少软件开发的成本。
2. 类继承的另一个好处是引入了一套类型系统的规范，由于程序员不用写显式转换的代码，这样工作量将大大减轻，而且类型转换会丧失类型系统在安全上的优势。

JS的原型存在诸多的矛盾，一些复杂的语法让它看起来就像一门基于类的语言，这些语法上的问题覆盖了它的原型机制，它也并不是直接让对象从其他对象继承，反而插入了一个斗鱼的中间层：同构构造器函数来产生对象。

当一个函数创建时，unction构造器产生的函数对象会允许类似这样的代码：

```javascript
this.prototype = {constructor: this}
```
这样的话，新函数对象被赋予了一个prototype，它的值是一个包含constructor属性且属性值为该函数的对象。prototype对象是用来存放继承特征的地方，但由于JS中没有提供去确定哪个函数是打算用于构造函数的，所以每个函数都会得到prototype对象。

4.当采用构造器调用模式，即用new前缀去调用一个函数时，函数执行的方式会被修改。如果new运算符是一个方法而不是一个运算符，他可能会像这样执行：<br />
```javascript
Function.method('new', Function() {
	var that = Object.create(this.prototype)
	var other = this.apply(that, arguement)
  return (typeof other === 'object' && other) || that
	}
)
```

然后可以定义一个构造器并扩充他的原型get_name和says.
```javascript
var Mammal = function(name) {
  this.name = name
}
Mammal.prototype.getName = function() {
  return this.name
}
Mammal.prototype.says = function() {
  return this.name || ''
}
```

以Mammal对象为原型构造一个实例myMammal.

```javascript
var newMammal = new Mammal('herb the Mammal')
var name = newMammal.getName()
```

以Mammal对象为原型构造一个对象Cat,并未Cat对象创建一个新的原型purr.

```javascript
Cat.prototype = new Mammal()
Cat.prototype.purr = function(n) {
  let s = '',
  for(let i = 0; i < n; i++) {
    if(s){
      s += '-'
    }
    s += 'r'
  }
  return s
}
```

为cat增加原型get_name，并以Cat为原型构建一个新对象myCat.后面的输出可以表明myCat通过不断的构造器继承了Cat,Mammal的实例。以上的做法虽然成功达到了目的但显得过于冗长，且关于protopyte的相关用法也显得格格不入。下面是同构method方法来定义一个inherits方法实现：<br />![clipboard.png](https://cdn.nlark.com/yuque/0/2020/png/296173/1586500976111-8b812b8a-76f9-43a2-ac23-35df2228ef45.png#align=left&display=inline&height=658&name=clipboard.png&originHeight=658&originWidth=848&size=52506&status=done&style=none&width=848)<br />但以上的代码虽然隐藏了那些无谓的prototype操作细节，但可以发现，没有了私有环境，所有的属性都是公开的。无法super(父类)的方法。另一个危害是乳沟你在调用构造器函数时忘记了在前面加上new前缀，那么this将不会被绑定到一个新对象中。坑爹的是，this会被绑定到全局对象上，这样你不但没有扩充新对象，反而破坏了全局变量环境。为了降低这个问题带来的风险，所有构造器函数都约定命名成首字母大写的形式，并且不以首字母大写的形式写任何其他的东西，这样可以让我们可以用目视是否缺少new前缀。但更好的备选方法是不使用new。
> （注：方法是作为对象的属性的函数。他们大致是一样的，只不过方法（method）通常在函数内部，这就意味着方法可以操作函数（function）内部的数据；另外，从传参的角度来讲，方法（method）相比函数（function）显式传递来说，通常是隐式传参。


有时，构造器需要接收一大串参数，记住参数的参数的顺序非常困难。因此，如果在编写构造器时让它接受一个简单的对象说明符，会更友好。那个对象包含了将要构建的对象规格说明。因此，与其写成这样：<br />`var myObj = maker(f, l, m, c, s)` <br />还不如写成这样：

```javascript
var myObj = maker({
  first: f,
  middlw: m,
  last: l,
  state: s,
  city: c
})
```

现在多个参数可以按任何顺序排序，如果构造器会聪明的使用默认值，一些参数可以忽略掉，且代码也更易读。当与JSON仪器工作时，这种形式还有一个好处，JSON文本只能描述数据，但有时数据表示的是一个对象，把该数据与它的方法关联起来是有用的。乳沟构造器取得一个对象说明符，就能让它轻松实现，因为我们可以把JSON对象传递给构造器，而它将返回一个构造完全的对象。

5.基于原型的继承相比于基于类的继承更简单：一个新对象可以继承一个旧对象的属性。废话少说上代码：<br />![clipboard1.png](https://cdn.nlark.com/yuque/0/2020/png/296173/1586501164784-aba8a13c-9f7f-411a-a3f5-e569d225d24f.png#align=left&display=inline&height=714&name=clipboard1.png&originHeight=714&originWidth=819&size=57143&status=done&style=none&width=819)<br />以上代码就是先创建一个myMammal的对象，在在这个对象的基础上创建myCat对象，这样myCat对象就继承了myMammal对象的属性。这是一种“差异化继承”。通过定制一个新的对象，我们指明它与所基于的基本对象的区别。

6.应用模块模式也是一种很好的继承模式，它由以下步骤：

1. 创建一个新对象。
2. 有选择的定义私有实例变量和方法。这些就是函数中通过var语句定义的普通变量。
3. 给这个新对象扩充方法。这些方法拥有特权去访问参数，以及第二部中通过var语句定义的变量。
4. 返回那个新对象。

以下是一个函数化构造器的伪代码模板：

```javascript
var constructor = function() {
  vat that
  my = my || {}
  // 将共享的变量和函数添加到my中
  that = 一个新对象
  // 添加给that的特权方法
  return that
}
```

（其中spec对象包含构造器需要构造一个新势力的所有信息。my对象是一个为继承链中的构造器提供秘密共享的容器。）
