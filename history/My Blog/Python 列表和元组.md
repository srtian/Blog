
### 基本性质：


#### 1. 相同点：

python中有关于数组和元组，其实本质上都是一个可以放置任意数据类型的有序集合。

```python
a = ['hello', 'world', 1, 2, 3]
a
['hello', 'world', 1, 2, 3]
 
name = ('srtian', 20)
name
('srtian', 20)
```


#### 2. 不同点：

1. 列表是动态的，长度大小都不固定，可以随意的去增删改
2. 元组是静态的，长度大小固定，无法增删改

```python
a = [1, 2, 3, 4]
a[2] = 'HELLO'
a
[1, 2, 'HELLO', 4]
 
tup = (1, 2, 3, 4)
tup[1] = 10086
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```

如上述的代码所示，我们无法直接改变元组的值。当我们想要对元组进行改变的时候，只能重新开辟一块内存，创建新的元组：

```python
tup = (1, 2, 3)
new_tup = tup + (4, )
new _tup
(1, 2, 3, 4)
```


#### 3. 存储差异

由于列表和元组一个是动态的一个是静态的，因此两者的存储方式也不同：

```python
a = [1, 2, 3]
a.__sizeof__()
64
tup = (1, 2, 3)
tup.__sizeof__()
48
```

从上面的代码可以得知，就算存储相同的数据，列表和元组所占的字节也是不同的，这是由于列表是动态的，因此它还需要存储指针，来指向对应的元素，且由于列表可变这一性质，还需要额外存储已经分配的查高度大小，才能实时追踪列表空间的使用情况，当空间不足的时候，及时分配额外空间。这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)


#### 4. 性能

python在后台会对静态资源进行资源缓存。通常来讲，因为垃圾回收机制，如果一些变量不使用了，python就会回收这些变量的内存，返还给操作系统。

但对于一些静态的变量，如果不被使用且占用空间不大，python会暂时缓存这部分内存，当下次还需要创建同样大小的元组的时候，python就可以不用再向操作系统发起请求，寻找内存了，而是可以直接分配之前缓存的内存，从而大大的提交程序运行的速度。

总的来讲，如果是要对数据进行增删改，那么就用列表性能会更好。如果不需要，那就元组。
