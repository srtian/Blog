
### 前言：
对于HTTPS其实很早之前就有过学习，但对其一直是一知半解，知道的并不深入全面，因此用了些时间，好好地阅读了极客时间关于HTTPS的一些专栏，并总结一下尝试着用自己的话来描述一下。


## 一、没有安全的 HTTP 和它的巡礼之年
HTTP最初的目的：传输超文本文件，因此一直是明文传输文件，而且不安全。由于是明文传输，所以就很容易被中间人所截取，一切通信的内容也被这个中间人所掌握。这也就是常说的中间人攻击。


### 1.1 什么是安全
那如何定义通信过程是安全的呢：机密性，完整性，身份验证以及不可否认：<br />机密性：简单来说就是数据是加密过的，除了参与通信之外的人都是都是看不了的。<br />完整性：数据在通信的过程中是完整的，没加经过篡改的。<br />身份认证：通信双方可以验证对方的真实身份<br />不可否认：不能否认已经发生过的行为

因为是明文传输，所以在一些对安全要求高的场景就不能很好的满足需求，因此在原有的基础上引入了加密方案，在TCP和HTTP之间加入了一个安全层SSL/TLS
> HTTP -> TCP
> HTTP -> 安全层(SSL/TLS) -> TCP


### 1.2 什么是SSL/TLS？
SSL全名叫Secure Sockets Layer中文名叫 安全套接层，在 OSI 模型中储运第五层会话层的位置。这玩意儿是由网景公司所发明，并在其发展到 V3 的时候被 IETF 改名为 TLC（Transport Layer Security），并对其进行标准化。而 TLS 发展到现在也经历了三个版本，最新的版本是2018年所制定的，牢牢的将密码学的发展与当今互联网的现状相结合，持续提高安全与性能，因此也成为信息安全领域的权威标准。<br />而它的职责也很简单：

- 对发起 HTTP 请求的数据进行加密操作
- 对接收到 HTTP 的内容进行解密操作

当浏览器客户端和服务端在使用 TLS 进行通信时，需要选择一组合理的加密算法来实现安全通信，而这些算法的组合通常被称为：加密套件。它的命名是很规范的，基本形式就是：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法。其中，签名算法可以进行身份验证，摘要算法可以保证数据的完整性，而对称加密算法则可以保证数据的机密性。（值得注意的是，在2019年不安全的 TLS 1.0 和 1.1 默认被禁用（[Safari TP 91](https://link.zhihu.com/?target=https%3A//webkit.org/blog/9526/release-notes-for-safari-technology-preview-91/)、Google Chrome 72+、Firefox Nightly）


## 二、安全的 HTTPS 和它的故事

### 2.1 对称加密
前面我们提到，HTTP协议在进行传输的时候是通过明文进行传输的，因此不安全。那么如果需要保证传输信息的机密性，最简单的方法不外于将其进行加密，这样第三方的人在拿到这些信息的时候，也就不能获取信息里面的内容了。因此这就引入了加密的第一个概念：对称加密。

对称加密其实很简单：加密和解密都使用的是相同的密钥，是对称的，这里的密钥就是用于解开加密信息的钥匙。

简单来说就是客户端会给服务端发送它支持的加密的方法的列表，以及一个随机数，然后服务器端在接受到这些东西后，会从客户端所支持的加密方法列表中选取一种，然后同时生成一个随机数给客户端，这样两端就都确定了加密方法和随机数，也就可以通过这些信息来生成对应的密钥了。这样做的话即使黑客在获取到浏览器与服务器所传输的信息，得到的也只是一串乱码，而他也没有相应的密钥，也就保证了信息传输的机密性。

TLS中所提供的对称加密算法有很多，其中最常用的当属 AES（Advanced Encryption Standard）既高级加密标准，密钥的长度可以是128，192，256，是当今用的最为广泛的对称加密算法。当然除了上面这个AES之外，我们国家也存在这自己的一套对称加密算法：SM1 和 SM4。其中SM1算法不公开，属于国家机密，而 SM4 则是公开的，可以自行使用，这两个算法的最大的优势就在于：国家支持！

对称加密还有一个分组的概念，他可以让算法用固定的长度的密钥加密任意长度的明文，从而将密钥转化为密文。最新的分组模式叫做AEAD，在加密的同时还增加了认证的功能。

对称加密就是通过上面的这些东西，来完成一个简单却安全的加密方式的。


### 2.2 非对称加密
对称加密看起来的确是解决了我们所说的安全要素中的机密性的要求，但它仍然存在一个致命的漏洞就是：密钥交互的方式仍然是明文的。也正是为了解决密钥安全的问题，我们就需要使用非堆成加密的方法，那什么是非堆成加密呢？非对称加密简单来说就是有两把私钥，一把是公钥，可以公开给任何人使用，一把是私钥，需要严格保密。这就形成了一个非对称性。具体举个栗子来讲就是：有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。

非对称加密除了可以对信息进行加密外，很多非对称加密算法还有签名的功能，这样就可以提供身份认证，保证通信双方可以确定对面的身份。

而从实现上来讲，所有的非对称加密算法，都是基于各种数学难题来设计实现的，这些难题的特点在于：正向计算很简单，反向推倒是无解的。其中比较经典的非对称加密算法包括：RSA，ECC以及SM2。


#### RSA
RSA 是所使用的数学难题是：两个大的质数相乘的结果很容易计算，但根据这个结果去做质因分解得到原先的两个质数，则需要很大的计算量。就比如这个：<br />[https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2019-December/001139.html](https://lists.gforge.inria.fr/pipermail/cado-nfs-discuss/2019-December/001139.html)。<br />前段时间美国一群大佬宣布，240哥十进制的整数分解成功，找到了它的两个大质数因子，不过这个成本也是很大的。


#### ECC && SM2
ECC和 SM2 都是是基于椭圆曲线的数学难题设计的。普遍的观点认为，椭圆曲线的难度高于大质数难题，160 位密钥的 ECC 加密强度，相当于 1088 位密钥的 RSA。因为密钥短，所以相应的计算量、消耗的内存和带宽也就少，加密解密的性能就上去了，因此对于互联网行业来讲吸引力也是相当大的。而SM2除了加密强度和国际标准和ECC差不多以外，还属于国家所支持的非对称加密算法。

需要注意的是，非对称加密的安全性上虽然可以满足我们的需求，但它却存在这一个比较大的问题就是L：性能。由于非对称加密在所需要的算法运算非常复杂，因此在性能上得不到很好的保证。也正是由于这个原因，现在的TLS主要采用的是一种叫混合加密的方式来进行加密。


#### 混合加密
混合加密其实很简单，就是使用非对称加密的方式，解决密钥交换的问题，然后用随机数产生对称算法使用的会话密钥，在对其使用公钥加密，并传送给通信对象。通信对象拿到密文后用私钥解开并取出会话密钥。这样就是实现了堆成密钥的安全交换了，后续就可以使用这个对称密钥来进行对称加密。


### 2.3 摘要算法（Digest Algorithm）
在前面我们有提到过安全的几大要素，其中机密性我们可以通过上面的对称加密 + 非对称加密来解决。而在完整性方面，我们则需要使用摘要算法来解决。

简单理解，我们可以将摘要算法理解为一种特殊的压缩算法，他可以将任意长度的数据压缩成固定长度且独一无二的摘要字符串，且这个加密的过程也是单向的，加密后的数据无法解密，不能从摘要中反向推出原文。


### 学习资料：
[https://time.geekbang.org/column/article/176569](https://time.geekbang.org/column/article/176569)<br />[https://time.geekbang.org/column/intro/189](https://time.geekbang.org/column/intro/189)——安全篇

