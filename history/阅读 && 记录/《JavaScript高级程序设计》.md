
# 第一章
1.一个完整的JS的实现应该包括下列三个不同的部分：核心（ECMASript),文档对象模型（BOM)浏览器对象模型（DOM).

2.ECMA-262给出了ECMAScript兼容的而定义。要想成为ECMAScript的实现，则该实现必须要做到：<br />	1.支持ECMA-262的描述的所有‘类型，值，对象，函数，属性以及程序语法和语义’。<br />	2.支持Unicode字符标准。<br />	3.添加ECMAScript没有描述的‘更多类型/值/对象/属性和函数’。ECMA-262所说的这些新增特性，主要是指该标准中没有规定的新对象和对象的新属性。<br />	4.支持ECMA-262没有定义的“程序和正则表达式语法”

3.文档对象模型是正对XML但经过扩展用于HTML的应用程序编程接口(API).DOM把整个页面映射为一个多层次节点结构。<br />

# 第二章 在HTML中的JS
1.向HTML页面中插入JS的主要方法，就是使用<script>元素。

2.HTML4.01为 script 定义看下列6元素（在此仅类而出在用元素）：<br />	1.async 表示应该立即下载脚本，但不应妨碍页面中的其他操作。只对外部脚本文件有效。<br />	2.charst 表示通过src属性制定的代码的字符集。但现在浏览器大不凡都会忽略它，因此不常用。<br />	3.defer 表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本有效。<br />	4.src 表示包含要执行的外部文件。<br />	5.type 表示编写代码使用的脚本语言的内容形式

3.而使用 script 元素的方式有两种：直接在页面嵌入JS中和包含外部JS文件。在使用嵌入时，秩序为 script 指定type属性。包含在 script 元素内部的JS代码将从上至下依次解释。在解释器对 script 元素内部所有代码求值完毕以前，页面的其余内容都不会被浏览器加载或显示.在使用嵌入式时，不要在代码中的任何地方出现 `/script`  字符串。

 在现代的web应用程序一般都不再将JS文件放在开头，而是放在 `</body>` 之后，这样可以在保证在解析包含JS代码之前，页面的内容将完全呈现在浏览器中。这样会加强用户体验。

4.异步脚本HTML5为 `<script>` 元素定义了async属性，可表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。。这个属性与defer属性类似，都用于改变处理脚本的行为。与defer相似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。与defer不同的是，标记为async的脚本并不保证按照指定他们的先后顺序执行。

5.XHTML 可扩展超文本标记语言。编写的规则比hrml要严格的多。

6.一般认为使用外部文件来包含JS代码要好。这样有可维护性，可缓存，适应未来。

7.文档模式：通过使用文档类型(doctype)切换实现的。最初的文档模式分为混杂模式和标准模式。<br />8.<noscript>:早期浏览器用于解决浏览器不支持js时使页面平稳退化。

 <br />

# 第三章 基本


 1.ECMAScript中的一切（变量，函数名和操作符）都区分大小写。

2.所谓标识符，就是指变量,函数，属性的名字或者函数的参数。标识符的规则：1.第一个字符必须是一个字母,下划线（-），美元符号。其他的则可以是字母下划线，美元符号或数字。

3.按照惯例，ECMAScript标识符采用驼峰大小写格式。列如：firstSecond,myCar.

4.ECMAScript使用C风格的注释，包括单行和多行注释。

5.ES5引入了严格模式的概念。在严格模式下，ES3的一些不确定的行为得到处理，且对不安全的操作也会抛出错误。在启用严格模式时，可以在顶部添加如下代码“use strict”.他是一个编译只是，用于高速支持的JS引擎切换到严格模式。

6.记住，ECMAScript中的语句以一个分号结尾。且代码块要用{}。

7.ECMA-262描述了一组具有与特定用途的关键字，这些关键字课用于表示控制语句的开始或结束，或者用于执行特定操作等。标识符也不能是关键字。保留字也不能是标识符。

8.ECMAScript的变量的松散类型的，可以用来保存任何类型的数据。

9.ECMAScript哟有五种简单数据类型：Undefined,Null,Boolean,Number,String.还有一种复杂数据类型Object.

10.typeof是可以检测给定变量的数据类型的操作符。

11.包含undefined值的变量与尚未定义的变量不一样。一个会返回Undefined，一个则会返回产生错误。

12.从逻辑角度来看，Null值表示一个空对象指针。因此在使用typeof操作符检测Null时会返回object。只要已在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样不仅可以体现null作为控队想指针的惯例，二千有助于进一步区分null和undefined.

13.字符串是不可改变的。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。

14.对象在ES中其实就是一组数据和功能的集合。对象可以通过执行new操作符后跟要创建的对象类型的名称来创建。

15.ECMA-262描述了一组用于操作数据值的操作符，包括算数操作符，位操作符，关系操作符和相等操作符。

16.只能操作一个值的操作符叫做一元操作符。

17.位操作符用于在最基本的二赠次上，即按内存中表示数值的位来操作数值。但不饿能操作64位，得将64转为32在进行操作再转化为64。

18.函数中，除了return语句之外，没有任何生命表示函数会返回一个值。函数在执行完return语句之后停止并立即退出。

19.ES函数并不介意传递进来多少个参数，也不在乎参数的数据类型。因为ES中的参数在内部是一个数组来表示的。函数接受的始终都是这个数组，而不会关心数组中包含哪些参数。实际上，在函数体呢可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。用法与数组相似。

20.ES不能像传统意义上那样实现重载。因为ES函数没有签名，其参数是由包含零或多个值的数组来表示的。


# 第四章 变量，作用域和内存问题


 1.ES变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。

2.JS不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。

3.当从一个变量向另一个变量复制应用类型的值时，同时也会将存储在变量对象中的值复制一份放在为新变量分配的空间中。不同的是，这个值的副本实际上一个指针，而这个指针指向存储在堆中的一个对象。因此，两个变量实际上将应用同一个对象。

4.在检测引用类型的值时，这个操作符的用处不大。而instanceof操作符则可以检测是什么类型的对象。

5.执行环境规定了变量或函数有权访问的洽谈数据，决定了他们各自的行为。每一个与之关联的变量环境都有一个与之关联的变量对象。执行环境有全局执行环境和函数执行环境之分。

6.在web浏览器中，全局执行环境都被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法

7.当代码在一个环境中执行时，会创建变量对象的一个作用链。作用链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行代码所在环境的变量对象。全局执行环境的变量对象始终都是作用域链的最后一个对象。每次进入一个新的执行环境，都会创建一个用于搜索变量和函数的作用域链。

8.在编写JS时，不用关心内存使用问题，所需内存的分配以及无用的回收完全实现了自动管理。

9.JS中最长用的垃圾收集方式是标记清除，另一个就是引用计数（现在不再使用，但IE中访问非原生JS还是会导致问题）。且为了优化内存，一旦数据不在有用，最好通过将其值设置为Null来释放其引用。这种做法叫做接触引用。

 <br />

# 第五章 引用类型


 1.引用类型的值（对象）是引用类型的一个实例。在ES中，引用类型是一种数据结构，用于将数据和功能组织在一起。它们也常被称为类，但这并不妥当。因为ES在技术层面上是一门面对对象的语言，但它并不具备传统的面向对象的语言所支持的了和接口等基本结构，引用类型有时候也被称为对象定义，因为他们描述的是一类对象所具有的属性和方法。

2.创建object实例的方式有两种，第一种是使用new操作符后跟object构造函数。另一种方式是使用对象字面两表示法。

3.ES数组除了与其他编程语言一样都是数据的有序列表外，不同的是，ES数组的而每一项都可以保存任何类型的数据。

4.创建数组的基本方式有两种。

1. 一种是Array构造函数。
2. 另一种则是使用数组字面量表示法。与对象的构建方法相同的是，在使用数组字面量表示法时，也不会调用Array构造函数。

<br />5.instanceof操作符能解决某个对象是不是数组的问题，但如果一个网页存在多个框架，则会存在多个全局执行环境，就会有多个Array构造函数，如果一个数组从一个框架传向另一个框架，那么传入的数组与在第二个框架中原生创建的数组便具有了不同的构造函数。而ES5新增了Array.isArray()方法。这个方法可以无视在那个全局环境创建的，而得出是不是数组。

6.调用数组的tostring()会返回有数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。

7.在调用toLocaleString()方法时，他会创建一个数组值的一逗号分隔的字符串。

8.ES数组也提供了push()和pop()方法，以便实现类似于栈的行为(后进先出)。push()方法可以接受任意数量的参数，把他们添加到数组的末尾，并返回修改后数组的长度。而pop()方法，则会从数组末尾一处最后一项，减少数组的length值，然后返回移除的项。

9.数组还有shift（）方法，它能够移除数组中的第一个项并返回该项。同时数组长度减1。

10.数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。其中reverse()方法会对方砖数组项的顺序。而sort()则默认按升序排列数组项，但sort()也会可以接受一个比较函数作为参数，以便我们指定那个值位于那个值得后面。

11.数组的concat方法可以基于当前数组中的所有项创建一个新数组。slice()则能够用基于当前数组的一过多个项创建一个新数组。

12.数组中的solice方法时最强大的数组方法。可以删除，插入，替换。其主要用途是想数组的中部插入项。

16.ES5为数组是咧添加了两个位置方法：indexOf()和lastIndexOf().这两个方法都接收两个参数：要查找的项和表示查找起点位置的索引。只不过前者在数组的开头找，后者在数组的末尾找。

17.ES5为数组定义了5个迭代方法。每个方法都接受两个参数:要在每一项上运行的函数与和（可选的）运行该函数的作用域对象——影响this的值。传入这些方法的函数会接收三个参数：数组项的值，该项在数组中的位置和数组对象本身。这五个迭代方法分别是：

- every()
- filter()
- foeEach()
- map()
- some()

<br />18.ES5海新增了两个缩小数组的方法：

- reduce()
- reduceRight().

这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。两个方法都接受两个参数：一个在每一项上调用的函数和（可选）作为缩小基础的初始值。传给reduce()和reduceRight()的函数接受4个参数：前一个值，当前值，项的索引和数组对象。两个方法作用相同，但方向相反。

19.ES通过RegExp类型支持正则表达式。正则表达式的匹配模式支持下列3个标志：

- g:表示全局模式，即模式将被应用于所有的字符串。而非在发现第一个匹配项立即停止。
- i：表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写；
- m:表示多行模式，即在到达一行文本末尾是还会继续查找下一行中是佛存在与模式匹配的项。

一个正则表达式就是一个模式和上述三个表示的组合体。不同的组合则会产生不同的结果。<br />20.RegRxp的每个是咧都会具有以下属性，通过这些属性可以取得有关模式的各种信息。

- global:布尔值，表示是否设置了g标志。
- ignoreCase:布尔值，表示是否设置了i标志。
- lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起。
- multiline：布尔值，表示是否设置m标志。
- source：正则表达式的字符串表示。按照字面量形式传入构造函数中的字符串模式返回。

<br />21.RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。

22.由于函数是对象，英雌函数名实际上也是一个指向函数对象的指正，不会与某个函数绑定。又因为ES中的函数名本省是对象，所以函数也可以作为值来使用。

23.在函数内部，有两个特殊的对象：arguements和this。arguements是一个类数组对象，包含着传入函数中的所有参数。该对象还有一个叫call的属性，是一个指针，可以返回正在执行的Functon对象。指向拥有argument对象的函数。this引用的是函数据以执行的环境对象。

24.ES中函数是对象，因此函数也有属性和方法。每个函数都包括两个属性：length和prototype.其中length属性表示函数希望接受的命名参数的个数。而在ES核心所定义的全部属性中，prototype最耐人寻味了。对于ES中的引用类型而言，prototype是保存他们所有实例方法的真正所在。且该属性不能被枚举。

25.ECMA-262定义了两个单体内置对象Global和Math.

26.Global是全局对象。包含了URI编码方法和eval()方法。eval()是ES语言最强大的一个方法。只接受一个参数，即要执行的字符串。可以欺骗作用域，但会严重影响性能，因此不推荐使用。<br />

# 第六章 面对对象的程序设计
1.ECAM-262把对象定义为：无序属性的集合，其属性可以包含基本值.对象或者函数。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。

2.数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为特性。

-  configurable:表示能否通过delete删除属性从而重新定义属性，能佛修改属性的特性，或者把属性修改为访问器属性。其默认值是ture。
-  enumerable：表示能否通过for-in循环返回属性。默认为ture。
-  writable：表示能否修改属性的值。默认为ture.
-  value:包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把属性值保存在这个位置。这个特性的默认值为undefined.

<br />3.访问器属性不包含数据值；他们包含一对儿getter和setter函数。访问器属性有如下四个特性：

- 	configurable：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为ture。
- 	emumerable：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为ture。
- 	get:在读取属性是调用的函数。默认值为undefined
- 	set:在写入属性是调用的函数。默认值为undefined.

	访问属性不能直接定义，必须使用object.defineProperty()来定义。

4.ES5定义了一个object.defineProperties()方法。可以为对象定义多个属性。

5.ES5的object.getOwnPropertyDescriptor（）方法。可以取得给定属性的描述符。<br />这个方法接受两个参数：属性所在的对象和要读取器描述符的属性名称。

6.虽然object构造函数或对象字面量都可以创建单个对象，但这些方式有个缺点：使用同一个接口创建对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。

7.工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建对象的过程。（注：其主要思路就是先创建一个函数，带有几个需要创建对象及其属性，然后返回这个对象。并在函数外部运行该函数并对其赋值。这样便可以通过函数创建多个对象。）

8.创建自定义的构造函数意味着将来可以将他的是咧标识为一种特定的类型。而构造函数与其他函数的唯一区别，就在于调用他们的方式不同。而构造函数的主要问题，就是每个方法都要在每个实例上面重新创建一遍。

9.我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。

10.只要创建一个新函数，就会根据一组特定的规则为该函数穿件一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。

11.有两种方式使用in操作符：单独使用和for-in循环中使用。在单独使用时，in操作符会在同过对象能够访问给定属性是返回true。

12.由于在原型其中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上映射出来——及时是先创建看实例后修改原型也照样如此。

13.所有原生的引用类型都是采用原型模式创建的.

14.原型模式省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。

15.创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。

16.寄生构造函数模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。对于它来说，返回的对象与构造函数或者与构造函数的原型属性之间没有关系。

17.稳妥构造函数模式，指的是没有公共属性，而且其方法也不会引用this的对象。这种方法适于在一些安全的环境中，或者防止数据被其他应用程序改动时使用。与寄生构造函数有两点不同：一是新创建对象的实例方法不引用this，二是不使用new操作符调用构造函数。

18.对于继承而言，ES只支持实现继承，即继承实际的方法。

19.原型链的基本思想是利用原型让一个应用类型继承另一个引用类型的属性和方法。

20.在解决原型中包含应用类型值所带来问题的过程中，人们开始使用一种叫做借用构造函数的技术。这种基本思想是在子类型构造函数的内部调用超类型构造函数。

21.相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超累型构造函数传递参数。但借用构造函数中函数的复用也就无从谈起了。

22.组合继承，指的是将原型链和借用构造函数的技术组合到一块。思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例函数的继承。

23.寄生式继承，与原型式继承非常类似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的抵消了文体，可以将这个模式与组合继承一起使用。

24寄生组合式继承，即寄生式和组合继承的优点与一身。即通过借用构造函数来调用超类型的构造函数，通过原型链的混成形式来继承方法。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。


# 第七章 函数表达式
1.闭包是指有权访问另一个函数作用域中的变量的函数。

2.当某个函数第一次被调用时，汇创建一个指向环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性。然后，使用this,grguements和其他命名参数的值来初始化函数的活动对象。但在作用域链中，外部函数的活动对于对象始终处于第二位。外部函数的外部函数处于第三位。直至作用域链的重点的全局执行环境。

3.作用域链的配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。

4.this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时。this等于那个对象。

5.由于JS中没有会计作用域，所以意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。

6.所有对象属性都是共有的。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数,局部变量和函数内部定义的其他函数。

7.我们把有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式。

1. 一种是在构造函数中定义特权方法。这个模式在构造函数内部定义了私有变量和函数。然后，又继续创建了能够访问这些私有成员的特权方法。能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问访问在构造函数中定义的所有变量和函数。
2. 通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法。这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其共有方法。共有方法是在原型上定义的，这一点体现了典型的原型模式。

<br />10.模块模式则是为单列创建私有变量和特权方法。所谓单例制度就是只有一个实例的对象。

11.JS中的函数表达式和闭包都是及其有用的特性，利用它们可以实现很多功能。不过因为创建闭包必须维护函数內部的私有作用域，所以过度使用他们可能会占用大量内存。

 

 <br />

# 第八章 BOM
0.W3C为了使BOM更标准化，将其纳入了HTML5的规范中。

1.BOM的核心对象是window，它表示浏览器的一盒实例。在浏览器中，window对象有双重角色，即是通过JS访问浏览器窗口的一个借口，又是ES规定的Global对象

2.网页中的任意对象，变量和函数。都以window作为Global对象，因此有权访问内置的方法。

3.所有在去全局作用域声明的变量，函数，都会变成window对象的属性和方法。

4.全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以。

5.尝试访问未申明的变量会抛出错误。而通过查询window对象，则可以知道某一个未申明的变量是否存在。

6.除非最高层窗口是通过window.open打开灯，否则其它window对象的name属性不会包含任何值

7.location提供了当前窗口中加载的文档有关的信息，还提供了一些导航信息。

8.location不仅保存着当前文档信息，还表示现在他将URL解析为独立的皮阿奴单，让人们可以通过不同的属性访问这些片段。

9.使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性的修改浏览器。

10.改变浏览器位置最常用的方法是设置location.href属性，但若不想用户有回退的功能，可以使用replace（）。这方法值接受1个参数，不会在浏览器的历史记录中生成新纪录。

11.navigator对象提供了与浏览器有关的信息，至于会是哪些信息取决于浏览器。

12.还有screen：保存这与客户端显示器有关的信息，这些信息一般只用于站点分析。

13.history则为访问浏览器的历史记录开了小缝，可以访问浏览器历史记录的数量也可向后或向前导航到任意页面。


# 第十章 DOM
1.DOM可以将任何HTML或XML文档描绘成一个有多层节点构成的结构。而节点也有不同的类型，每个节点也拥有各自的特点和方法

2.想要了解节点的具体信息是，可以使用nodeName和nodeValue两个属性

3.在文档中的节点与节点之间存在各种关系，且每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一个类数组对象，英语保存一组有序的节点，可以通过为止来访问这些节点。而要注意的是虽然 NodeList 可以通过方括号访问NodeList的值，而且也有length属性，但它并不是Array的实例（这与arguement一样）他实际上是基于DOM结构动态执行查询的结果，因此DOM结构的变化能自动反映在NodeList对象中。而对于NodeList则可以通过方括号，也可以使用item()

4.操作特性的方法有三个：

- getAttribute() 取得自定义特性的值
- setAttribute() 可以接受两个参数，要设置的特性名和值，若是该值存在，则指定的值会替换本来存在的值
- removeAttribute() 用于彻底删除元素的特性



5.调用removeNamedItem() 方法与在元素上调用remobeAttribute()方法的想过相同。直接删除给给定名称的特性，但removeNamedItem()返回表示被删除的Attr()节点

6.NodeList和NamedNodeMap和HTMLCollection三者是彻底理解DOM的关键。因为三者都是动态的。每当文档结构发生变化时，他们都会得到更新，保存着最新，最准确的信息。

