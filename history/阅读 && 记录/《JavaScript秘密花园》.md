
## 函数
函数是JS中的一等对象，这意味着可以吧函数象其他值一样传递。一个常见的用法是把匿名作为回调函数传递异步函数中。函数在执行前就会被解析，因此函数无论出现在上下文的任意一个地方都可以。

JS有一套完全不同于其他语言的对this的处理机制。在五种不同的情况下，this指向的各不相同。

   - 在全局范围内使用this，它将会指向全局对象即window.
   - 函数调用时，也会指向全局对象。ES5注意，在严格模式 下，不存在全局变量。这种情况下this将会是undefined.
   - 方法调用text.foo(); 在这个例子时this指向text对象。
   - 调用构造函数 new foo();如果函数倾向于和new关键词一块使用，则我们成这个函数是构造函数。在函数内部，this指向新创建的对象。
   - 当使用Function,property上的call或者apply方法时，函数内的this将会被显式设置为函数调用的第一个参数。

<br />

## 对象
 1.js中所有的变量都可以当做对象使用。除了两个例外null和undefined.<br />2.有一个常见的误解是数字的字面值不能当作对象来使用。这是因为JS解析器的一个错误，他试图将点操作符解析为浮点数字面值的一部分。对于该错误有几种方法Laura让数字的字面值看起来像对象。（可以在数字.toString中间加空格或者是.也可以是位数字加上括号）<br />3.JS的对象可以作为哈希表使用，主要用来保存命名的键与值的对应关系。<br />4.有两种方式来访问对象的属性，点操作符或者中括号操作符。这两种语法是等价的，但是中括号操作符在下面两种情况下依然有效。

1. 动态设置属性 
2. 属性名不是一个有效的变量名

5.删除属性唯一的方法是使用delete操作符；设置属性为undefined或者null并不能真正的删除属性，而仅仅是移除了属性和值的关联。<br />6.对象的属性名可以使用字符串或者普通字符声明、但由于JS解析器的另一个错误设计，上面的第二种声明方式在ES5之前会抛出错误。这个错误的原因是deleta是JS语言的一个关键词；因此未来在更低版本的JS引擎下也能正常运行，必须使用字符串字面值声明方式、<br />7.JS不包含传统的类继承模型（在ES6已结支持类继承模型了），而是使用prortype原型模型。<br />8.这两种方法的第一个不同之处在于JS使用原型链的继承方式。且改变任意一个对象的原型都会影响到另一个对象的原型。<br />9.当查找一个对象的属性时，JS会向上遍历原型链，知道找到给定名称的属性为止、当查找到原型链的顶部，也就是object.prototype但是仍然没哟刟指定的属性时，就会返回undefined。<br />10.当原型属性用来创建原型链时，可以把任何类型的值赋给它。然而将原子类型赋给prototype的操作符就会被忽略。（并不是很理解）<br />11.如果一个属性在原型链的上端，则对于查找实践将会带来不利影响。特别的，试图获取一个不存在的属性将会遍历这个原型链。在使用for in 循环遍历对象属性时，原型链上的所有属性都将被访问。这将会影响代码的执行效率。<br />12.一个错误特性被经常使用，那就是扩展object.prototype或者其他内置类型的原型对象。这种技术被称为monkey patching并且会破会封装。虽然他被广泛的应用到一些JS类库中，但作者仍然不认为内置类型添加一些非标准的函数是个好主意。<br />13.要充分理解原型链继承的工作方式，要提放原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。<br />14.为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自object.prototype的hasOwnProperty的方法。（通过判断一个属性是否是undefined是不够的，因为一个属性可能确实存在，只不过他的属性被设置为undefined），而hasOwnProperty是JS中唯一一个处理属性但是不查找原型链的函数。<br />15.for in和in操作符一样，同样在查找对象属性时遍历原型链上所有属性。且for in 循环不会遍历那些enumerable设置为false的属性；好比如数组的length属性。
