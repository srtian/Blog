<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/srtian/Blog</id><title>RSS feed of srtian's Blog</title><updated>2023-03-02T09:25:47.653038+00:00</updated><author><name>srtian</name><email>shenruotian@gmail.com</email></author><link href="https://github.com/srtian/Blog"/><link href="https://raw.githubusercontent.com/srtian/Blog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/srtian/Blog/issues/15</id><title>浅谈 Rust 前端应用开发</title><updated>2023-03-02T09:25:48.015055+00:00</updated><content type="html"><![CDATA[<p>随着技术的不断演进，近年来愈来越多的非前端开发语言诸如：Rust、Go 等也开始进入前端/跨端应用开发领域，并收获了不小的开源社区的关注。因此本次在此尝试对基于 Rust 的一些 前端/跨端 应用开发进行一些分析，来分析一下这种开发模式的技术基础、基本方案等情况，由于篇幅原因将分为两部分：第一部分，主要讨论 Rust 前端应用开发的基本现状、原理以及收益等，而第二部分则会讨论号称 Electron 终结者的 Tauri 的基本情况、最大卖点、基本架构组成等。
<a name="rwzVM"></a></p>
<h1>一、兴起的基础</h1>
<p>对于前端应用开发有一定了解的同学应该知道，可以在浏览器端运行的编程语言主要有两种：</p>
<ul>
<li>JavaScript</li>
<li>WebAssembly</li>
</ul>
<p>而诸如 Rust、Golang 等这样的编程语言并不具备直接运行在浏览器端的能力，当今的 Rust 前端应用开发框架之所以能得到落地，最主要还是得益于 WebAssembly 近年来的快速发展。其主要的流程就是将 Rust 编译成 WebAssembly ，然后在浏览器端运行，大致如下：<br />
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f7c090de8b499894d7d51381118c75~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<p>因此讨论 Rust 来进行前端开发，WebAssembly 是无法绕开的一环，它的诸多<a href="https://webassembly.org/">特性</a>也成为了 Rust/Go 等前端应用框架的卖点：</p>
<ul>
<li>Efficient and fast</li>
<li>Part of the open web platform</li>
<li>Safe</li>
</ul>
<p>这几点特性也让使用 WebAssembly 开发前端应用在技术上已经成为了可能。而另一方面，Rust 由于其优秀的语言设计以及强劲的性能，已经多年稳坐最受欢迎语言的排名榜首，这让越来越多的开发者加入到了 Rust 学习以及开发的中去，让 Rust 技术社区不断壮大，也让诸多 Rust 开发者不断思考着其能够发光发热的领域。<br />而此时前端领域也遇到了自己的瓶颈，随着前端开发领域的不断扩展，前端所要实现的业务复杂度也在不断增长，这也对前端应用在性能以及安全性上提出了更高的要求。虽然经过多年来的不断改进，JavaScript 在性能上都得到了长足的进步，但相较于系统级语言还是存在较大的差距。而 Rust 作为一门系统级语言，在具有强大的性能的同时，还提供强大的所有权系统以及类型体系，对安全性提供了强力的保障，这无疑是对 JavaScript 极好的补充。于是一方是快速壮大的技术社区在寻求充分的发挥场景，一方是要求不断提升的前端领域，这二者的结合也就顺理成章了。
<a name="futn1"></a></p>
<h1>二、基本介绍</h1>
<p><a name="JhEli"></a></p>
<h3>2.1、基本情况</h3>
<p>在介绍 Rust 开发前端应用之前，需要先补充一个小点，现在使用 Rust 开发前端应用有两种开发方式，我将其称称为激进派以及改良派。其中激进派的做法是整个应用全部使用 Rust 进行开发，然后将其编译为 WASM 运行在 WebView 或者浏览器中，这也是我们今天所讨论的开发方式。而改良派则倾向于将应用的一部分用 Rust 进行开发，然后将其作为一个 Module 和前端应用进行组合，这也是一种较为常见的开发方式，由于篇幅问题在此就不做过多介绍。<br />总的来说现今的开源社区的 Rust 前端框架基本呈现一超多强的局面，大体上有以下几个较为出名的开源项目： </p>
<ul>
<li><a href="https://github.com/yewstack/yew">Yew</a> : 当今最火的 Rust 前端框架，也是开发时间最早的一批框架了，其核心在于基于组件进行开发，Github 上已有 20k+ star。</li>
<li><a href="https://seed-rs.org/">Seed</a>：语法类似于 Elm。</li>
<li><a href="https://github.com/dioxuslabs/dioxus">dioxus</a>：类 React 的 Rust 前端框架，支持跨端开发（Web、Desktop、Mobile）。</li>
<li><a href="https://github.com/sycamore-rs/sycamore">sycamore</a>：类似于 Svelte，提供响应式开发。（有意思的是，这个框架自称的一大卖点是：<strong>No JavaScript</strong>: Had enough of JavaScript? So have we.）</li>
</ul>
<p>总的来看，这些框架在设计上，大体上具有几个比较共同的特性：</p>
<ol>
<li>基于组件开发，虽然在具体写法上存在一些区别，但总的来说都是如此。</li>
<li>或多或少的都有些现代前端框架的影子，譬如：Yew 和 dioxus 之于 React，sycamore 之于 Svelte。</li>
<li>基本使用 virtual dom 的方式来对 dom 的操作进行的一定的抽象（毕竟 Wasm 不能直接操作 DOM）。 </li>
</ol>
<p>光说不练假把式，本着实践是检验真理的唯一标准，我周末花了些时间使用 <a href="https://github.com/DioxusLabs/dioxus">dixous</a> 实现了一个 TodoMVC 应用，感兴趣的同学可以直接点看下面的链接，试着运行项目看看：</p>
<blockquote>
<p><a href="https://github.com/srtian/todomvc-dioxus">https://github.com/srtian/todomvc-dioxus</a></p>
</blockquote>
<p>从个人的开发体验上来看，由于 Rust 本身的语言设计和 JavaScript 有较大的区别，因此对于熟悉使用 JS/TS 的开发者来说，会有一定的 Gap，比如说状态管理时的区别；至于其他的诸如 JSX 等，由于这些框架都在借鉴 React 等前端框架的设计理念，所以总的来说差异并不大。
<a name="s0ygc"></a></p>
<h3>2.2、基本架构</h3>
<p>至于这些 Rust 前端框架的大体架构，由于大体上都是借鉴了现代前端框架的开发模式，差距并不大，总的来讲都会有一个 html 的宏来负责对 virtual_dom 的处理以及映射，此外还会提供前端路由、状态管理、异步处理等能力，来提升框架的易用性以及能力。这里将以 dioxus 为例其主要构成大体如下：<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73768d770324146ab23dcba181a2a4a~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />正如之前所介绍的，dioxus 是基于 react 的风格所开发的前端框架，因此其中很多东西都和 react 生态系统保持了高度的一致：</p>
<ul>
<li>其中 Router 借鉴了 react-router，主要提供了 hooks 和 components 这两个部分的能力: <a href="https://github.com/DioxusLabs/dioxus/blob/master/packages/router/src/lib.rs">router</a>：</li>
</ul>
<pre><code class="language-rust">mod hooks {
    mod use_route;
    mod use_router;
    pub use use_route::*;
    pub use use_router::*;
}
pub use hooks::*;

mod components {
    mod link;
    mod redirect;
    mod route;
    mod router;

    pub use link::*;
    pub use redirect::*;
    pub use route::*;
    pub use router::*;
}
pub use components::*;
</code></pre>
<ul>
<li>state 则主要是通过 hooks 来进行管理，按照其<a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks">官方描述</a>，主要有四个基础的 hooks：use_state、use_ref、use_future、use_coroutine。其中 use_state 和 use_ref 除了在使用以及能力上和 react 的 hooks 有些许区别外，其他的并无太大区别，而 use_future、use_coroutine 则主要用于处理异步的状态，具体使用场景可以移步官方文档对应的<a href="https://dioxuslabs.com/guide/async/index.html">章节</a>，写得很详细，在此就不做过多的赘述。</li>
<li>然后就是 Virtual DOM 了，这也是几乎所有 Rust 前端框架的重中之重。一方面由于 WebAssembly 操作 DOM 比 JavaScript 具有更高的成本，因此需要使用 Virtual DOM 来减少 DOM 的操作频率，以提升性能；其次在跨端/服务端渲染部分， Virtual DOM 也有着非常重要的作用。因此dioxius 的 Virtual DOM 在借鉴了 react 的相关优秀理念的同时，还借鉴了 <a href="https://github.com/fitzgen/dodrio">Dodrio</a> 诸如：Bump Allocation、Change List as Stack Machine 等等设计思想以提升其 Virtual DOM 的性能以及内存使用效率；最后还充分利用的 Rust 所有权的特性对内存进行优化。从而做到：通常情况下一旦加载了应用，就不再需要执行分配操作，只有当新组件被添加至 dom 中时，才会进行再分配；且对于给定的组件，添加新节点时，会动态的回收旧的虚拟DOM的空间；最后还会记录之前的组件的平均内存占用情况，从而预估未来组件需要分配多少内存。</li>
<li>最后 dioxus 提供了 rsx! 和 html! 这两个宏来为开发者提供类似于 JSX 的开发功能，本质上主要的能力就是将我们所写的 html/rsx 转化成 Virtual DOM ，没个元素则有下列属性组成：</li>
</ul>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
pub struct Element {
    pub name: Ident,
    pub key: Option&lt;LitStr&gt;,
    pub attributes: Vec&lt;ElementAttrNamed&gt;,
    pub children: Vec&lt;BodyNode&gt;,
    pub _is_static: bool,
}
</code></pre>
<p>至于在跨端部分，dioxus使用的实际还是 Tauri 所提供的 wry 来进行 WebView 的侨接。这块儿在下一部分来讲，再次就不做过多赘述了。
<a name="mgKX4"></a></p>
<h3>2.3、基本分析</h3>
<p><a name="kI2PZ"></a></p>
<h4>1、性能</h4>
<p>Rust 作为系统级的编程语言，在性能上的优势是毋庸置疑的，swc、postcss-rs 等工具的兴起最大的原因就在于此。譬如<a href="https://github.com/postcss-rs/postcss-rs">postcss-rs</a> 就给出的性能对比：<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7265e2bd88245b59cbc1aaa4a0190b4~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />从上图的直观表现来看，rust 在性能上较之 JS 具有非常大的优势。但这里的性能差距并不能作为讨论的前端应用开发场景下的依据。前面也提到过 Rust 并不能直接运行在浏览器端，需要编译成 WebAssembly 才能运行在浏览器端，所以对比的对象应该是 WebAssembly 和 JavaScript。<br />  而在Wasm方面，我们前面曾提到，虽然 WebAssembly 在性能上相较于 Javascript 有一定优势，但由于无法直接操作DOM，所以并不一定会在前端应用上有很好的表现，这也是很多早期 Wasm 用户所吐槽的点。但这个问题也只是暂时的，<a href="https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md">Interface Types</a> 计划完全解决这个问题，且随着 WebAssembly 的不断发展，这一情况也会得到改善，我们可以直接使用框架之间的 <a href="https://github.com/krausest/js-framework-benchmark">benchmark</a> 来进行对比（这里现在还不支持 dixous 进行对比，因此选用了 yew、sycamore 以及 wasm-bindgen ）：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/296173/1662101171226-d5dd9f4a-78cf-4211-a29e-1b639c635095.png#clientId=u892e03c0-70e3-4&amp;from=paste&amp;id=u3a2bb538&amp;originHeight=1594&amp;originWidth=1286&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufa5f0fd6-4418-481b-9705-fb03cf62782&amp;title=" alt="" /><br />可以看到，Rust 系的前端框架在常见的DOM操作方面的性能上大多和传统的前端框架没有明显的区别，甚至在一些场景下要优于 Angular 和 React。而在其他方面也表现很不错： <br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8c0fe924d54dff8ae0b48b80bc35c6~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />因此在性能上来讲，Rust 系的前端框架还是保持着一个较为不错的表现的，并没有出现所谓的 wasm 在 dom 操作上性能非常差的现象。而对于计算密集的场景，WASM 则要优于 JS，具体讨论可以看下述文章，在此就不再做过多的讨论了：<br /><a href="https://www.adservio.fr/post/how-fast-and-efficient-is-wasm">how-fast-and-efficient-is-wasm</a>。<br />总的来说，虽然WASM在操作DOM的性能上仍然存在较大的进步空间，但距传统前端框架的性能差距并不大；而在计算密集的场景下，则会有一定的优势。
<a name="d9gl2"></a></p>
<h4>2、安全</h4>
<p>基于 Rust 开发的应用在安全方面无疑也是具有竞争力的。首先 Rust 本身由于所有权系统以及生命周期来实现内存管理，没有运行时的GC，加之强大的编译器的代码检查，都为构建构建内存安全的应用提供了坚实的保障。<br />而对于 WebAssembly 来说，正如它自身的<a href="https://webassembly.org/docs/security/">文档</a>所说的，WebAssembly 的安全模型主要有两个目标：</p>
<ol>
<li>不让用户遭受 Bug 以及恶意模块的影响</li>
<li>为开发者提供足够的能力开发安全的应用</li>
</ol>
<p>首先在内存方面 WebAssembly 只提供一个沙盒化的线性内存（linear memory），致使其对内存的访问十分有限，只能对这个线性内存进行读写以及扩缩容，无法对其他内存进行操作。这虽然损失了一定的便利性，但在内存安全方面也提供了一些保障，对于 WASM 内存安全的详细介绍，可以参考下列文章：<br /><a href="https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/">https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/</a><br />而在控制访问方面。WASM 也做的非常的好：WebAssembly 代码本身是在一个由虚拟机管理的沙盒中封闭运行的，这让它与主机是相互隔离的，无法与主机直接进行交互。在这种情况下，如果想实现对系统资源的访问就只能通过虚拟机所提供的 WebAssembly 系统接口（<a href="https://github.com/WebAssembly/WASI">WASI</a>）来进行。而WASI 提供了基于能力的安全模型（Capability-based security），遵循最小权限原则，譬如在进行指定文件等资源的访问时，需要显示的在外部传入加有权限的文件描述符的引用，对于其他未授权的资源是无法访问的，这种依赖注入的方式可以避免很多传统安全模型的潜在风险。<br />总的来说，在安全方面 Rust + WebAssembly 的组合能帮助我们写出更加安全的应用，为用户的安全保驾护航。
<a name="vbirE"></a></p>
<h1>三、总结 &amp;&amp; 展望</h1>
<p>综上所述，Rust 开发前端应用开发主要是通过将代码编译为 WebAssembly 从而实现在浏览器端运行甚至是跨端的目的。但需要注意的是，站在2022年的来看，这种开发模式仍然还是稚嫩的，存在不少的问题：</p>
<ol>
<li>开发团队的搭建成本，虽然上文提到 Rust 已多年连续蝉联最受欢迎编程语言的榜首。但它学习曲线的陡峭性仍然会让很多开发者望而却步，因此当一个应用选择使用这种方式进行开发时，会需要搭建一个 Rust 开发团队，但显然搭建一个前端工程师团队还是会比搭建一个 Rust 开发团队要迅速、简单不少。</li>
<li>开发速度，前端场景下，大部分的业务强调的还是快准狠，现代前端框架也是向着这个方向发展的，而 Rust 在开发业务的速度上明显是很难与 React/Vue 相抗衡。 </li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcbec89e6e6a48beb019effb2a2fc2e3~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<ol start="3">
<li>生态系统的问题，虽然 Cargo 生态经过近几年的快速发展，已经到达了一个较为不错的水平，但要和广大的前端工程师的生态系统比，仍然存在一定差距，还需要一定的时间来进行追赶。</li>
</ol>
<p>也正是由于以上原因，以 Rust 为主力语言进行前端应用开发的方式并没有取得很多的落地。取得落地的反而是一些混合应用，比较典型的就是 Figma：将部分计算密集或者是业务逻辑复杂的模块使用 Rust/Cpp 进行开发，在这些模块内实现计算逻辑，对外暴露出计算结果/指令，然后通过 canvas 去对页面进行绘制，这样可以有效的缓解 WebAssembly 操作 DOM 所带来的性能损耗从而保障性能。至于整体都使用 Rust 进行开发，我想还需要 WebAssembly 得到足够的普及以及得到更好的发展，才能实现。<br />好了，本文对 Rust 进行前端应用开发进行了一个简单的介绍，下文将开始介绍号称 Electron 杀手的 Tauri，看它是如果利用我们在本文做介绍的这些基础能力，成为当今炙手可热的客户端应用开发方案的。</p>
<p>参考资料</p>
<ul>
<li><a href="https://training.linuxfoundation.org/blog/webassembly-security-now-and-in-the-future/">https://training.linuxfoundation.org/blog/webassembly-security-now-and-in-the-future/</a></li>
<li><a href="https://webassembly.org/">https://webassembly.org/</a></li>
<li><a href="https://github.com/WebAssembly/WASI">https://github.com/WebAssembly/WASI</a></li>
<li><a href="https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/">Memory in WebAssembly (and why it’s safer than you think)</a></li>
<li><a href="https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md">https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md</a></li>
<li><a href="https://rustwasm.github.io/docs/book/introduction.html">https://rustwasm.github.io/docs/book/introduction.html</a></li>
<li><a href="https://webassembly.org/docs/security/">https://webassembly.org/docs/security/</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/15" rel="alternate"/><published>2023-03-02T09:25:44+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/14</id><title>浅谈 Rust 所有权机制</title><updated>2023-03-02T09:25:48.347738+00:00</updated><content type="html"><![CDATA[<h1>一、什么是 stack 和 heap</h1>
<p>stack 和 heap 都用于变量的内存存储。对于大多数的编程人员来讲，都无需去关心内存是如何分配到 heap 和 stack 中的（实际上，对于 stack   和 heap 的区别，也很多人并不是很清楚）。譬如在JavaScript中，大多数人知道一个结论：基本数据类型放在 stack 中，而引用数据类型放在 heap 里面。但一旦问到，为何需要这样进行划分的时候，少有人可以说上一二。</p>
<p>那它们到底有什么区别呢？ 首先它们虽然都是可供代码使用的内存，但结构是不同的。 stack是一个线性的数据结构，以放入值得顺序存储值并以相反的顺序取出值，也就是我们常说的：后进先出。其数据的输入和取出，则通常被称为 进栈、出栈。由于 <code>stack</code>是线性的数据结构，所以 stack 中的所有数据都是必须占用<strong>已知且固定</strong>的大小。</p>
<p>而 heap 则是一个非线性的数据结构，是缺乏组织的。因此对于一些在初始时，大小未知或大小可能发生变化的数据，则可以放在堆中。当我们想要在堆中存储一些数据时，我们通常其实是请求一块大小合适的空间，然后操作系统在堆中搜索一个足够大的空间以匹配我们所请求的内存量，并将其标记为已用，并返回一个表示该位置地址的 **指针， **而这个指针也通常被存在 stack 中。这个过程也就是 <strong>堆内存分配</strong>，也常被称为 <strong>内存分配。</strong></p>
<blockquote>
<p>需要注意的是，将变量推入 stack 中，其实并不能被认为是内存分配，因为它本质上，只是按顺序压入 stack中，比不需要去进行显性的分配</p>
</blockquote>
<p>由于它们数据结构不同、存储方式不同。也决定了，将值压入 stack 要比在 heap 上进行内存分配要来的快。因为入 stack 时，操作系统无需为新数据搜索内存空间，位置固定于 stack 顶部，只需压入即可。而堆内存分配则需要先找到一块足够存放数据的内存空间，然后才能将变量放入，生成指针（很多时候，还需要将指针压入 stack 中保存）。同理，访问 stack 的变量也比访问 heap 得数据要快。</p>
<h1>二、什么是所有权</h1>
<p>搞清楚栈和堆得区别后，我们大致就可以清楚我们通常说的 GC 其实主要关注的就是 heap 上的内存的回收。而我们今天要说的的所有权，其实也是主要管理堆数据，例如：哪部分代码正在使用 heap上的哪些数据，最大限度的减少堆上的重复数据，清理堆上不再使用的数据确保不会耗尽空间。</p>
<p>所有的编程语言，都有着属于自己的管理计算机内存的方式。大体上可分为两个大的流派：</p>
<ol>
<li>语言自带垃圾回收机制，可以在程序运行时不断的去寻找不再使用的内存。比如JavaScript、Go等语言，就自带垃圾回收机制</li>
<li>语言没有自带垃圾回收，需要开发者亲自进行内存的分配和释放，比较典型的就是如 C、 C++。</li>
</ol>
<p>而Rust则没有走上面两条道路，而是通过所有权系统来管理内存，编译器在编译时会根据一系列的规则去对代码进行进行检查，确定变量的回收时机，因此，当程序运行时，所有权系统不会减慢程序。</p>
<p>而所有权系统具体有以下三点最重要的规则：</p>
<ul>
<li>Rust 中的每一个值都有一个被称为其 owner 的变量</li>
</ul>
<pre><code class="language-rust">let a = 5   // a 是 5 的 owner
</code></pre>
<ul>
<li>每个值在任何一刻都只能有一个 owner</li>
<li>当 owner 离开作用域时，这个值的内存将被回收</li>
</ul>
<h1>三、变量的作用域</h1>
<p>Rust 根据作用域管理指针，在作用域中申请内存，离开作用域则会释放作用域。Rust 中的作用域也非常简单, Rust 是词法作用域，以大括号为边界，一个大括号对应着一个作用域：</p>
<pre><code class="language-rust">fn main() {
    let content = String::from(&quot;Srtian&quot;);
    println!(&quot;{}&quot;,content);
}
</code></pre>
<p>比如如上的代码，在 <code>String::from</code> 处为 <code>content</code> 申请了内存，而在离开大括号后，content也就离开了作用域后被释放掉。</p>
<h1>四、所有权的具体表现</h1>
<p>上面几部分以及差不多将Rust的所有权系统简单的减少了一遍，接下来就让我们来看看，所有权系统到底是如何作用域 Rust 的内存管理的。</p>
<h2>4.1、所有权的移动</h2>
<p>在Rust中，对于已知大小的值，将其进行复制到另一个值会很容易：</p>
<pre><code class="language-rust">fn main() {
    let a =  &quot;5&quot; ; 
    let b = a ; //将值a复制到b 
    println!（&quot;{}&quot;, a)  // 5 
    println!(&quot;{}&quot;, b)  // 5 
} 
</code></pre>
<p>因此 a 存储在  <code>stack</code> 中，所以我们可以对其直接进行复制。但对于放在 <code>heap</code> 中的数据，我们就不能这么简单的进行复制了（放在 <code>heap</code> 中的数据，也就是被所有权系统所管理的数据）：</p>
<pre><code class="language-rust">fn main() { 
	let s1 = String::from(&quot;hello&quot;);
	let s2 = s1; // 将s1复制到s2
    println!(&quot;{}&quot;, s1)  // 这里会报错，因为s1在这里已经被释放了
    println!(&quot;{}&quot;, s2)  // hello
}
</code></pre>
<p>当我们运行上面代码时，会出现报错。这是因为，当我们复制存储在 <code>heap</code> 中的值时，Rust 为了防止诸如：二次释放这样的错误，它在处理这种场景时，会直接认为 s1 不再有效。这样 Rust 就无需再在 s1 离开作用域时再需要清理它。</p>
<p>熟悉诸如JavaScript等语言的朋友，应该对浅拷贝和深拷贝很熟悉，其实上述的这个操作有点浅拷贝的意思，它只会拷贝指针、长度和容量，而不会直接拷贝数据。但 Rust 同时也会让第一个变量直接无效，因此也不能粗暴的将其理解为浅拷贝。</p>
<blockquote>
<p>还有个需要注意的： Rust 永远不会自动创建数据的&quot;深拷贝&quot;。因此，所有自动的复制，都可以认为对于运行时的性能影响较小</p>
</blockquote>
<p>而当我们确实需要深拷贝去拷贝 heap 上的数据时，我们可以使用 <code>clone</code> 方法来对值进行深拷贝：</p>
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
	let s1 = String::from(&quot;hello&quot;);
	let s2 = s1.clone();
	println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
}
</code></pre>
<h2>4.2、所有权的借用</h2>
<p>所有权的移动或者变量的深拷贝并不能满足工程师们日常的开发需求，比如：</p>
<pre><code class="language-rust">fn main(){
    let contents = String::from(&quot;hello srtian&quot;);
    some_process(contents);
    println!(&quot;{}&quot;,contents); // error
}
fn some_process(word:String) {
    println!(&quot;some_process {}&quot;,word);
}
</code></pre>
<p>在上面的代码中， some_process(contents) contents变量会『移动』给some_process的参数word，contents变量就不能再次使用了。而且对于每次内存的重新分配，许多资源在时间和空间的开销都太昂贵了，但在日常开发中，类似的需求还是很多的。因此在这种情况下， Rust 提供了借用的选项。</p>
<p>所有权的借用也非常简单，我们只需在借用的变量前，加&amp;字符即可：</p>
<pre><code class="language-rust">struct Person {
    age: u8
}

fn main() {
    let jake = Person { age: 18 };
    let srtian = &amp;jake;

    println!(&quot;jake: {:?}\nsrtian: {:?}&quot;, jake, srtian);
}
</code></pre>
<p>在上述代码中，尽管没有 clone。但上面的代码仍然会编译并输出。同样，如果是不可复制的值被借用，可以将其作为参数传递给函数，也就是解决我们上面所说的那个问题：</p>
<pre><code class="language-rust">fn sum(vector: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let mut sum = 0;
    for item in vector {
        sum = sum + item
    }
    sum
}

fn main() {
    let v = vec![1,2,3];
    let v_ref = &amp;v;
    let s = sum(v_ref);
    println!(&quot;sum of {:?}: {}&quot;, v_ref, s); // 不会报错
}
</code></pre>
<p>不过，需要注意的是，对于借用来的变量，我们是不能对其进行更改的。这其实也符合我们日常生活的基本常识，借来的东西，我们都需要原样进行返回。不过，Rust 也提供了方法来对借用来的变量进行更改：</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}

</code></pre>
<p>我们需要将 s 修改为 mut。然后传入的参数以及接受的参数，都需要显式的表明是 mut 的。不过需要注意的是，在特定的作用域中，特定的数据只能有一个可变引用。这个限制允许可变性的存在，不过是以一种受限的方式允许的。这样做的好处在于 Rust 可以在编译时就避免 数据竞争。数据竞争类似于竞态条件，它可由三种行为造成：</p>
<ol>
<li>两个或更多指针同时访问统一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ol>
<p>有时候，我们会希望返回借来的值。比如我们想要返回字符串中较长的一个，我们可以写出如下的代码：</p>
<pre><code class="language-rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.bytes().len() &gt; y.bytes().len() {
        x
    } else {
        y
    }
}

fn main() {
    let jake = &quot;jake&quot;;
    let srtian = &quot;srtian&quot;;

    println!(&quot;{}&quot;, longest(jake, srtian));
}
</code></pre>
<p>以上的代码不能成功编译，会报错：</p>
<pre><code class="language-rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
                                ^ expected lifetime parameter
 
 = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>这就有关乎变量的生命周期了，生命周期是借用变量的有效范围。Rust 强大的编译器让我们在大多数情况下，无需显式的编写它们，而是通过推断去实现。但在一些需要生命周期参与的场景下，还是需要我们手动的去添加申明周期函数。譬如，我们想要解决上面的错误，就需要进行生命周期的手动声明：</p>
<pre><code class="language-rust">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {
    if x.bytes().len() &gt; y.bytes().len() {
        x
    } else {
        y
    }

fn main() {
    let jake = &quot;jake&quot;;
    let srtian = &quot;srtian&quot;;

    println!(&quot;{}&quot;, longest(jake, srtian));
}
</code></pre>
<p>如此我们就能将借用的变量进行返回来。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/14" rel="alternate"/><category term="Rust"/><published>2023-03-02T08:09:43+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/13</id><title>产品可用性之容错处理设计及实践</title><updated>2023-03-02T09:25:48.522926+00:00</updated><content type="html"><![CDATA[<h2>一、为什么说容错处理很重要</h2>
<p>B端产品由于其自身就具有一定的业务复杂度以及上手成本，因此在可用性方面，做好容错处理至关重要。一个好的容错处理既可以有效的提升用户使用产品的顺畅程度以及使用效率，也可以避免一些产品设计不够完善的问题的暴露。<br />
<br />下图是我在学习尼尔森十大可用性原则时所做的学习思维导图：<br /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/296173/1591757022787-9e968925-89d4-4a08-ad73-1f24b61a8298.svg" alt="" />从上述的思维导图我们不难发现，尼尔森所强调的可用性原则里面，绝大部分其实都和容错处理息息相关。我个人理解，容错处理我们可以在一下几个方面进行设计：</p>
<ol>
<li>在用户进行相关操作前，提供合理的引导，提示等有效的使用帮助。【2、环境贴切原则 10、人性化帮助原则】</li>
<li>用户在进行操作时，及时给予操作反馈以及实时错误提示（实时错误提示主要应用于表单）。【1、状态可见， 5、防错原则】</li>
<li>发生阶段性错误发生后，错误易定位，且错误易恢复，操作易重启。【3、撤销重做原则 9、容错原则】</li>
</ol>
<p>接下来，我将从以上三个方面，来阐述如果进行合理的容错处理。</p>
<h2>二、操作前的容错处理</h2>
<h3>2.1、环境贴切原则</h3>
<p>可能有些朋友会有疑惑：为何环境贴切原则会列到操作前的容错处理当中。但从我个人的经验以及理解来看：用户在进行一个操作时，所处的大环境会有效的有助于用户进行合理的自我下意识判断。首先我们要清楚的是，用户在进行操作的时候，大多数情况下，是下意思的行为，并不会在每个操作上都会去花费一定的心力成本去思考，这个操作进行后，会造成什么影响。因此一个熟悉的大环境或者是说熟悉的上下文环境，可以有利于用户不花费多余的心力成本就去完成一些操作。<br />
<br />这一点在AI平台就得到了很好的印证，早期AI平台由于产品规划的原因，只有英文版的。但实际上，我们的主要用户是公司内部的算法工程师，虽然这个群体普遍英文水平较高，但得到的反馈还是某些专业名词不够直观，不好理解。因此当时我就尝试去推动平台进行本地化，在原有的英文基础上，支持中文。在中文得到支持后，也得到了不少好的反馈，且从数据上来看，在支持中文以后，百分之90%以上的用户都使用中文版，且对于一些复杂表单的填写的错误率也下降了近三分之一。</p>
<h3>2.2、人性化帮助原则</h3>
<p>除了上述的环境贴切原则，另一方面就是给予用户足够的人性化的帮助，主要是以下几个方面：</p>
<h4>1. 新手引导</h4>
<p>新手引导算是现在互联网中最常见的帮助方式了，非常有利于用户快速上手。而对于B端产品，主要的实现方式主要包括：</p>
<ul>
<li>引导视频</li>
<li>引导文档</li>
<li>引导动画</li>
</ul>
<p>比如AI平台就给予了一个全面的帮助文档来让用户可以快速了解平台的基础功能，以及一些相关的专业名词的含义：<br />                                                       <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591340878952-3daed16d-c0ca-4ee6-8a1b-e75d13dd6cdf.png#align=left&amp;display=inline&amp;height=396&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1188&amp;originWidth=480&amp;size=76949&amp;status=done&amp;style=none&amp;width=160" alt="image.png" /></p>
<h4>2. 表单设计合理并给予有效引导</h4>
<p>从数据录入的操作便捷程度来讲：单选 &gt; 选择型下拉框(select) &gt; 输入框。此外对于一些具有相应填写规则的表单，也需要给予一些提示，具体方式主要有以下几种：</p>
<ul>
<li>使用 <code>placeholder</code> 对输入内容进行提示</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591351917689-b08a9eb0-dadc-46e7-846e-ed20fd27290a.png#align=left&amp;display=inline&amp;height=42&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=126&amp;originWidth=1100&amp;size=12160&amp;status=done&amp;style=none&amp;width=366.6666666666667" alt="image.png" /></p>
<ul>
<li>使用提示icon，将填写规则说明：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352213692-fca28354-cc08-4990-be53-188849d5bacf.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=258&amp;originWidth=1742&amp;size=42359&amp;status=done&amp;style=none&amp;width=580.6666666666666" alt="image.png" /></p>
<h4>3. 操作提醒的设置</h4>
<p>对于一些比如删除等不可逆的操作时，我们也需要在用户进行操作前，给予有效的提醒，这样可以有效的减少用户的误点误删的事情发生：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352474964-982eafd9-58a8-4beb-b7e1-366f75136d4d.png#align=left&amp;display=inline&amp;height=93&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=278&amp;originWidth=1256&amp;size=35655&amp;status=done&amp;style=none&amp;width=418.6666666666667" alt="image.png" /><br />此外，在表单填写时，也应该给予实时的提醒，让用户可以在填写时就知道自己的填写内容是错误的，从而及时的更正，而不是要等要点击提交按钮时才会抛出异常或者错误，这一块Ant Design的表单就做的很好：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352663302-fb84f114-f2b0-40a9-8eab-cf270e863c9e.png#align=left&amp;display=inline&amp;height=45&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=134&amp;originWidth=1224&amp;size=24954&amp;status=done&amp;style=none&amp;width=408" alt="image.png" /></p>
<h2>三、操作时的容错处理</h2>
<p><a name="uXxlF"></a></p>
<h3>3.1、状态可见原则</h3>
<p>这里的状态可见，从大的方面来讲，可以理解为一个任务的状态，在这个方面，大家都做的不错；但从小的方面来讲，状态可以是一次搜索，一次表单的填写等这样小的操作。比如搜索，如果没有搜索到对应的内容，在一些场景下就需要提醒：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591354809203-06f00d65-84fa-4643-978b-bcf0fb3994a6.png#align=left&amp;display=inline&amp;height=51&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=152&amp;originWidth=1058&amp;size=30922&amp;status=done&amp;style=none&amp;width=352.6666666666667" alt="image.png" /><br />以及我上面，在人性化帮助原则中第3点所提到的，表单的填写需要实时的提醒，其实也是状态可见原则的表现。<br /></p>
<h3>3.2、防错限制的设置</h3>
<p>对于一些比较常发生的错误，我们也可以通过一些权限设置，或者是直接给予默认值等设置，来避免类似错误的发生。比如给表单设置默认项，不可操作的按钮进行置灰并给予相应的置灰解释：<br />                                                          <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352946704-bb920a17-a5f4-4550-8e26-542bf7ef7077.png#align=left&amp;display=inline&amp;height=66&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=544&amp;size=21088&amp;status=done&amp;style=none&amp;width=181.33333333333334" alt="image.png" /></p>
<h2>四、错误发生后的容错处理</h2>
<h3>4.1、错误发生后，及时提供错误信息</h3>
<p>这一项在AI 平台或者类似的一些平台所需要的，比如在AI平台发起一个编译任务，如果此项任务发生错误，就应该在展示错误状态外，还停供相关的错误信息，以方便用户快速进行定位，修复相关错误：<br />                           <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591690266586-6b2fd6ca-750d-4533-8d08-59447ed3f998.png#align=left&amp;display=inline&amp;height=26&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=45&amp;originWidth=836&amp;size=6891&amp;status=done&amp;style=none&amp;width=491" alt="image.png" /><br /></p>
<h3>4.2、错误操作发生后，提供完善的保障机制</h3>
<p>对于B端产品来说，用户经常也会出现误删资源的操作。因此如果在这些操作进行时，在进行提醒之外，应该还具有一定的回溯机制。比如在AI平台现在在Web端对一个资源进行删除，但其实只是暂时删除了一个映射关系，其底层的资源暂时是没有被删除的，仍然存储在数据库中，只有到了一定的时间，才会去清理相应的资源。这样做的好处就在于，虽然耗费了一定的空间，但大大的降低了数据损失的风险（这块除了这一处理方式，其实对于数据集这样的资源，本身就会对不太常用的数据集放入磁带，因此删除也只是解除映射关系之余将这个资源打入冷资源中）</p>
<p>除此之外，对于一些链路比较长的任务，我们也应该提供完善的回退机制，保证用户在当前阶段发生错误时，可以回退到上一步，而不至于整个任务全部失败，需要从头再来，比如以一个算法模型的半自动化的生产链路来讲：<br />
<br /></p>
<p>这是一个很长的生产链路，所耗费的时也很长，因此在进行模型半自动化生产的过程中，如果因为其中一个任务出现了问题，而导致整个链路都需要重新开始，实在是太不友好了。因此需要将上述步骤提供完善的错误回退机制，比如预测任务发起失败，只需要提示用户预测任务发起失败，然后给予用户完善的错误信息提示，待用户解决问题后，直接重新发起预测任务即可。<br />
<br />类似的例子还有很多，比如PS，LR等操作软件，也提供了历史记录的功能，可以轻松回退的相应的地方<br /></p>
<h2>结语</h2>
<p>上述只是我个人在实践过程中的一些体会以及方法论，因为大家的产品特征不同，所要解决的问题，目标用户群体也不同。因此在具体的设计时，要根据自身的特点，去因地制宜的设计合理的容错处理机制。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/13" rel="alternate"/><category term="Web"/><category term="产品"/><category term="Top"/><published>2020-06-10T07:07:06+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/12</id><title>简述JavaScript模块化编程</title><updated>2023-03-02T09:25:48.762245+00:00</updated><content type="html"><![CDATA[<h1>简述JavaScript模块化编程</h1>
<p>在早期编写JavaScript时，我们只需在 script 标签内写入JavaScript的代码就可以满足我们对页面交互的需要了。但随着时间的推移，时代的发展，原本的那种简单粗暴的编写方式所带来的诸如逻辑混乱，页面复杂，可维护性差，全局变量暴露等问题接踵而至，前辈们为了解决这些问题提出了很种的解决方案，其中之一就是JavaScript模块化编程。总的来说，它有以下四种优点：<br /></p>
<ol>
<li>解决项目中的全局变量污染的问题。</li>
<li>开发效率高，有利于多人协同开发。</li>
<li>职责单一，方便代码复用和维护 。</li>
<li>解决文件依赖问题，无需关注引用文件的顺序。</li>
</ol>
<p><a name="GU4V3"></a></p>
<h3>一、先行者CommonJs</h3>
<p><br />2009年Node.js横空出世，将JavaScript带到了服务器端领域。而对于服务器端来说，没有模块化那可是不行的。因此CommonJs社区的大牛们开始发力了，制定了一个与社区同名的关于模块化的规范——CommonJs。它的规范主要如下：<br /></p>
<ol>
<li>模块的标识应遵循的规则（书写规范）。</li>
<li>定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴露出来的API。</li>
<li>如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖。</li>
<li>如果引入模块失败，那么require函数应该报一个异常。</li>
<li>模块通过变量exports来向外暴露API，exports只能是一个对象，暴露的API须作为此对象的属性。</li>
</ol>
<p><br />根据CommonJS规范的规定，每个文件就是一个模块，有自己的作用域，也就是在一个文件里面定义的变量、函数、类，都是私有的，对其他文件是不可见的。通俗来讲，就是说在模块内定义的变量和函数是无法被其他的模块所读取的，除非定义为全局对象的属性。<br /></p>
<pre><code>// addA.js
const a = 1;
const addA = function(value) {
  return value + a;
}
</code></pre>
<p><br />上面代码中，变量a和函数addA，是当前文件addA.js私有的，其他文件不可见。如果想在多个文件中分享变量a，必须定义为global对象的属性：<br /></p>
<pre><code>global.a = 1;
</code></pre>
<p><br />这样我们就能在其他的文件中访问变量a了，但这种写法不可取，输出模块对象最好的方式是module.exports：<br /></p>
<pre><code>// addA.js
var a = 1;
var addA = function(value) {
  return value + x;
}
module.exports.addA = addA;
</code></pre>
<p><br />上面代码通过module.exports对象输出了一个函数，该函数就是模块外部与内部通信的桥梁。加载模块需要使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。<br /></p>
<pre><code>var example = require(&#x27;./addA.js&#x27;);
console.log(example.addA(1));  //2
</code></pre>
<p><br />CommonJs看起来是一个很不错的选择，拥有模块化所需要的严格的入口和出口，看起来一切都很美好，但它的一个特性却决定了它只能在服务器端大规模使用，而在浏览器端发挥不了太大的作用，那就是同步！这在服务器端不是什么问题，但放在浏览器端就出现问题了，因为文件都放在服务器上，如果网速不够快的话，前面的文件如果没有加载完成，浏览器就会失去响应！因此为了在浏览器上也实现模块化得来个异步的模块化才行！根据这个需求，我们的下一位主角——AMD就产生了！<br /></p>
<p><a name="8mpSo"></a></p>
<h3>二、AMD 异步模块定义</h3>
<p><br />AMD的全名叫做：Asynchronous Module Definition即异步模块定义。它采用了异步的方式来加载模块，然后在回调函数中执行主逻辑，因此模块的加载不影响它后面的模块的运行。它的规范如下：<br /></p>
<pre><code>define(id?, dependencies?, factory);
</code></pre>
<ol>
<li>用全局函数define来定义模块;</li>
<li>id为模块标识，遵从CommonJS Module Identifiers规范</li>
<li>dependencies为依赖的模块数组，在factory中需传入形参与之一一对应</li>
<li>如果dependencies的值中有&quot;require&quot;、&quot;exports&quot;或&quot;module&quot;，则与commonjs中的实现保持一致</li>
<li>如果dependencies省略不写，则默认为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]，factory中也会默认传入require,exports,module</li>
<li>如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx</li>
<li>如果factory为对象，则该对象即为模块的返回值</li>
</ol>
<p><br />具体分析AMD我们通过require.js来进行。require.js是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一，require.js的出现主要是来解决两个问题：<br /></p>
<ol>
<li>实现JavaScript文件的异步加载，避免网页失去响应。</li>
<li>管理模块的依赖性，管理模块的相互独立性，也就是我们常说的低耦合，这有利于代码的编写与维护。</li>
</ol>
<p><br />使用require.js我们首先要加载它，为了避免浏览器未响应，我们在后面可以加上async,告诉浏览器这个文件需要异步加载（IE不支持该属性，所以需要把defer也加上）：<br /></p>
<pre><code>&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;
</code></pre>
<p><br />定义模块时，在require.js中我们可以使用define，但define对于需要定义的模块是否是独立的模块的写法是不同;所谓的独立模块就是指不依赖于其他模块的模块，而非独立模块就是指不依赖于其他模块的模块。<br />
<br />define在定义独立模块时有两种写法，一种是直接定义对象；另一种是定义一个函数，在函数内的返回值就是输出的模块了：<br /></p>
<pre><code>define({
    method1: function() {},
    method2: function() {},
});
//等价于
define(function () {
	return {
	    method1: function() {},
		method2: function() {},
    }
});
</code></pre>
<p><br />如果define定义非独立模块，那么它的语法就规定一定是这样的：<br /></p>
<pre><code>define([&#x27;module1&#x27;, &#x27;module2&#x27;], function(m1, m2) {

    return {
        method: function() {
            m1.methodA();
			m2.methodB();
        }
    }

});
</code></pre>
<p><br />define在这个时候接受两个参数，第一个参数是module是一个数组，它的成员是我们当前定义的模块所依赖的模块，只有顺利加载了这些模块，我们新定义的模块才能成功运行。第二个参数是一个函数，当前面数组内的成员全部加载完之后它才运行，它的参数m与前面的module是一一对应的。这个函数必须返回一个对象，以供其他模块调用，需要注意的是，回调函数必须返回一个对象，这个对象就是你定义的模块。<br />
<br />在加载模块方面，AMD和CommonJs都是使用require。require.js也同样如此，它要求两个参数：module，callback：<br /></p>
<pre><code>require([module], callback);
</code></pre>
<p><br />第一个参数[module]，是一个数组，里面的成员就是需要加载的模块；第二个参数callback，则是加载成功之后的回调函数。<br />require方法本身也是一个对象，它带有一个config方法，用来配置require.js运行参数。config方法接受一个对象作为参数。<br /></p>
<pre><code>//别名配置
requirejs.config({
    paths: {
        jquery: [   //如果第一个路径不能完成加载，就调到第二个路径继续进行加载
            &#x27;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&#x27;,
            &#x27;lib/jquery&#x27;   //本地文件中不需要写.js
        ]
    }
});

//引入模块，用变量$表示jquery模块
requirejs([&#x27;jquery&#x27;], function ($) {
    $(&#x27;body&#x27;).css(&#x27;background-color&#x27;,&#x27;black&#x27;);
});
</code></pre>
<p><br />虽然require.js实现了异步的模块化，但它仍然有一些不足的地方，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载，使得初次加载其他模块的速度较慢，提高了开发成本。<br /></p>
<p><a name="TZgDs"></a></p>
<h3>三、CMD 通用模块定义</h3>
<p><br />CMD的全称是Common Module Definition，即通用模块定义。它是由蚂蚁金服的前端大佬——玉伯提出来的，实现的JavaScript库为sea.js。它和AMD的require.js很像，但加载方式不同，它是按需就近加载的，而不是在模块的开始全部加载完成。它有以下两大核心特点：<br /></p>
<ol>
<li>简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。</li>
<li>自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。</li>
</ol>
<p><br />在CMD规范中，一个文件就是一个模块，代码书写的格式是这样的：<br /></p>
<pre><code>define(factory);
</code></pre>
<p><br />当factory为函数时，表示模块的构造方法，执行该方法，可以得到该模块对外提供的factory接口，factory 方法在执行时，默认会传入三个参数：require、exports 和 module：<br /></p>
<pre><code>// 所有模块都通过 define 来定义
define(function(require, exports, module) {

  // 通过 require 引入依赖
  var $ = require(&#x27;jquery&#x27;);
  var Spinning = require(&#x27;./spinning&#x27;);

  // 通过 exports 对外提供接口
  exports.doSomething = ...

  // 或者通过 module.exports 提供整个接口
  module.exports = ...

});
</code></pre>
<p><br />它与AMD的具体区别其实我们也可以通过代码来表现出来，AMD需要在模块开始前就将依赖的模块加载出来，即依赖前置；而CMD则对模块按需加载，即依赖就近，只有在需要依赖该模块的时候再require就行了：<br /></p>
<pre><code>// AMD规范
define([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) {  // 依赖必须一开始就写好  
   a.doSomething()    
   // 此处略去 100 行    
   b.doSomething()    
   ...
});
// CMD规范
define(function(require, exports, module) {
   var a = require(&#x27;./a&#x27;)   
   a.doSomething()   
   // 此处略去 100 行   
   var b = require(&#x27;./b&#x27;) 
   // 依赖可以就近书写   
   b.doSomething()
   // ... 
});
</code></pre>
<p><br />需要注意的是Sea.js的执行模块顺序也是严格按照模块在代码中出现(require)的顺序。<br />
<br />从运行速度的角度来讲，AMD虽然在第一次使用时较慢，但在后面再访问时速度会很快；而CMD第一次加载会相对快点，但后面的加载都是重新加载新的模块，所以速度会慢点。总的来说,<br />require.js的做法是并行加载所有依赖的模块, 等完成解析后, 再开始执行其他代码, 因此执行结果只会&quot;停顿&quot;1次, 而Sea.js在完成整个过程时则是每次需要相应模块都需要进行加载，这期间会停顿是多次的，因此require.js从整体而言相对会比Sea.js要快一些。
<a name="hZM1K"></a></p>
<h3>四、ES6模块特性</h3>
<p><br />在ES6中将模块认为是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。在一个模块中定义的变量不会自动被添加到全局共享的作用域之中，这个变量只能作用在这个作用域中。此外模块还必须导出一些外部文件可以访问的元素，以供其他模块或代码使用。<br />
<br />除了这个基本特性，ES6模块还有两大特性也十分重要，需要额外注意：<br /></p>
<ul>
<li>首先是在模块的顶部this值是undefined，这是由于在ES6中的模块的代码是在严格模式下执行的。（如果对this不是很熟悉的可以去看我的这篇文章<a href="https://www.jianshu.com/p/8d6cc7ad9c58/">：深入浅出this关键字</a>）</li>
<li>其次，模块不支持HTML风格的代码注释，这是早期浏览器所遗留下的JavaScript特性，在ES6的语法里不予支持。
<a name="b3340053"></a></li>
</ul>
<h4>4.1、基本用法-模块加载</h4>
<p><br />首先我们来看浏览器是如何加载模块的。其实在ES6规范出来之前，web浏览器就规定了三种方式来引入JavaScript文件：<br /></p>
<ul>
<li>在没有src属性的 script 元素中直接内嵌JavaScript代码</li>
<li>在 script 元素中通过src属性指定一个地址来加载JavaScript代码文件</li>
<li>通过Web Worker或Service Worker的方法加载并执行JavaScript代码<br />
而在浏览器中，默认的行为就是将JavaScript作为脚本来进行加载，而非模块。所以我们要告诉浏览器我们加载的是模块，方法就是在 script 元素中，将type属性指定为&quot;module&quot;。具体看下面的示例：</li>
</ul>
<pre><code>// 第一种方式
&lt;script type=&quot;&quot;module&gt;
   import { add } from &quot;./example&quot;;
   let num = add(1, 1);
&lt;/script&gt;
//  第二种方式
&lt;script type=&quot;module&quot; src=&quot;example.js&quot;&gt;
// 第三种方式，以脚本的方式加载example.js
let worker = new Worker(&quot;example.js&quot;);
</code></pre>
<p><br />当HTML解析器遇到 script 元素的type=&quot;module&quot;的时候，模块文件就开始下载，直到文件被完全解析完成才会去执行模块内的代码。模块文件是按照他们出现在HTML文件中顺序执行的，也就是说无论用何种方式引入模块，第一个 script type=&quot;module&quot; 总是在第二个 script type=&quot;module&quot; 之前执行。<br /></p>
<p><a name="0384f32d"></a></p>
<h4>4.2、基本用法-导出</h4>
<p><br />在ES6中我们可以使用export关键字将一部分代码暴露给其他模块，以供其他模块或代码使用。先让我们来看看export关键字在MDN的定义吧：<br /></p>
<blockquote>
<p>export语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。（
此特性目前仅在 Safari 和 Chrome 原生实现。它在许多转换器中实现，如Traceur Compiler，Babel或Rollup。）
通过MDN的定义我们可以知道：export关键字可以将其放在任何函数、对象或原始值前面，从而将它们从模块中导出。示例如下：</p>
</blockquote>
<pre><code>//   ./example.js
// 导出变量
export var a = 1;
// 导出函数
export function addA(value) {
   return value + a;
}
//导出类
export class add1 {
   constructor(value) {
       this.value = value + a;
   }
}
//这个函数就是这个模块所私有的，在外部不能访问它
function say1() {
   console.log(&#x27;我是不是很帅&#x27;);
}
//这又是个函数
function say2() {
   console.log(&#x27;没错我就是很帅&#x27;);
}
//在后面对函数进行导出,它就不是私有的了
export say2;
</code></pre>
<p><br />需要注意的是：使用export导出的函数和类都需要一个名称，除非使用default关键字，否则就不能用这个方法导出匿名函数或类。所以当我们需要导出匿名的函数或者类时，我们可以这么做：<br /></p>
<pre><code>//   ./example.js
//导出匿名函数
export default function(a, b) {
   return a + b；
}
//或者导出匿名的类
export default class {
consturctor(value) {
   this.value = value + 1;
   }
}
</code></pre>
<p><br />具体关于default关键字的用法我会在后面做具体介绍，现在只需记住：当我们需要导出匿名的函数或者类时要使用export default语法。<br /></p>
<p><a name="ac2d4199"></a></p>
<h4>4.3、基本语法-导入</h4>
<p><br />在ES6中，从模块中导入的功能可以通过import关键字。import语句由两部分组成：要导入元素的标识符和元素应当从哪个模块导入。<br /></p>
<pre><code>//  ./say.js
import { say2 } from &quot;./example.js&quot;;
console.log(say2()); // &#x27;没错我就是很帅&#x27;
</code></pre>
<p><br />import 后面的大括号中的say2表示从规定模块导入的元素的名称。关键字from后面的字符串则表示要导入的模块的路径，这通常是包含模块的.js文件的相对或绝对路径名，需要注意的是只允许使用单引号和双引号的字符串来包裹路径，浏览器使用的路径格式与传给 script 元素的相同，所以必须把文件的扩展名也加上。<br /></p>
<blockquote>
<p>（注：由于Node.js遵循基于文件系统前缀以区分本地文件个包的惯例，即example是一个包，而./exampple.js是一个本地文件。为了更好的兼容多个浏览器Node.js环境，我们一定要在路径前包含./或../来表示要导入的文件。）
除此之外，我们还可以导入多个元素或者直接导入整个模块：</p>
</blockquote>
<pre><code>// 导入多个元素
improt { a, addA, say2 } from &quot;./example.js&quot;;
console.log(a); // 1
sonsole.log(addA(1); // 2
// 导入整个模块
import * as example from &quot;./example.js&quot;
console.log(example.a); // 1
sonsole.log(example.addA(1); // 2
console.log(example.say2()); // &#x27;没错我就是很帅&#x27;
</code></pre>
<p><br />上面的导入整个模块就是把example.js中导出的所有元素全部加载到一个叫做example的对象中，而所导出的元素就会作为example的属性被访问。因为example对象是作为example.js中所导出成员的命名空间对象而被创建的，所以这种导入方式被称为命名空间导入（name space import)。<br />还有一点要注意的是，不管import语句把一个模块写了多少次，该模块只执行一次。意思就是，在首次执行导入模块后，实例化的模块就会被保存在内存中，只要使用import语句引用它就可以重复使用它：<br /></p>
<pre><code>// 首次导入需要加载模块example.js
import { a } from &quot;./example.js&quot;
// 下面的两个import将无需加载example.js了
import { addA } from &quot;./example.js&quot;
import { say2 } from &quot;./example.js&quot;
</code></pre>
<p><br />当从模块中导入一个元素时，它与const是一样无法定义另一个同名变量和导入一个同名元素，也无法在import语句前使用元素或者改变导出的元素的值：<br /></p>
<pre><code>//接上面的代码
say2 = 1 ;  //会抛出一个错误
</code></pre>
<p><br />这是由于ES6的import语句为导入的元素创建的是只读绑定的标识符，而不是原始绑定。因此元素只有在被导出的模块中才可以被修改，即使是将该模块的全部导入也无法修改其中的元素。<br /></p>
<pre><code>//   ./example.js
// 这是一个函数
export function setA(newA) {
   a = newA;
}
//  ./say.js
import { a, setA } from &quot;./example&quot;;
console.log(a);  // 1
a = 2;   //抛出错误
// 所以我们得这么做
setA(2);
console.log(a);  // 2
</code></pre>
<p><br />调用setA(2)时会返回到example.js中去执行，将a设置为2。由于say.js导入的只是a的只读绑定的标识符而已，因此会自动进行更改。<br /></p>
<p><a name="28d578f4"></a></p>
<h4>4.4、其他基本语法</h4>
<p><a name="493e9ebb"></a></p>
<h5>1.语法限制</h5>
<p><br />export和import在语法上还有一个重要的限制，那就是他们必须在条件语句和函数之外使用，例如：<br /></p>
<pre><code>if (ture) {
   export var a = 1;      //语法错误
}
function imp() {
   import a from &quot;./example.js&quot;; //语法错误
}
</code></pre>
<p><br />由于模块语法存在的其中一个原因是让JavaScript引擎可以静态地确定哪些代码是可以导出的，因此export和import语句被设计成静态的，不能进行任何形式的动态导出或导入。<br /></p>
<p><a name="19702694"></a></p>
<h5>2.重命名解决</h5>
<p><br />有时在开发中，我们在导入一些元素后不想使用它们的原始名称了，我们就可以在导出过程或者导入过程中去改变导出元素的名称：<br /></p>
<pre><code>// 导出过程
function add(a, b) {
   return a + b;
}
export { add as add1 };  //在导入过程中必须使用add1作为名称
// 导入过程
import {add as add1 } from &quot;./example&quot;
console.log(add1(1,1));  // 2
console.log(typeof add); //undefined
</code></pre>
<p><a name="bd49c3cc"></a></p>
<h5>3.模块的默认值</h5>
<p><br />在CommonJS等其他的模块化规范中，从模块中导出或导入默认值是一个常见的用法，因此在ES6中也延用了这种用法并进行了优化。在ES6中我们可以使用default关键字来指定默认值，并且一个模块只能默认一个导出值：<br /></p>
<pre><code>// ./example.js
// 第一种默认导出语法
export default function(a, b) {
   return a + b;
}
// 第二种默认导出语法
function add(a, b) {
   return a + b;
}
export default add;
// 第三种默认导出语法
function add(a, b) {
   return a + b;
}
export { add as default };
</code></pre>
<p><br />需要注意的是第三种语法，default关键字虽然不能作为元素的名称，但可以作为元素的属性名称，因此可以使用as语法将add函数的属性设置为default。<br />导入默认值的语法则是这样的：<br /></p>
<pre><code>//  第一种语法
import add from &quot;./example&quot;;
//  第二种语法
import { default as add } from &quot;./example&quot;;
</code></pre>
<p><br />看到这里有些朋友可能会发现，我们的第一种语法中import关键字后面并没有加大括号，认为这是错误的。其实这是导入默认值的独特语法，在这的本地名称add用于表示模块导出的任何默认函数，这种语法是最纯净的，ES6标准创建团队的大佬们也希望这种语法能成为web主流的模块导入形式。<br />我们前面说的导入匿名函数也同样使用这种语法：<br /></p>
<pre><code>//   ./example.js
//导出匿名函数
export default function(a, b) {
   return a + b；
}
// ./say.js
import add from &quot;./example&quot;;
console.log(add(1,1));  // 2
</code></pre>
<p><br />在这里本地名称add就是用于表示上面的匿名函数的。<br /></p>
<p><a name="8dd7f54c"></a></p>
<h5>4.导出已导入的元素</h5>
<p><br />我们同样可以在本模块内导出我们在本模块内导入的元素，有以下几种语法：<br /></p>
<pre><code class="language-javascirpt">//  第一种语法
import { add } from ./example.js;
export { add };
//  第二种语法
export { add } from ./example.js;
//换一个名称导出
export { add as add1 } from ./example.js; //以add这个名称导入，再以add1的名称导出
// 导出整个模块
export *  from ./example.js;
</code></pre>
<p><br />// 最后求一波暑期前端实习的坑位-_-||</p>
]]></content><link href="https://github.com/srtian/Blog/issues/12" rel="alternate"/><category term="JavaScript"/><published>2020-04-07T07:51:09+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/11</id><title>聊一聊常见的浏览器端数据存储方案</title><updated>2023-03-02T09:25:48.963598+00:00</updated><content type="html"><![CDATA[<h3>前言：</h3>
<p>五一假期在撸代码的时候用到cookie，感觉对浏览器的数据存储方案不是很了解，因此又去翻了两本大头书中间的关于浏览器端数据存储的章节，同时去MDN逛了逛，又看了几篇文章，算是对浏览器的数据存储方案有了一个了解，在此总结一下！</p>
<h2>浏览器存储</h2>
<p>在浏览器端存储数据对我们是很有用，这相当于赋予浏览器记忆的功能，可以纪录用户的所有状态信息，增强用户体验。比如当纪录用户的登陆状态时，可以让用户能够更快的进行访问，而不是每次登陆时都需要去进行繁琐的操作。</p>
<p>总的来说,现在市面上最常见的数据存储方案是以下三种：</p>
<ul>
<li>Cookie</li>
<li>web存储 (locaStorage和seesionStorage)</li>
<li>IndexedDB</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16325ce01e799f9f?w=749&amp;h=356&amp;f=png&amp;s=111928" alt="图片.png" /></p>
<h2>Cookie</h2>
<p>Cookie的又称是HTTP Cookie，最初是在客户端用于存储会话信息，从底层来看，它作为HTTP协议的一种扩展实现，Cookie数据会自动在web浏览器和web服务器之间传输，因此在服务器端脚本就可以读写存储的cookie的值，因此Cookie通常用于存储一些通用的数据，比如用户的登陆状态，首选项等。虽然随着时代的进步，HTML5所提供的web存储机制已经逐步替代了Cookie，但有些较为老的浏览器还是不兼容web存储机制，因此正处于这个老旧更替阶段的我们对于它还是要了解了解的。(比如我这个瓜皮还在用它，2333)</p>
<h3>Cookie的优点</h3>
<p>首先由于操作Cookie的API很早就已经定义和实现了，因此相比于其他的数据存储方式，Cookie的兼容性非常的好，兼容现在市面上所有的主流浏览器，我们在使用它的时候完全不用担心兼容问题。</p>
<h3>Cookie的缺点</h3>
<p>说到Cookie的缺点，那就有点多了，不然也不会在Cookie后面出现web存储等新的数据存储的方案了。
总结起来Cookie的缺点主要是以下几点：</p>
<ol>
<li>存储量小。虽不同浏览器的存储量不同，但基本上都是在4kb左右。</li>
<li>影响性能。由于Cookie会由浏览器作为请求头发送，因此当Cookie存储信息过多时，会影响特定域的资源获取的效率，增加文档传输的负载。</li>
<li>只能储存字符串。</li>
<li>安全问题。存储在Cookie的任何数据可以被他人访问，因此不能在Cookie中储存重要的信息。</li>
<li>由于第三方Cookie的滥用，所以很多老司机在浏览网页时会禁用Cookie，所以我们不得不测试用户是否支持Cookie，这也是很麻烦的一件事。</li>
</ol>
<h3>Cookie的操作</h3>
<p>基本的Cookie操作主要有三个：读取，写入和删除。但在JavaScript中去处理cookie是一件很繁琐的事情，因为cookie中的所有的名字和值都是经过URI编码的，所以当我们必须使用decodeURICompoent来进行解码才能得到cookie的值。我们来看看CookieUtil对象是如何操纵cookie的：</p>
<pre><code class="language-JavaScript">var CookieUtil = {
	// get可根据cookie的名字获取相应的值
	get: function() {
		const cookieName = encodeURIcOMPONET(name) + &quot;=&quot;,
			   cookieStart = document.cookie.indexOf(cookieName),
			   cookieValue = null
		if(cookieStart &gt; -1) {
			const cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart)
			if(cookieEnd == -1) {
				cookieEnd = document.cookie.length
			}
			cookieValue = decodeURICompoent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))	
		}
		return cookieValue
	}
	// set设置一个cookie
	set: function(name, value, expires, path, domain, secure) {
		var cookieText = encodeURIComponet(name)+&quot;=&quot;+encodeURIComponet(value)
		if(expires instanceof Date) {
			cookieText += &quot;; expires=&quot; + expires.toGMTString()
		}
		if(path) {
			cookieText += &quot;;path=&quot; + path
		}
		if(domain) {
			cookieText += &quot;; domain&quot; + domain
		}
		if(secure) {
			cookieText += &quot;; secure&quot;
		}
		document.cookie = cookieText
	}
	// 删除已有的cookie
	unset: function(name, path, domain, secure) {
		this.set(name, &quot;&quot;, new Date(0), path, domain, secure)
	}
}
</code></pre>
<p>是不是很麻烦，无论是获取一个cookie的值或是设置一个cookie都是很麻烦的事情，这也成为了后续的浏览器数据存储方案出现的一大原因。</p>
<h2>web存储</h2>
<p>web存储机制最初作为HTML5的一部分被定义成API的形式，但又由于其本身的独特性与其他的一些原因而剥离了出来，成为独立的一个标准。web存储标准的API包括locaStorage对象和seesionStorage对象。它所产生的主要原因主要出于以下两个原因：</p>
<ul>
<li>人们希望有一种在cookie之外存储回话数据的途径。</li>
<li>人们希望有一种存储大量可以跨会话存在的数据的机制。</li>
</ul>
<p>（注：其实在最初的web存储规范中包含了两种对象的定义：seesionStorage和globalStorage,这两个对象在支持这两个对象的浏览器中都是以windows对象属性的形式存在的）</p>
<h3>locaStorage</h3>
<p>locaStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了我们上面所提到的globalStorage。从功能上来讲，我们可以通过locaStorage在浏览器端存储键值对数据，它相比于cookie而言，提供了更为直观的API，且在安全上相对好一点
，而且虽然locaStorage只能存储字符串，但它也可以存储字符串化的JSON数据，因此相比于cookie，locaStorage能存储更复杂的数据。总的来说相较于cookie，locaStorage有以下优势：</p>
<ul>
<li>提供了简单明了的API来进行操作</li>
<li>更加安全</li>
<li>可储存的数据量更大</li>
</ul>
<p>也正是出于以上这些原因，locaStorage被视为替代cookie的解决方案，但还是要注意不要在locaStorage中存储敏感信息。</p>
<h4>locaStorage的基本语法</h4>
<p>locaStorage的基本操作很简单，示例如下：</p>
<pre><code class="language-JavaScript">// 使用方法存储数据
locaStorage.setItem(&quot;name&quot;, &quot;Srtian&quot;)
// 使用属性存储数据
locaStorage.say = &quot;Hello world&quot;
// 使用方法读取数据
const name = locaStorage.getItem(&quot;name&quot;)
// 使用属性读取数据
const say = locaStorage.say
// 删除数据
locaStorage.removeItem(&quot;name&quot;)
</code></pre>
<p>但需要注意的是，我们上面的示例全是存储字符串格式的数据，当我们需要传输其他格式的数据时，我们就需要将这些数据全部转换为字符串格式，然后再进行存储：</p>
<pre><code class="language-JavaScript">const user = {name:&quot;Srtian&quot;, age: 22}
localStorage.setItem(&quot;user&quot;, JSON.stringify(user))
</code></pre>
<p>当然，我们在获取值的时候也别忘了将其转化回来：</p>
<pre><code class="language-JavaScript">const age = JSON.parse(locaStorage.user)
</code></pre>
<h4>locaStorage储存数据的有效期与作用域</h4>
<p>通过locaStorage存储的数据时永久性的，除非我们使用removeItem来删除或者用户通过设置浏览器配置来删除，负责数据会一直保留在用户的电脑上，永不过期。</p>
<p>locaStorage的作用域限定在文档源级别的（意思就是同源的才能共享），同源的文档间会共享locaStorage的数据，他们可以互相读取对方的数据，甚至有时会覆盖对方的数据。当然，locaStorage的作用域同样也受浏览器的限制。</p>
<h4>locaStorage的兼容</h4>
<p>locaStorage的兼容如下表所示：</p>
<pre><code>    Feature 	Chrome 	Edge 	Firefox (Gecko) Internet Explorer 	Opera 	Safari (WebKit)
localStorage 	4 	(Yes) 	   3.5 	            8 	             10.50     4
sessionStorage 	5 	(Yes) 	   2 	            8 	             10.50 	   4
</code></pre>
<h3>sessionStorage</h3>
<p>sessionStorage是web存储机制的另一大对象，sessionStorage 属性允许我们去访问一个 session Storage 对象。它与 localStorage 相似，不同之处在于 localStorage里面存储的数据没有过期时间设置，而Session Storage只存储当前会话页的数据，且只有当用户关闭当前会话页或浏览器时，数据才会被清除。</p>
<h4>sessionStorage的基本语法</h4>
<p>我们可以通过下面的语法，来保存，获取，删除数据，大体语法与：</p>
<pre><code class="language-JavaScript">// 保存数据到sessionStorage
sessionStorage.setItem(&#x27;name&#x27;, &#x27;Srtian&#x27;);

// 从sessionStorage获取数据
var data = sessionStorage.getItem(&#x27;name&#x27;);

// 从sessionStorage删除保存的数据
sessionStorage.removeItem(&#x27;name&#x27;);

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
</code></pre>
<p>下面的示例会自动保存一个文本输入框的内容，如果浏览器因偶然因素被刷新了，文本输入框里面的内容会被恢复，写入的内容不会丢失：</p>
<pre><code class="language-JavaScript">// 获取文本输入框
var field = document.getElementById(&quot;field&quot;)

// 检测是否存在 autosave 键值
// (这个会在页面偶然被刷新的情况下存在)
if (sessionStorage.getItem(&quot;autosave&quot;)) {
  // 恢复文本输入框的内容
  field.value = sessionStorage.getItem(&quot;autosave&quot;)
}
// 监听文本输入框的 change 事件
field.addEventListener(&quot;change&quot;, function() {
  // 保存结果到 sessionStorage 对象中
  sessionStorage.setItem(&quot;autosave&quot;, field.value)
})
</code></pre>
<p>在兼容性和优点方面，sessionStorage和locaStorage是差不多的，因此在此也就不多说了，下面我们来聊一聊IndexedDB。</p>
<h2>IndexedDB</h2>
<p>虽然web存储机制对于存储较少量的数据非常便捷好用，但对于存储更大量的结构化数据来说，这种方法就不太满足开发者们的需求了。IndexedDB就是为了应对这个需求而产生的，它是由HTML5所提供的一种本地存储，用于在浏览器中储存较大数据结构的 Web API，并提供索引功能以实现高性能查找。它一般用于保存大量用户数据并要求数据之间有搜索需要的场景，当网络断开时，用户就可以做一些离线的操作。它较之SQL更为方便，不需要写一些特定的语法对数据进行操作，数据格式是JSON。</p>
<h3>IndexedDB的基本语法</h3>
<p>使用IndexedDB在浏览器端存储数据会比上述的其他方法更为复杂。首先，我们需要创建数据库，并指定这个数据库的版本号：</p>
<pre><code class="language-JavaScript">// 注意数据库的版本号只能是整数
const request = IndexedDB.open(databasename, version)
</code></pre>
<p>然后我们需要生成处理函数，需要注意的是onupgradeneeded 是我们唯一可以修改数据库结构的地方。在这里面，我们可以创建和删除对象存储空间以及构建和删除索引。
：</p>
<pre><code class="language-JavaScript">request.onerror = function() {
	// 创建数据库失败时的回调函数
}
request.onsuccess = function() {
	// 创建数据库成功时的回调函数
}
request.onupgradeneededd = function(e) {
	 // 当数据库改变时的回调函数
}

</code></pre>
<p>然后我们就可以建立对象存储空间了，对象存储空间仅调用createObjectStore()就可以创建。这个方法使用存储空间的名称，和一个对象参数。即便这个参数对象是可选的，它还是非常重要的，因为它可以让我们定义重要的可选属性和完善你希望创建的对象存储空间的类型。</p>
<pre><code class="language-JavaScript">request.onupgradeneeded = function(event) {
	const db = event.target.result
	const objectStore = db.createObjectStore(&#x27;name&#x27;, { keyPath:&#x27;id&#x27; })
}
</code></pre>
<p>对象的存储空间我们已经建立好了，接下来我们就可以进行一系列的骚操作了，比如来个蛇皮走位！不不不，口误口误，比如添加数据：</p>
<pre><code class="language-JavaScript">addData: function(db, storename, data) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	for(let i = 0; i &lt; data.length; i++) {
		const request = store.add(data[i])
		request.onerror = function() {
			console.error(&#x27;添加数据失败&#x27;)
		}
		request.onsuccess = function() {
			console.log(&#x27;添加数据成功&#x27;)
		}
	}
}
</code></pre>
<p>如果我们想要修改数据，语法与添加数据差不多，因为重复添加已存在的数据会更新原本的数据，但还是有细小的差别：</p>
<pre><code class="language-JavaScript">putData: function(db, storename, data) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	for(let i = 0; i &lt; data.length; i++) {
		const request = store.put(data[i])
		request.onerror = function() {
			console.error(&#x27;修改数据失败&#x27;)
		}
		request.onsuccess = function() {
			console.log(&#x27;修改数据成功&#x27;)
		}
	}
}
</code></pre>
<p>获取数据：</p>
<pre><code class="language-JavaScript">getDataByKey: function(db, storename, key) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	const request = store.get(key)
	request.onerror = function() {
		console.error(&#x27;获取数据失败&#x27;)
	}
	request.onsuccess = function(e) {
		const result = e.target.result
		console.log(result)
	}
}
</code></pre>
<p>删除数据：</p>
<pre><code class="language-JavaScript">deleteDate: function(db, storename, key) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	store.delete(key)
	console.log(&#x27;已删除存储空间&#x27; + storename + &#x27;中的&#x27; + key + &#x27;纪录&#x27;)
}
</code></pre>
<p>关闭数据库：</p>
<pre><code>db.close
</code></pre>
<h3>IndexedDB的优点（相较于前面的存储方案）</h3>
<ul>
<li>拥有更大的储存空间</li>
<li>能够处理更为复杂和结构化的数据</li>
<li>拥有更多的交互控制</li>
<li>每个'database'中可以拥有多个'database'和'table'</li>
</ul>
<h3>IndexedDB的局限性</h3>
<p>了解了IndexedDB的优点，我们当然也要来聊一聊IndexedDB的局限性与适用的场景：</p>
<h4>1. 存储空间限制</h4>
<p>一个单独的数据库项目的大小没有限制。然而可能会限制每个 IndexedDB 数据库的大小。这个限制（以及用户界面对它进行断言的方式）在各个浏览器上也可能有所不同：</p>
<ul>
<li>Firefox: 对 IndexedDB 数据库的大小没有限制。在用户界面上只会针对存储超过 50 MB 大小的 BLOB（二进制大对象）请求权限。这个大小的限额可以通过 dom.indexedDB.warningQuota 首选项进行自定义。(定义在 <a href="http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js)%E3%80%82">http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js)。</a></li>
<li>Google Chrome：<a href="https://developers.google.com/chrome...rage#temporary">https://developers.google.com/chrome...rage#temporary</a></li>
</ul>
<h4>2. 兼容性问题</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16325ce02ccb3e88?w=1240&amp;h=189&amp;f=png&amp;s=58377" alt="图片.png" />
从上面的图我们可以看出对于IndexedDB的兼容来讲比前面所提及的存储方案要差不少，因此在使用IndexedDB时，我们也要好好的考虑兼容性的问题</p>
<h4>3. indexedDB受同源策略的限制</h4>
<p>indexedDB使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。要着重指出的一点是 IndexedDB 不适用于从另一个站点加载进框架的内容 (不管是 <frame> 还是 &lt;iframe>。这是一项安全措施。详情请看这个：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=595307">https://bugzilla.mozilla.org/show_bug.cgi?id=595307</a></p>
<p>除此之外，IndexedDB还存在诸如：不适合存储敏感数据，相较于web存储机制的操作更加复杂等问题，这都是我们在使用IndexedDB时需要考虑的。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/11" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T10:04:17+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/10</id><title>React高阶组件的那些事，了解一下？</title><updated>2023-03-02T09:25:49.138119+00:00</updated><content type="html"><![CDATA[<h4>前言</h4>
<p>学习react已经有一段时间了，期间在阅读官方文档的基础上也看了不少文章，但感觉对很多东西的理解还是不够深刻，因此这段时间又在撸一个基于react全家桶的聊天App（现在还在瞎78写的阶段，在往这个聊天App这个方向写），通过实践倒是对react相关技术栈有了更为深刻的理解，而在使用react-redux的过程中，发现connect好像还挺有意思的，也真实感受到了高阶组件所带来的便利，出于自己写项目本身就是为了学习的目的，因此对高阶组件又进行了一番学习。写下这篇文章主要是对高阶组件的知识进行一个梳理与总结，如有错误疏漏之处，敬请指出，不胜感激。</p>
<h2>初识高阶组件</h2>
<p><em>要学习高阶组件首先我们要知道的就是高阶组件是什么，解决了什么样的问题。</em></p>
<p>React官方文档的对高阶组件的说明是这样的:</p>
<blockquote>
<p>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, perse. They are a pattern that emerges from React’s compositional nature.</p>
</blockquote>
<p>从上面的说明我们可以看出，react的高阶组件并不是react API的一部分。它源自于react的生态。</p>
<p>简单来说，一个高阶组件就是一个函数，它接受一个组件作为输入，然后会返回一个新的组件作为结果，且所返回的新组件会进行相对增强。值得注意的是，我们在这说的组件并不是组件实例，而是一个组件类或者一个无状态组件的函数。就像这样：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

function removeUserProp(WrappedComponent) {
//WrappingComponent这个组件名字并不重要，它至少一个局部变量，继承自React.Component
    return class WrappingComponent extends React.Component {
        render() {
// ES6的语法，可以将一个对象的特定字段过滤掉
            const {user, ...otherProps} = this.props
            return &lt;WrappedComponent {...otherProps} /&gt;
        }
      }
}

</code></pre>
<p>了解设计模式的大佬们应该发现了，它其实就是的设计模式中的装饰者模式在react中的应用，它通过组合的方式从而达到很高的灵活程度和复用。
就像上面的代码，我们定义了一个叫做 removeUserProp 的高阶组件，传入一个叫做 WrappedComponent 的参数（代表一个组件类），然后返回一个新的组件 ，新的组件与原组件并没有太大的区别，只是将原组件中的 prop 值 user 给剔除了出来。</p>
<p>有了上面这个高阶组件的，当我们不希望某个组件接收到 user 时，我们就可以将这个组件作为参数传入 removeUserProp() 函数中，然后使用这个返回的组件就行了：</p>
<pre><code class="language-JavaScript">const NewComponent = removeUserProp(OldComponent)
</code></pre>
<p>这样 NewComponent 组件与 OldComponent 组件拥有完全一样的行为，唯一的区别就在于传入的name属性对这个组件没有任何作用，它会自动屏蔽这个属性。也就是说，我们这个高阶组件成功的为传入的组件增加了一个屏蔽某个prop的功能。</p>
<p>那么明白了什么是高阶组件后，我们接下来要做的是，弄清楚高阶组件主要解决的问题，或者说我们为什么需要高阶组件？总结起来主要是以下两个方面：</p>
<ol>
<li>代码重用</li>
</ol>
<blockquote>
<p>在很多情况下，react组件都需要共用同一个逻辑，我们在这个时候就可以把这部分共用的逻辑提取出来，然后利用高阶组件的形式将其组合，从而减少很多重复的组件代码。</p>
</blockquote>
<p>2.修改React组件的行为</p>
<blockquote>
<p>很多时候有些现成的react组件并不是我们自己撸出来的，而是来自于GitHub上的大佬们的开源贡献，而当我们要对这些组件进行复用的时候，我们往往都不想去触碰这些组件的内部逻辑，这时我们就能通过高阶组件产生新的组件满足自身需求，同时也对原组件没有任何损害。</p>
</blockquote>
<p>现在我们对高阶组件有了一个较为直观的认识，知道了什么是高阶组件以及高阶组件的主要用途。接下来我们就要具体了解高阶组件的实现方式以及它的具体用途了。</p>
<h3>高阶组件的实现分类</h3>
<p>对于高阶组件的实现方式我们可以根据作为参数传入的组件与返回的新组件的关系将高阶组件的实现方式分为以下两大类：</p>
<ul>
<li>代理方式的高阶组件</li>
<li>继承方式的高阶组件</li>
</ul>
<h2>代理方式的高阶组件</h2>
<p>从高阶组件的使用频率来讲，我们使用的绝大多数的高阶组件都是代理方式的高阶组件，如react-redux中的connect，还有我们在上面所实现的那个removeUserProp。这类高阶组件的特点是返回的新组件类直接继承于 React.Component 类。新组建在其中扮演的角色是一个传入参数组件的代理，在新组建的render函数中，把被包裹的组件渲染出来。在此过程中，除了高阶组件自己需要做的工作，其他的工作都会交给被包裹的组件去完成。</p>
<p>代理方式的高阶组件具体而言，应用场景可以分为以下几个：</p>
<ul>
<li>操作prop</li>
<li>通过ref获取组件实例</li>
<li>抽取状态</li>
<li>包装组件</li>
</ul>
<h3>控制prop</h3>
<p>代理类型的高阶组件返回的新组件时，渲染过程也会被新组建的render函数所控制，而在此过程中，render函数相对于一个代理，完全决定该如何使用被包裹在其中的组件。在render函数中，this.props包含了新组件接受到的所有prop。因此最直观的用法就是接受到props，然后进行任何读取，增减，修改等控制props的自定义操作。
就比如我们上面的那个示例，就做到了删除prop的功能，当然我们也能实现一个添加prop的高阶组件：</p>
<pre><code class="language-JavaScript">function addNewProp(WrappedComponent, newProps) {
    return class WrappingComponent extends React.Component {
        render() {
          return &lt;WrappedComponent {...thisProps} {...newProps} /&gt;
        }
      }
}
</code></pre>
<p>这个addNewProp高阶组件与我们最开始举例的removeUserProp高阶组件在实现上并无太大的区别。唯一区别较大的就是我们传入的参数除了WrappedComponent组件类外，还新增了newProps参数。这样的高阶组件在复用性方面会跟友好，我们可以利用这样一个高阶组件给不同的组件添加不同的新属性，比如这样：</p>
<pre><code class="language-JavaScript">const FirstComponent = addNewProp(OldComponent,{num: First})
const LastComponent = addNewProp(NewComponent,{num: Last})
</code></pre>
<p>在上面的代码中，我们实现了让两个完全不同的组件分别通过高阶组件生成了两个完成不同的新的组件，而这其中唯一相同的是都添加了一个属性值，且这个属性还不相同。从上面的代码我们也不难发现，高阶组件可以重用在不同组件上，减少了重复的代码。当需要注意的是，在修改和删除 Props的时候，除非由特殊的要求，否则最好不要影响到原本传递给普通组件的 Props。</p>
<h3>通过ref获取组件实例</h3>
<p>我们可以通过ref获取组件实例，但值得注意的是，React官方不提倡访问ref，我们只是讨论一下这个技术的可行性。在此我们写一个refsHOC的高阶组件，可以获得被包裹组件的ref，从而根据ref直接操纵被包裹组件的实例：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

function refsHOC(WrappedComponent) =&gt; {
  return class HOCComponent extends React.Component {
    constructor() {
      super(...arguments)
      this.linkRef = this.linkRef.bind(this)
    }
    linkRef(wrappedInstance) {
      this._root = wrappedInstance
    }
    render() {
      const props = {...this.props, ref: this.linkRef}
      return &lt;WrappedComponent {...props}/&gt;
    }
  }
}

export default refsHOC
</code></pre>
<p>这个refs高阶组件的工作原理其实也是增加传递给被包裹组件的props，不同的是利用了ref这个特殊的prop而已。我们通过linkRef来给被包裹组件传递ref值，linkRef被调用时，我们就可以得到被包裹组件的DOM实例。</p>
<p>这种高阶组件在用途上来讲可以说是无所不能的，因为只要能够获得对被包裹组件的引用，就能通过这个引用任意操纵一个组件的DOM元素，贼酸爽。但它从某个角度来讲也是啥也干不了的，因为react团队表示：<strong>不要过度使用 Refs</strong>。且我们也有更好的替代品——控制组件（Controlled Component)来解决相关问题，因此这个坑建议大家还是尽量少踩为好。</p>
<h3>抽取状态</h3>
<p>对于抽取状态，我想大家应该都不会很陌生。react-redux中的connect函数就实现了这种功能，它异常的强大，也成功吸引了我对高阶组件的注意力。但在这有一点需要明确的是：connect函数本身并不是高阶组件，connect函数执行的结果才是一个高阶组件。让我们来看看connect的源码的主要逻辑：</p>
<pre><code class="language-JavaScript">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {
    return function wrapWithConnect(WrappedComponent) {
        class Connect extends Component {
            constructor(props, context) {
                //参数获取
                super(props, context)
                this.store = props.store || context.store
                const storeState = this.store.getState()
                this.state = { storeState }
            }
            // 进行判断，当数据发生改变时，Component重新渲染
            shouldComponentUpdate(nextProps, nextState) {
                if (propsChanged || mapStateProducedChange || dispatchPropsChanged) {
                 this.updateState(nextProps)
                  return true
                 }
                }
            // 改变Component中的state
            componentDidMount() {
                 this.store.subscribe(() = {
                  this.setState({
                   storeState: this.store.getState()
                  })
                 })
                }
            render(){
                this.renderedElement = createElement(WrappedComponent,
                    this.mergedProps
                )
                return this.renderedElement
            }
        }
        return hoistStatics(Connect, WrappedComponent)
    }
}
</code></pre>
<p>从上面的代码我们不难看出connect模块的返回值wrapWithConnect是一个函数，而这个函数才是我们所认知的高阶组件。wrapWithConnect函数会返回一个ReactComponent对象Connect，Connect会重新render外部传入的原组件WrappedComponent，并把connect中所传入的mapStateToProps, mapDispatchToProps和this.props合并后结合成一个对象，通过属性的方式传给WrappedComponent，这才是最终的渲染结果。</p>
<h3>包装组件</h3>
<p>在日常开发中我们所接触到的大多数的高阶组件都是通过修改props部分来对输入的组件进行相对增强的。但其实高阶组件还有其他的方式来增强组件，比如我们可以通过在render函数中的JSX引入其他元素，甚至将多个react组件合并起来，来获得更骚气的样式或方法，例如我们可以给组件增加style来改变组件样式：</p>
<pre><code class="language-JavaScript">const styleHOC = (WrappedComponent, style) =&gt; {
    return class HOCComponent extends React.Component {
        render() {
            return (
            &lt;div style={style}&gt;
                &lt;WrappedComponent {...this.props} /&gt;
            &lt;/div&gt;
            )
        }
    }
}
</code></pre>
<p>当我们想改变组件的样式的时候，我们就可以直接调用这个函数，比如这样：</p>
<pre><code class="language-JavaScript">const style = {
			background-color: #f1fafa;
			font-family: &quot;微软雅黑&quot;;
			font-size: 20px;
		}
const BeautifulComponent = styleHOC(uglyComponent, style)
</code></pre>
<h2>继承方式的高阶组件</h2>
<p>前面我们讨论了代理方式实现的高阶组件以及它们的主要使用方式，现在我们继续来讨论一下以继承方式实现的高阶组件。</p>
<p>。继承方式的高阶组件通过继承来关联作为参数传入的组件和返回的组件，比如传入的组件参数是OldComponent,那函数所返回的组件就直接继承于OldComponemt。</p>
<p>码界有句老话说的好：组合优于继承。在高阶组件里也不例外。
继承方式的高阶组件相对于代理方式的高阶组件有很多不足之处，比如输入的组件与输出的组件共有一个生命周期等，因此通常我们接触到的高阶组件大多是代理方式实现的高阶组件，也推荐大家首先考虑以代理方式来实现高阶组件。但我们还是需要去了解并学习它，毕竟它也是有可取之处的，比如在操作生命周期函数上它还是具有其优越性的。</p>
<h3>操作生命周期函数</h3>
<p>说继承方式的高阶组件在操纵生命周期函数上有其优越性其实不够说明它在这个领域的地位，更准确地表达是：操作生命周期函数是继承方式的高阶组件所特有的功能。这是由于继承方式的高阶组件返回的新组件继承于作为参数传入的组件，两个组件的生命周期是共用的，因此可以重新定义组件的生命周期函数并作用于新组件。而代理方式的高阶组件作为参数输入的组件与输出的组件完全是两个生命周期，因此改变生命周期函数也就无从说起了。</p>
<p>例如我们可以定义一个让参数组件只有在用户登录时才显示的高阶组件：</p>
<pre><code class="language-JavaScript">const shouldLoggedInHOC = (WrappedComponent) =&gt; {
    return class MyComponent extends WrappedComponent {
        render() {
            if (this.props.loggedIn) {
                return super.render()
            }
            else {
                return null
            }
        }
    }
}
</code></pre>
<h3>操纵Prop</h3>
<p>除了操作生命周期函数外，继承方式的高阶函数也能对Prop进行操作，但总的难说贼麻烦，当然也有简单的方式，比如这样：</p>
<pre><code class="language-JavaScript">function removeProps(WrappedComponent) {
    return class NewComponent extends WrappedComponent {
        render() {
        const{ user, ...otherProps } = this.props
        this.props = otherProps
        return super.render()
        }
    }
}
</code></pre>
<p>虽然这样看起来很简单，但我们直接修改了this.props，这不是一个好的实践，可能会产生不可预料的后果，更好的操作办法是这样的：</p>
<pre><code class="language-JavaScript">function removeProps(WrappedComponent) {
    return class NewComponent extends WrappedComponent {
        render() {
        const element =super.render()
        const{ user, ...otherProps } = this.props
        this.props = otherProps
        return React.cloneElement(element, this.props, element.props.children)
        }
    }
}
</code></pre>
<p>我们可以通过React.cloneElement来传入新的props，让这些产生的组件重新渲染一次。但虽然这种方式可以解决直接修改this.props所带来的问题，但实现起来贼麻烦，唯一用得上的就是高阶组件需要根据参数组件WrappedComponent渲染结果来决定如何修改props时用得上，其他的时候显然使用代理模式更便捷清晰。</p>
<h2>高阶组件命名</h2>
<p>用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和debug。</p>
<p>因此我们通常会用 WrappedComponent 的名字加上一些 前缀作为 HOC 的名字。我们来看看React-Redux是怎么做的：</p>
<pre><code class="language-JavaScript">function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName ||
         WrappedComponent.name ||
         ‘Component’
}

HOC.displayName = `HOC(${getDisplayName(WrappedComponent)})`
//或
class HOC extends ... {
  static displayName = `HOC(${getDisplayName(WrappedComponent)})`
  ...
}
</code></pre>
<p>实际上我们不用自己来写getDisplayName这个函数，recompose 提供了这个函数，我们只要使用即可。</p>
<h4>结尾语</h4>
<p>我们其他要注意的就是<a href="https://react.bootcss.com/react/docs/higher-order-components.html">官方文档</a>所说的几个约定与相关规范，在此我就不一一赘述了，感兴趣的可以自己去看看。最后很感谢能看到这里的朋友，因为水平有限，如果有错误敬请指正，十分感激！</p>
]]></content><link href="https://github.com/srtian/Blog/issues/10" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T10:00:39+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/9</id><title> 从 HTML5 WebSocket 到 Socket.io</title><updated>2023-03-02T09:25:49.331001+00:00</updated><content type="html"><![CDATA[<h2>HTML5 WebSocket概述</h2>
<p>作为新一代的web标准，HTML5为我们提供了很多有用的东西，比如canvas，本地存储（已经分离出去了），多媒体编程接口，当然还有我们的WebSocket。WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯（full-duplex）的网络技术，可以传输基于信息的文本和二进制的数据。它于2011年被IETF定为标准 RFC 6455，同时WebSocket API也被W3C定为标准。</p>
<h2>一、WebSocket产生的背景</h2>
<h3>1.黎明前的黑暗——实时web应用的需求</h3>
<p>web应用的信息交互过程我想大家或多或少都知道一些，通常是客户端通过浏览器发出一个请求，然后服务器端在接受和审核请求后,进行处理并将结果返回给客户端，最后由客户端的浏览器将信息呈现出来。这种通信机制在信息交互不是特别频繁的情况下并没有太大的问题，但对于那些实时性要求高、海量数据并发的应用来说，就显得捉襟见肘了，比如现在常见的网页游戏，证券网站，RSS订阅推送，网页实时对话，打车软件等。通常当客户端准备呈现一些信息时，这些信息在服务器端很有可能就已经过时了。为了满足以上那些场景，大佬们研究出来了一些折衷方案，其中最常用的就是普通轮询和Comet技术，而Comet技术实际上就是轮询的改进，细分起来Comet有两种实现方式：</p>
<ul>
<li>长轮询机制</li>
<li>流技术机制</li>
</ul>
<h4>1.1 长轮询机制</h4>
<p>长轮序是对普通轮询的改进和提高。普通轮询简单来说，就是客户端每隔一定的时间就向服务器端发送请求，从而以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的最大问题是，客户端已固定的频率发送请求时，很可能服务端的数据没有更新，产生很多无用的网络传输，非常低效。</p>
<p>为了减少无效的网络传输，长轮询对普通轮询进行了改进和提高，当服务器端没有数据更新时，链接会保持一段时间的周期，直到数据或状态发生改变或连接时间过期，通过这种机制我们就可以减少很多无效的客户端和服务器间的交互。当然，如果服务器端的数据变更非常频繁的话，这种机制并没有有效的提高性能，和普通轮询没有太大的区别，且长轮询也会耗费更多的资源，比如CPU,内存,带宽等。</p>
<h4>1.2 流技术机制</h4>
<p>流技术机制简单来说就是客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器接到请求后作出回应，并不断更新状态，以保证客户端和服务器端的连接不过期。通过这种机制就可以将服务器端的信息不断传向客户端，从而保证信息的时效性。但这种机制对于用户体验并不友好，需要针对不同的浏览器升级不同的方案来改进用户体验，同时这种机制如果在并发情况下发生时，会对服务器的资源造成很大压力。</p>
<h3>2.黎明的到来——WebSocket</h3>
<p>正是出于以上几种解决方案都有着各自的局限性,HTML5 WebSocket也就应运而生了，浏览器可以通过JavaScript借助现有的HTTP协议来向服务器发出WebSocket连接的请求，当连接建立后，客户端和服务器端就可以直接通过TCP连接来直接进行数据交换。这是由于websocket协议本质上就是一个TCP连接，所以在数据传输的稳定性和传输量上有所保证，且相对于以往的轮询和Comet技术在性能方面也有了长足的进步：
<img src="https://user-gold-cdn.xitu.io/2018/5/11/1634ea2e300a0c6f?w=504&amp;h=360&amp;f=jpeg&amp;s=17994" alt="image" /></p>
<p>有一点需要注意的是虽然websocket在通信时需要借助HTTP，但它本质上和HTTP有着很大的区别：</p>
<ul>
<li>WebSocket是一种双向通信协议，在建立连接之后，WebSocket服务端和客户端都能主动向对方发送或者接受数据。</li>
<li>WebSocket需要先连接，只有再连接后才能进行相互通信。</li>
</ul>
<p>他们的关系其实就和这张图表现的一样，虽然有相交的部分，但依然有着很大的区别：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634ea2e0ed4878d?w=374&amp;h=133&amp;f=jpeg&amp;s=9144" alt="image" /></p>
<h2>二、WebSocket API的用法</h2>
<p>由于每个服务器端的语言都有着自己的API，因此首先我们来讨论客户端的API：</p>
<pre><code class="language-JavaScript">// 创建一个socket实例：
const socket = new WebSocket(ws://localhost:9093&#x27;)
// 打开socket
socket.onopen = (event) =&gt; {
    // 发送一个初始化消息
  	socket.send(&#x27;Hello Server!&#x27;)
  	 // 服务器有响应数据触发
    socket.onmessage = (event) =&gt; { 
        console.log(&#x27;Client received a message&#x27;,event)
    }
    // 出错时触发，并且会关闭连接。这时可以根据错误信息进行按需处理
    socket.onerror = (event) =&gt; {
  	    console.log(&#x27;error&#x27;)
    }
    // 监听Socket的关闭
    socket.onclose = (event) =&gt; { 
        console.log(&#x27;Client notified socket has closed&#x27;,event)
    }
    // 关闭Socket
    socket.close(1000, &#x27;closing normally&#x27;) 
 }
</code></pre>
<p>是不是感觉HTML5 websocket所提供的API贼鸡儿简单，没错，就是这么简单。但有几点我们需要注意：</p>
<ul>
<li>在创建socket实例的时候，new WebSocket()接受两个参数，第一个参数是ws或wss,第二个参数可以选填自定义协议，如果是多协议，可以是数组的方式。</li>
<li>WebSocket中的send方法不是任何数据都能发送的，现在只能发送三类数据，包括UTF-8的string类型（会默认转化为USVString），ArrayBuffer和Blob，且只有在建立连接后才能使用。（感谢大佬指出错误，已修改）</li>
<li>在使用socket.close(code,[reason])关闭连接时，code和reason都是选填的。code是一个数字值表示关闭连接的状态号，表示连接被关闭的原因。如果这个参数没有被指定，默认的取值是1000 （表示正常连接关闭）,而reason是一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于123字节的UTF-8 文本。</li>
</ul>
<h3>1.ws和wss</h3>
<p>我们在上面提到过，创建一个socket实例时可以选填ws和wss来进行通信协议的确定。他们两个其实很像HTTP和HTTPS之间的关系。其中ws表示纯文本通信，而wss表示使用加密信道通信（TCP+TLS）。那为啥不直接使用HTTP而要自定义通信协议呢？这就要从WebSocket的目的说起来，WebSocket的主要功能就是为了给浏览器中的应用与服务器端提供优化的，双向的通信机制，但这不代表WebScoket只能局限于此，它当然还能够用于其他的场景，这就需要他可以通过非HTTP协议来进行数据交换，因此WebSocket也就采用了自定义URI模式，以确保就算没有HTTP，也能进行数据交换。</p>
<p>ws和wss：</p>
<ul>
<li><strong>ws协议</strong>：普通请求，占用与HTTP相同的80端口</li>
<li><strong>wss协议</strong>：基于SSL的安全传输，占用与TLS相同的443端口。</li>
</ul>
<p>注：有些HTTP中间设备有时候可能会不理解WebSocket，而导致各种诸如：盲目连接升级，乱修改内容等问题。而WSS就很好的解决了这个问题，它建立了一台哦端到端的安全通道，这个通道对中间设备模糊了数据，因此中间设备就不能感知到数据，也就无法对请求做一些特殊处理了。</p>
<h2>三、WebSocket协议的规范</h2>
<p>以下是一个典型的WebSocket发起请求到响应请求的示例：</p>
<pre><code>客户端到服务端：
GET / HTTP/1.1
Connection:Upgrade
Host:127.0.0.1:8088
Origin:null
Sec-WebSocket-Extensions:x-webkit-deflate-frame
Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==
Sec-WebSocket-Version:13
Upgrade:websocket

服务端到客户端：
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Server:beetle websocket server
Upgrade:WebSocket
date: Thu, 10 May 2018 07:32:25 GMT
Access-Control-Allow-Credentials:true
Access-Control-Allow-Headers:content-type
Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=
</code></pre>
<p>我们可以看到，WebSocket协议和HTTP协议乍看并没有太大的区别，但细看下来，区别还是有些的，这其实是一个握手的http请求，首先请求和响应的，”Upgrade:WebSocket”表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket协议。从客户端到服务器端请求的信息里包含有”Sec-WebSocket-Extensions”、“Sec-WebSocket-Key”这样的头信息。这是客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息，并在握手的过程中依据这些信息生成一个28位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。</p>
<p>当握手成功后，这个时候TCP连接就已经建立了，客户端与服务端就能够直接通过WebSocket直接进行数据传递。不过服务端还需要判断一次数据请求是什么时候开始的和什么时候是请求的结束的。在WebSocket中，由于浏览端和服务端已经打好招呼，如我发送的内容为utf-8 编码，如果我发送0x00,表示包的开始，如果发送了0xFF，就表示包的结束了。这就解决了黏包的问题。</p>
<h2>四、兼容性情况</h2>
<pre><code>浏览器	                 支持情况
Chrome	            Supported in version 4+
Firefox	            Supported in version 4+
Internet Explorer	Supported in version 10+
Opera	            Supported in version 10+
Safari	            Supported in version 5+
</code></pre>
<h2>五、Socket.IO</h2>
<p>简单来说Socket.IO就是对WebSocket的封装，并且实现了WebSocket的服务端代码。Socket.IO将WebSocket和轮询（Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。也就是说，WebSocket仅仅是Socket.IO实现实时通信的一个子集。Socket.IO简化了WebSocket API，统一了返回传输的API。传输种类包括：</p>
<ul>
<li>WebSocket</li>
<li>Flash Socket</li>
<li>AJAX long-polling</li>
<li>AJAX multipart streaming</li>
<li>IFrame</li>
<li>JSONP polling。</li>
</ul>
<p>我们来看一下服务端的Socket.IO基本API：</p>
<pre><code class="language-JavaScript">// 引入socke.io
const io = require(&#x27;socket.io&#x27;)(80)
// 监听客户端连接,回调函数会传递本次连接的socket
io.on(&#x27;connection&#x27;,function(socket))
// 给所有客户端广播消息
io.sockets.emit(&#x27;String&#x27;,data)
// 给指定的客户端发送消息
io.sockets.socket(socketid).emit(&#x27;String&#x27;, data)
// 监听客户端发送的信息
socket.on(&#x27;String&#x27;,function(data))
// 给该socket的客户端发送消息
socket.emit(&#x27;String&#x27;, data)
</code></pre>
<p>另外，Socket.IO还提供了一个Node.JS API，它看起来很像客户端API。所以我们来看看它的实际应用吧：</p>
<pre><code class="language-JavaScript">// socket-server.js

// 需要使用HTTP模块来启动服务器和Socket.IO
const http= require(&#x27;http&#x27;), 
const io= require(&#x27;socket.io&#x27;)

const server= http.createServer(function(req, res){ 
    // 发送HTML的headers和message
    res.writeHead(200,{ &#x27;Content-Type&#x27;: &#x27;text/html&#x27; })
    res.end(&#x27;&lt;p&gt;Hello Socket.IO!&lt;p&gt;&#x27;)
}); 
// 在8080端口启动服务器
server.listen(8080)

// 创建一个Socket.IO实例，并把它传递给服务器
const socket= io.listen(server)

// 添加一个连接监听器
socket.on(&#x27;connection&#x27;, function(client) { 

// 连接成功，开始监听
client.on(&#x27;message&#x27;,function(event){ 
    console.log(&#x27;Received message from client!&#x27;,event)
})
// 连接失败
client.on(&#x27;disconnect&#x27;,function(){ 
    clearInterval(interval)
    console.log(&#x27;Server has disconnected&#x27;)
  })
})
</code></pre>
<p>然后我们就可以启动这个文件了：</p>
<pre><code>node socket-server.js
</code></pre>
<p>然后我们就可以创建一个每秒钟发送消息到客户端的发送器了；</p>
<pre><code class="language-JavaScript">var interval= setInterval(function() { 
  client.send(&#x27;This is a message from the server,hello world&#x27; + new Date().getTime()); 
},1000);
</code></pre>
<hr />
<p>注：需要注意的是，如果我们想在前端使用socket.IO,我们需要下载这个：</p>
<pre><code>npm install socket.io-client --save
</code></pre>
<p>然后再连接网络：</p>
<pre><code class="language-JavaScript">import io from &#x27;socket.io-client&#x27;
const socket = io(&#x27;ws://localhost:8080&#x27;)
</code></pre>
]]></content><link href="https://github.com/srtian/Blog/issues/9" rel="alternate"/><category term="FE"/><category term="Web"/><category term="JavaScript"/><published>2019-09-28T09:59:23+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/8</id><title>Redux 源码解读</title><updated>2023-03-02T09:25:49.504378+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>作为React全家桶的一份子，Redux为react提供了严谨周密的状态管理。但Redux本身是有点难度的，虽然学习了React也有一段时间了，自我感觉算是入了门，也知道redux的大概流程。但其背后诸如creatstore,applymiddleware等API背后到底发生了什么事情，我其实还是不怎么了解的，因此最近花了几天时间阅读了Redux的源码，写下文章纪录一下自己看源码的一些理解。（redux4.0版本）</p>
<h3>一、源码结构</h3>
<p>Redux是出了名的短小精悍（恩，这个形容很贴切），只有2kb大小，且没有任何依赖。它将所有的脏活累活都交给了中间件去处理，自己保持着很好的纯洁性。再加上redux作者在redux的源码上，也附加了大量的注释，因此redux的源码读起来还是不算难的。</p>
<p>先来看看redux的源码结构，也就是src目录下的代码：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/3/163c618640a812c8?w=309&amp;h=366&amp;f=png&amp;s=17704" alt="源码结构" title="Redux源码结构图.PNG" /></p>
<p>其中utils是工具函数，主要是作为辅助几个核心API，因此不作讨论。
（注：由于篇幅的问题，下面代码很多都删除了官方注释，和较长的warn）</p>
<h3>二、具体组成</h3>
<p>index.js是redux的入口函数具体代码如下：</p>
<h4>2.1 index.js</h4>
<pre><code class="language-JavaScript">import createStore from &#x27;./createStore&#x27;
import combineReducers from &#x27;./combineReducers&#x27;
import bindActionCreators from &#x27;./bindActionCreators&#x27;
import applyMiddleware from &#x27;./applyMiddleware&#x27;
import compose from &#x27;./compose&#x27;
import warning from &#x27;./utils/warning&#x27;
import __DO_NOT_USE__ActionTypes from &#x27;./utils/actionTypes&#x27;

function isCrushed() {}
if (
  process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;
  typeof isCrushed.name === &#x27;string&#x27; &amp;&amp;
  isCrushed.name !== &#x27;isCrushed&#x27;
) {
  warning(
  )
}

export {
  createStore,
  combineReducers,
  bindActionCreators,
  applyMiddleware,
  compose,
  __DO_NOT_USE__ActionTypes
}
</code></pre>
<p>其中isCrushed函数是用于验证在非生产环境下 Redux 是否被压缩，如果被压缩就会给开发者一个 warn 的提示。</p>
<p>在最后index.js 会暴露 createStore, combineReducers, bindActionCreators, applyMiddleware, compose 这几个redux最主要的API以供大家使用。</p>
<h4>2.2 creatStore</h4>
<p>createStore函数接受三个参数：</p>
<ul>
<li>reducer：是一个函数，返回下一个状态，接受两个参数：当前状态 和 触发的 action；</li>
<li>preloadedState：初始状态对象，可以很随意指定，比如服务端渲染的初始状态，但是如果使用 combineReducers 来生成 reducer，那必须保持状态对象的 key 和 combineReducers 中的 key 相对应；</li>
<li>enhancer：是store 的增强器函数，可以指定为中间件，持久化 等，但是这个函数只能用 Redux 提供的 applyMiddleware 函数来进行生成</li>
</ul>
<p>下面就是creactStore的源码，由于整体源码过长，且 subscribe 和 dispatch 函数也挺长的，所以就将 subscribe 和 dispatch 单独提出来细讲。</p>
<pre><code class="language-JavaScript"> import $$observable from &#x27;symbol-observable&#x27;

import ActionTypes from &#x27;./utils/actionTypes&#x27;
import isPlainObject from &#x27;./utils/isPlainObject&#x27;

export default function createStore(reducer, preloadedState, enhancer) {
  if (typeof preloadedState === &#x27;function&#x27; &amp;&amp; typeof enhancer === &#x27;undefined&#x27;) {
    enhancer = preloadedState
    preloadedState = undefined
  }
  // enhancer应该为一个函数
  if (typeof enhancer !== &#x27;undefined&#x27;) {
    if (typeof enhancer !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the enhancer to be a function.&#x27;)
    }
    //enhancer 接受 createStore 作为参数，对  createStore 的能力进行增强，并返回增强后的  createStore 。
    //  然后再将  reducer 和  preloadedState 作为参数传给增强后的  createStore ，最终得到生成的 store
    return enhancer(createStore)(reducer, preloadedState)
  }
  // reducer必须是函数
  if (typeof reducer !== &#x27;function&#x27;) {
    throw new Error(&#x27;Expected the reducer to be a function.&#x27;)
  }

 // 初始化参数
  let currentReducer = reducer   // 当前整个reducer
  let currentState = preloadedState   // 当前的state,也就是getState返回的值
  let currentListeners = []  // 当前的订阅store的监听器
  let nextListeners = currentListeners // 下一次的订阅
  let isDispatching = false // 是否处于 dispatch action 状态中, 默认为false

  // 这个函数用于确保currentListeners 和 nextListeners 是不同的引用
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }

  // 返回state
  function getState() {
    if (isDispatching) {
      throw new Error(
        ......
      )
    }
    return currentState
  }

  // 添加订阅
  function subscribe(listener) {
  ......
    }
  }
// 分发action
  function dispatch(action) {
    ......
  }

  //这个函数主要用于 reducer 的热替换，用的少
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the nextReducer to be a function.&#x27;)
    }
    // 替换reducer
    currentReducer = nextReducer
    // 重新进行初始化
    dispatch({ type: ActionTypes.REPLACE })
  }

  // 没有研究，暂且放着，它是不直接暴露给开发者的，提供了给其他一些像观察者模式库的交互操作。
  function observable() {
    ......
  }

  // 创建一个store时的默认state
  // 用于填充初始的状态树
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}

</code></pre>
<h5>subscribe</h5>
<pre><code class="language-JavaScript">function subscribe(listener) {
    if (typeof listener !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the listener to be a function.&#x27;)
    }

    if (isDispatching) {
      throw new Error(
        ......
      )
    }

    let isSubscribed = true
    // 如果 nextListeners 和 currentListeners 是一个引用，重新复制一个新的
    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          .......
        )
      }
      
      isSubscribed = false
      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      // 从nextListeners里面删除，会在下次dispatch生效
      nextListeners.splice(index, 1)
    }
  }
</code></pre>
<p>有时候有些人会觉得store.subscribe用的很少,其实不然，是react-redux隐式的为我们帮我们完成了这方面的工作。subscribe函数可以给 store 的状态添加订阅监听，一旦我们调用了 dispatch来分发action ，所有的监听函数就会执行。而 nextListeners 就是储存当前监听函数的列表，当调用 subscribe，传入一个函数作为参数时，就会给 nextListeners 列表 push 这个函数。同时调用 subscribe 函数会返回一个 unsubscribe 函数，用来解绑当前传入的函数，同时在 subscribe 函数定义了一个 isSubscribed 标志变量来判断当前的订阅是否已经被解绑，解绑的操作就是从 nextListeners 列表中删除当前的监听函数。</p>
<h5>dispatch</h5>
<p>dispatch是redux中一个非常核心的方法，也是我们在日常开发中最常用的方法之一。dispatch函数是用来触发状态改变的，他接受一个 action 对象作为参数，然后 reducer 就可以根据 action 的属性以及当前 store 的状态，来生成一个新的状态，从而改变 store 的状态；</p>
<pre><code class="language-JavaScript">function dispatch(action) {
    // action 必须是一个对象
    if (!isPlainObject(action)) {
      throw new Error(
        ......
      )
    }
    // type必须要有属性，不能是undefined
    if (typeof action.type === &#x27;undefined&#x27;) {
      throw new Error(
        ......
      )
    }
    // 禁止在reducers中进行dispatch，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度
    if (isDispatching) {
      throw new Error(&#x27;Reducers may not dispatch actions.&#x27;)
    }

    try {
      isDispatching = true
//       当前的状态和 action 传给当前的reducer，用于生成最新的 state
      currentState = currentReducer(currentState, action)
    } finally {  
      // 派发完毕
      isDispatching = false
    }
    // 将nextListeners交给listeners
    const listeners = (currentListeners = nextListeners)
    // 在得到新的状态后，依次调用所有的监听器，通知状态的变更
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }
    return action
  }
</code></pre>
<p>其中 currentState = currentReducer(currentState, action);这里的 currentReducer 是一个函数，他接受两个参数：</p>
<ul>
<li>当前状态</li>
<li>action</li>
</ul>
<p>然后返回计算出来的新的状态。</p>
<h4>2.3 compose.js</h4>
<p>compose 可以接受一组函数参数，从右到左来组合多个函数，然后返回一个组合函数。它的源码并不长，但设计的十分巧妙：</p>
<pre><code class="language-javascript">
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre>
<p>compose函数的作用其实其源码的注释里讲的很清楚了，比如下面这样：</p>
<pre><code class="language-JavaScript">compose(funcA, funcB, funcC)
</code></pre>
<p>其实它与这样是等价的：</p>
<pre><code class="language-JavaScript">compose(funcA(funcB(funcC())))
</code></pre>
<p>ompose 做的只是让我们在写深度嵌套的函数时，避免了代码的向右偏移。</p>
<h4>2.4 applyMiddleware</h4>
<p>applyMiddleware也是redux中非常重要的一个函数，设计的也非常巧妙，让人叹为观止。</p>
<pre><code class="language-JavaScript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    // 利用传入的createStore和reducer和创建一个store
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        `Dispatching while constructing your middleware is not allowed. ` +
          `Other middleware would not be applied to this dispatch.`
      )
    }
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>通过上面的代码，我们可以看出 applyMiddleware 是个三级<strong>柯里化</strong>的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer，也就是上面的...args；</p>
<p>applyMiddleware 利用 createStore 和 reducer 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量。</p>
<p>其中这一句我感觉是最核心的：</p>
<pre><code>dispatch = compose(...chain)(store.dispatch)
</code></pre>
<p>我特意将compose与applyMiddleware放在一块，就是为了解释这段代码。因此上面那段核心代码中，本质上就是这样的(假设...chain有三个函数)：</p>
<pre><code>dispatch = f1(f2(f3(store.dispatch))))
</code></pre>
<h4>2.5 combineReducers</h4>
<p>combineReducers 这个辅助函数的作用就是，将一个由多个不同 reducer 函数作为 value 的 object合并成一个最终的 reducer 函数，然后我们就可以对这个 reducer 调用 createStore 方法了。这在createStore的源码的注释中也有提到过。</p>
<p>并且合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名。</p>
<p>下面我们来看源码，下面的源码删除了一些的检查判断，只保留最主要的源码：</p>
<pre><code class="language-JavaScript">export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  // 有效的 reducer 列表
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]
  const finalReducerKeys = Object.keys(finalReducers)

// 返回最终生成的 reducer
  return function combination(state = {}, action) {
    let hasChanged = false
    //定义新的nextState
    const nextState = {}
    // 1，遍历reducers对象中的有效key，
    // 2，执行该key对应的value函数，即子reducer函数，并得到对应的state对象
    // 3，将新的子state挂到新的nextState对象上，而key不变
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
     // 遍历一遍看是否发生改变，发生改变了返回新的state，否则返回原先的state
    return hasChanged ? nextState : state
  }
}
</code></pre>
<h4>2.6 bindActionCreators</h4>
<p>bindActionCreators可以把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。
bindActionCreators函数并不常用（反正我还没有怎么用过），惟一会使用到 bindActionCreators 的场景就是我们需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，并且不希望把 dispatch 或 Redux store 传给它。</p>
<pre><code class="language-JavaScript">// 核心代码，并通过apply将this绑定起来
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments))
  }
} 
// 这个函数只是把actionCreators这个对象里面包含的每一个actionCreator按照原来的key的方式全部都封装了一遍，核心代码还是上面的
export default function bindActionCreators(actionCreators, dispatch) {
  // 如果actionCreators是一个函数，则说明只有一个actionCreator，就直接调用bindActionCreator
  if (typeof actionCreators === &#x27;function&#x27;) {
    return bindActionCreator(actionCreators, dispatch)
  }
  // 如果是actionCreator是对象或者null的话，就会报错
  if (typeof actionCreators !== &#x27;object&#x27; || actionCreators === null) {
    throw new Error(
    ... ... 
  }
 // 遍历对象，然后对每个遍历项的 actionCreator 生成函数，将函数按照原来的 key 值放到一个对象中，最后返回这个对象
  const keys = Object.keys(actionCreators)
  const boundActionCreators = {}
  for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &#x27;function&#x27;) {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}
</code></pre>
<h3>小节</h3>
<p>看一遍redux，感觉设计十分巧秒，不愧是大佬的作品。这次看代码只是初看，往后随着自己学习的不断深入，还需多加研究，绝对还能得到更多的体会。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/8" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:58:06+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/7</id><title>深入理解 Redux 中间件——走马观花</title><updated>2023-03-02T09:25:49.709042+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>最近几天对 redux 的中间件进行了一番梳理，又看了 redux-saga 的文档，和 redux-thunk 和 redux-promise 的源码，结合前段时间看的redux的源码的一些思考，感觉对 redux 中间件的有了更加深刻的认识，因此总结一下。</p>
<h3>一、Redux中间件机制</h3>
<p>Redux本身就提供了非常强大的数据流管理功能，但这并不是它唯一的强大之处，它还提供了利用中间件来扩展自身功能，以满足用户的开发需求。首先我们来看中间件的定义：</p>
<blockquote>
<p>It provides a third-party extension point between dispatching an action, and the moment it reaches
the reducer.</p>
</blockquote>
<p>这是Dan Abramov 对 middleware 的描述。简单来讲，Redux middleware 提供了一个分类处理 action 的机会。在 middleware 中，我们可以检阅每一个流过的 action,并挑选出特定类型的 action 进行相应操作，以此来改变 action。这样说起来可能会有点抽象，我们直接来看图，这是在没有中间件情况下的 redux 的数据流：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f39b787c?w=1269&amp;h=157&amp;f=png&amp;s=16392" alt="输入图片说明" title="redux.png" /></p>
<p>上面是很典型的一次 redux 的数据流的过程，但在增加了 middleware 后，我们就可以在这途中对 action 进行截获，并进行改变。且由于业务场景的多样性，单纯的修改 dispatch 和 reduce 显然不能满足大家的需要，因此对 redux middleware 的设计理念是可以自由组合，自由插拔的插件机制。也正是由于这个机制，我们在使用 middleware 时，我们可以通过串联不同的 middleware 来满足日常的开发需求，每一个 middleware 都可以处理一个相对独立的业务需求且相互串联：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f54070ae?w=1279&amp;h=239&amp;f=png&amp;s=27633" alt="image" /></p>
<p>如上图所示，派发给 redux Store 的 action 对象，会被 Store 上的多个中间件依次处理，如果把 action 和当前的 state 交给 reducer 处理的过程看做默认存在的中间件，那么其实所有的对 action 的处理都可以有中间件组成的。值得注意的是这些中间件会按照指定的顺序依次处理传入的 action，只有排在前面的中间件完成任务后，后面的中间件才有机会继续处理 action，同样的，每个中间件都有自己的“熔断”处理,当它认为这个 action 不需要后面的中间件进行处理时，后面的中间件就不能再对这个 action 进行处理了。</p>
<p>而不同的中间件之所以可以组合使用，是因为 Redux 要求所有的中间件必须提供统一的接口，每个中间件的尉氏县逻辑虽然不一样，但只要遵循统一的接口就能和redux以及其他的中间件对话了。</p>
<h3>二、理解中间价的机制</h3>
<p>由于redux 提供了 applyMiddleware 方法来加载 middleware，因此我们首先可以看一下 redux 中关于 applyMiddleware 的源码：</p>
<pre><code class="language-JavaScript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    // 利用传入的createStore和reducer和创建一个store
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
      )
    }
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>我们可以看到applyMiddleware的源码非常简单，但却非常精彩，具体的解读可以看我的这篇文章：
<a href="http://srtian96.gitee.io/blog/2018/06/02/%E8%A7%A3%E8%AF%BBRedux%E6%BA%90%E7%A0%81/">redux源码解读</a></p>
<p>从上面的代码我们不难看出，applyMiddleware 这个函数的核心就在于在于组合 compose，通过将不同的 middlewares 一层一层包裹到原生的 dispatch 之上，然后对 middleware 的设计采用柯里化的方式，以便于compose ，从而可以动态产生 next 方法以及保持 store 的一致性。</p>
<p>说起来可能有点绕，直接来看一个啥都不干的中间件是如何实现的：</p>
<pre><code class="language-JavaScript">const doNothingMidddleware = (dispatch, getState) =&gt; next =&gt; action =&gt; next(action)
</code></pre>
<p>上面这个函数接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数，但需要注意的是并不是所有的中间件都会用到这两个函数。然后 doNothingMidddleware 返回的函数接受一个 next 类型的参数，这个 next 是一个函数，如果调用了它，就代表着这个中间件完成了自己的职能，并将对 action 控制权交予下一个中间件。但需要注意的是，这个函数还不是处理 action 对象的函数，它所返回的那个以 action 为参数的函数才是。最后以 action 为参数的函数对传入的 action 对象进行处理，在这个地方可以进行操作，比如：</p>
<ul>
<li>调动dispatch派发一个新 action 对象</li>
<li>调用 getState 获得当前 Redux Store 上的状态</li>
<li>调用 next 告诉 Redux 当前中间件工作完毕，让 Redux 调用下一个中间件</li>
<li>访问 action 对象 action 上的所有数据</li>
</ul>
<p>在具有上面这些功能后，一个中间件就足够获取 Store 上的所有信息，也具有足够能力可用之数据的流转。看完上面这个最简单的中间件，下面我们来看一下 redux 中间件内，最出名的中间件 redux-thunk 的实现：</p>
<pre><code class="language-JavaScript">function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === &#x27;function&#x27;) {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
}
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
export default thunk;
</code></pre>
<p>redux-thunk的代码很简单，它通过函数是变成的思想来设计的，它让每个函数的功能都尽可能的小，然后通过函数的嵌套组合来实现复杂的功能，我上面写的那个最简单的中间件也是如此（当然，那是个瓜皮中间件）。redux-thunk 中间件的功能也很简单。首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action 。</p>
<p>需要注意的是，每个中间件最里层处理 action 参数的函数返回值都会影响 Store 上的 dispatch 函数的返回值，但每个中间件中这个函数返回值可能都不一样。就比如上面这个 react-thunk 中间件，返回的可能是一个 action 函数，也有可能返回的是下一个中间件返回的结果。因此，dispatch 函数调用的返回结果通常是不可控的，我们最好不要依赖于 dispatch 函数的返回值。</p>
<h3>三、redux的异步流</h3>
<p>在多种中间件中，处理 redux 异步事件的中间件，绝对占有举足轻重的地位。从简单的 react-thunk 到 redux-promise 再到 redux-saga等等，都代表这各自解决redux异步流管理问题的方案</p>
<h4>3.1 redux-thunk</h4>
<p>前面我们已经对redux-thunk进行了讨论，它通过多参数的 currying 以实现对函数的惰性求值，从而将同步的 action 转为异步的 action。在理解了redux-thunk后，我们在实现数据请求时，action就可以这么写了：</p>
<pre><code class="language-JavaScript">function getWeather(url, params) {
    return (dispatch, getState) =&gt; {
        fetch(url, params)
            .then(result =&gt; {
                dispatch({
                    type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: result,
                });
            })
            .catch(err =&gt; {
                dispatch({
                    type: &#x27;GET_WEATHER_ERROR&#x27;, error: err,
                });
            });
        };
}
</code></pre>
<p>尽管redux-thunk很简单，而且也很实用，但人总是有追求的，都追求着使用更加优雅的方法来实现redux异步流的控制，这就有了redux-promise。</p>
<h4>3.2 redux-promise</h4>
<p>不同的中间件都有着自己的适用场景，react-thunk 比较适合于简单的API请求的场景，而 Promise 则更适合于输入输出操作，比较fetch函数返回的结果就是一个Promise对象，下面就让我们来看下最简单的 Promise 对象是怎么实现的：</p>
<pre><code class="language-JavaScript">import { isFSA } from &#x27;flux-standard-action&#x27;;

function isPromise(val) {
  return val &amp;&amp; typeof val.then === &#x27;function&#x27;;
}

export default function promiseMiddleware({ dispatch }) {
  return next =&gt; action =&gt; {
    if (!isFSA(action)) {
      return isPromise(action)
        ? action.then(dispatch)
        : next(action);
    }

    return isPromise(action.payload)
      ? action.payload.then(
          result =&gt; dispatch({ ...action, payload: result }),
          error =&gt; {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          }
        )
      : next(action);
  };
}
</code></pre>
<p>它的逻辑也很简单主要是下面两部分：</p>
<ol>
<li>先判断是不是标准的 flux action。如果不是，那么判断是否是 promise, 是的话就执行 action.then(dispatch)，否则执行 next(action)。</li>
<li>如果是, 就先判断 payload 是否是 promise，如果是的话 payload.then 获取数据，然后把数据作为 payload 重新 dispatch({ ...action, payload: result}) ；不是的话就执行 next(action)</li>
</ol>
<p>结合 redux-promise 我们就可以利用 es7 的 async 和 await 语法，来简化异步操作了，比如这样：</p>
<pre><code class="language-JavaScript">const fetchData = (url, params) =&gt; fetch(url, params)
async function getWeather(url, params) {
    const result = await fetchData(url, params)
    if (result.error) {
        return {
            type: &#x27;GET_WEATHER_ERROR&#x27;, error: result.error,
        }
    }
        return {
            type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: result,
        }
    }
</code></pre>
<h4>3.3 redux-saga</h4>
<p>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。对于Saga，我们可简单定义如下：</p>
<blockquote>
<p>Saga = Worker + Watcher</p>
</blockquote>
<p>redux-saga相当于在Redux原有数据流中多了一层，通过对Action进行监听，从而捕获到监听的Action，然后可以派生一个新的任务对state进行维护（这个看项目本身的需求），通过更改的state驱动View的变更。如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f9ac4180?w=718&amp;h=428&amp;f=png&amp;s=16806" alt="image" /></p>
<p>saga特点：</p>
<ol>
<li>saga 的应用场景是复杂异步。</li>
<li>可以使用 takeEvery 打印 logger（logger大法好），便于测试。</li>
<li>提供 takeLatest/takeEvery/throttle 方法，可以便利的实现对事件的仅关注最近实践还是关注每一次实践的时间限频。</li>
<li>提供 cancel/delay 方法，可以便利的取消或延迟异步请求。</li>
<li>提供 race(effects)，[...effects] 方法来支持竞态和并行场景。</li>
<li>提供 channel 机制支持外部事件。</li>
</ol>
<pre><code class="language-JavaScript">function *getCurrCity(ip) {
    const data = yield call(&#x27;/api/getCurrCity.json&#x27;, { ip })
    yield put({
        type: &#x27;GET_CITY_SUCCESS&#x27;, payload: data,
    })
}
function * getWeather(cityId) {
    const data = yield call(&#x27;/api/getWeatherInfo.json&#x27;, { cityId })
    yield put({
        type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: data,
    })
}
function loadInitData(ip) {
    yield getCurrCity(ip)
    yield getWeather(getCityIdWithState(state))
    yield put({
        type: &#x27;GET_DATA_SUCCESS&#x27;,
    })
}
</code></pre>
<p>总的来讲Redux Saga适用于对事件操作有细粒度需求的场景，同时它也提供了更好的可测试性，与可维护性，比较适合对异步处理要求高的大型项目，而小而简单的项目完全可以使用 redux-thunk 就足以满足自身需求了。毕竟 react-thunk 对于一个项目本身而言，毫无侵入，使用极其简单，只需引入这个中间件就行了。而 react-saga 则要求较高，难度较大，但胜在优雅（虽然我觉得asycn await的写法更优雅）。我现在也并没有掌握和实践这种异步流的管理方式，因此较为底层的东西先就不讨论了。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入浅出React和Redux》</li>
<li>《深入React技术栈》</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/7" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:56:41+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/6</id><title>初探 HTML5 Web Workers</title><updated>2023-03-02T09:25:49.890937+00:00</updated><content type="html"><![CDATA[<h3>一、Web Workers是什么</h3>
<blockquote>
<p>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和通道属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序 (反之亦然)。 —— MDN</p>
</blockquote>
<p>众所周知，JavaScript是单线程的编程语言，也就是说，当我们在页面中进行一个较为耗时的计算的JavaScript代码时，在这段代码执行完毕之前，页面是无法响应用户操作的。也正是出于这个原因，HTML5为我们提供了 Web Workers 以解决这种问题，当我们需要在JavaScript中来进行耗时的计算或诸如此类的问题时，我们可以使用 Web Workers 在浏览器的后台启动一个独立的 Worker 线程来专门负责这段代码的运行，而不会阻碍后面代码的运行。</p>
<h3>二、Web Workers的使用</h3>
<h4>1. 实例化一个 Worker</h4>
<p>实例化运行一个 Worker 很简单，我们只需要 new 一个 Worker 全局对象即可。</p>
<pre><code class="language-JavaScript">var worker = new Worker(&#x27;./worker.js&#x27;)
</code></pre>
<p>它接受一个 filepathname String 参数，用于指定 Worker 脚本文件的路径。然后我们就可以在 worker.js 中写下一些代码:</p>
<pre><code class="language-JavaScript">console.log(&#x27;my_WOEKER:&#x27;, &#x27;srtian&#x27;)
</code></pre>
<p>另外，通过URL.createObjectURL()创建URL对象，也可以实现创建内嵌的worker:</p>
<pre><code class="language-JavaScript">var myTask = `
    var i = 0;
    var timedCount = () =&gt; {
        i = i+1;
        postMessage(i);
        setTimeout(timedCount, 1000);
    }
    timedCount();
`;

var myblob = new Blob([myTask]);
var myWorker = new Worker(window.URL.createObjectURL(myblob));
</code></pre>
<blockquote>
<p>需要注意的是，传入 Worker 构造函数的参数 URI 必须遵循同源策略。</p>
</blockquote>
<p>此外因为Worker线程的创建的是异步的，所以主线程代码不会阻塞在这里等待 worker 线程去加载、执行指定的脚本文件，而是会立即向下继续执行后面代码这点也需要注意。</p>
<h4>2. 数据通信</h4>
<p>当我们实例化一个 Worker 线程后，Worker不会相互，或者与主程序共享任何作用域或资源——那会将所有的多线程编程的噩梦带到我们面前——取而代之的是一种连接它们的基本事件消息机制。因此他们需要通过基于事件监听机制的message来进行通信，我们在new Worker()后悔返回一个实例对象，它包含了一个postMessage的方法，我们可以通过调用这个方法来给worker线程传递信息，我们也可以给这个对象监听事件，从而在worker线程中出发事件通信的时候能接收到数据。</p>
<pre><code class="language-JavaScript">var worker = new worker(&#x27;./worker.js&#x27;)
worker.addEventListener(&#x27;message&#x27;, function(e) {
    console.log(&#x27;worker receive:&#x27;, e.data )
}
worker.postMessage(&#x27;hello worker,this is main.js&#x27;)
</code></pre>
<p>然后在worker.js这个脚本中，我们就可以调用全局函数postMessage和全局的onmessage赋值来发送和监听数据和事件了。</p>
<pre><code class="language-JavaScript">// 监听事件
onmessage = function (e) {
  console.log(&#x27;WORKER RECEIVE：&#x27;, e.data);
  // 发送数据事件
  postMessage(&#x27;Hello, this is worker.js&#x27;);
}
</code></pre>
<p>需要注意的是 worker 支持 JavaScript 中所有类型的数据传递，可以传递一个 Object 数据；但这里的数据传递（主要是 Object 类型）并不是共享，而是复制。发送端的数据和接收端的数据是复制而来，并不指向同一个对象，此外这里的复制不是简单的拷贝，而是通过两端的序列化/解序列化来实现的，一般来说浏览器会通过 JSON 编码/解码；当然，这里的更多细节部分会由浏览器来处理，我们并不需要关心这些，只需要明白两端的数据是复制而来，互相独立的就行了。</p>
<h4>3. 错误处理机制</h4>
<p>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。</p>
<p>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。</p>
<p>错误事件有以下三个用户关心的字段：</p>
<ul>
<li>message: 可读性良好的错误消息。</li>
<li>filename: 发生错误的脚本文件名。</li>
<li>lineno: 发生错误时所在脚本文件的行号。 </li>
</ul>
<p>实际操作如下：</p>
<pre><code class="language-JavaScript">var worker = new Worker(&#x27;./worker.js&#x27;);

// 监听消息事件
worker.addEventListener(&#x27;message&#x27;, function (e) {
  console.log(&#x27;MAIN RECEIVE： &#x27;, e.data);
});
// 也可以使用 onMessage 来监听事件：


// 监听 error 事件
worker.addEventListener(&#x27;error&#x27;, function (e) {
  console.log(&#x27;MAIN ERROR：&#x27;, e);
  console.log(&#x27;MAIN ERROR：&#x27;, &#x27;filename:&#x27; + e.filename + &#x27;---message:&#x27; + e.message + &#x27;---lineno:&#x27; + e.lineno);
});


// 触发事件，传递信息给 Worker
worker.postMessage({
  m: &#x27;Hello Worker, this is main.js&#x27;
});
</code></pre>
<h4>4. 终止 Worker</h4>
<p>当我们在不需要 Worker 继续运行时，我就需要终止掉这个线程，这时候我们就可以调用 worker 的 terminate 方法:</p>
<pre><code class="language-javascript">worker.terminate()
</code></pre>
<p>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p>
<p>而在worker线程中，workers 也可以调用自己的 close  方法进行关闭：</p>
<pre><code>close()
</code></pre>
<h3>三. Web Workers的兼容</h3>
<p>由于Web Workers是HTML5所提供的，因此从兼容性上来说，还是需要注意的。总的兼容情况如下图所示：
<img src="https://user-gold-cdn.xitu.io/2018/7/21/164bb60041e07800?w=2360&amp;h=1190&amp;f=png&amp;s=52309" alt="image" />
图片来源：<a href="https://caniuse.com/#feat=webworkers">https://caniuse.com/#feat=webworkers</a></p>
<p>我们可以看到，虽然web worker很不错，但如果我们的代码执行在较老的浏览器中时，是缺乏支持的。但由于worker是一个API而不是语法，因此我门还是可以去填补它的。</p>
<p>这一块的详情可以去看——《你不知道的JavaScript中卷》关于 web worker 的那一节。</p>
<h3>四、Web Workers支持的JavaScript特性</h3>
<p>由于在 Worker 线程的运行环境中没有 window 全局对象，也无法访问 DOM 对象，所以一般来说我们在这只能执行纯JavaScript的计算操作，当然1我们那：</p>
<ul>
<li>setTimeout()， clearTimeout()， setInterval()， clearInterval()：有了设计个函数，就可以在 Worker 线程中执行定时操作了；</li>
<li>XMLHttpRequest 对象：意味着我们可以在 Worker 线程中执行 ajax 请求；</li>
<li>navigator 对象：可以获取到 ppName，appVersion，platform，userAgent 等信息；</li>
<li>location 对象（只读）：可以获取到有关当前 URL 的信息；</li>
<li>应用缓存</li>
<li>使用 importScripts() 引入外部 script</li>
<li>创建其他的 Web Worker</li>
</ul>
<h3>五、Web Worker 的实践</h3>
<p>总的来说，Web Worker为我们带来了强大的计算能力，我们可以加载一个JavaScript进行大量的复杂计算，而用不挂起主进程。并通过postMessage，onmessage进行通信，这也解决了大量计算对UI渲染的阻塞问题。</p>
<h4>应用场景</h4>
<h5>1、数学运算</h5>
<p>Web Worker最简单的应用应该就是用来进行后台计算了，这对CPU密集型的场景再适合不过了。</p>
<h5>2、图像处理</h5>
<p>通过使用从 canvas 中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同Workers来做计算，对图像进行像素级的处理，再把处理完成的图像数据返回给主页面。</p>
<h5>3、大数据的处理</h5>
<p>目前mvvm框架越来越普及，基于数据驱动的开发模式也越愈发流行，未来大数据的处理也可能转向到前台，因此我们将大数据的处理交给在Web Worker也是很好的。</p>
<h5>4. 数据预处理</h5>
<p>为优化的网站或 web 应用的数据加载时长，我们可以使用 Web Worker 预先获取一些数据，存储起来以备后续使用，因为它绝不会影响应用的 UI 体验。</p>
<h5>5. 大量的 ajax 请求或者网络服务轮询</h5>
<p>由于在主线程中每启动一个XMLHttpRequest请求都会消耗资源，虽然在请求过程中浏览器另外开了一个线程，但是在交互过程中还是需要消耗主线程资源；而使用worker则不会过多占用主线程，只是启动worker过程时比较耗资源。</p>
<blockquote>
<p>原文：<a href="http://srtian96.gitee.io/blog/2018/07/21/%E5%88%9D%E6%8E%A2%20HTML5%20Web%20Workers/">初探 HTML5 Web Workers</a></p>
</blockquote>
<p>参考资料：</p>
<ol>
<li>《你不知道的JavaScript中卷》</li>
<li><a href="https://juejin.im/post/59c1b3645188250ea1502e46">https://juejin.im/post/59c1b3645188250ea1502e46</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a></li>
<li><a href="https://qiutc.me/post/the-multithread-in-javascript-web-worker.html">https://qiutc.me/post/the-multithread-in-javascript-web-worker.html</a></li>
<li><a href="https://juejin.im/post/5a90233bf265da4e92683de3">https://juejin.im/post/5a90233bf265da4e92683de3</a></li>
</ol>
]]></content><link href="https://github.com/srtian/Blog/issues/6" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:54:12+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/5</id><title>浅谈HTTP缓存</title><updated>2023-03-02T09:25:50.080860+00:00</updated><content type="html"><![CDATA[<h3>一、HTTP缓存概述（HTTP Cache）</h3>
<p>要搞清楚HTTP缓存，首先当然是要搞清楚缓存是啥，按照MDN的描述，缓存是这样的：</p>
<blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
</blockquote>
<p>上面已经将会缓存是什么描述的很清楚了，而HTTP缓存顾名思义，就是通过HTTP协议，来实现对资源缓存的目的。总的来说，HTTP缓存主要通过两个HTTP头来实现的，其中Expires是由HTTP1.0提供的，而Cache-Control则是由HTTP1.1所提供的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b78d14ea59?w=372&amp;h=321&amp;f=png&amp;s=6680" alt="HTTP缓存图1.PNG" /></p>
<p>下面我们就来对这两个头进行一个了解。</p>
<h3>二、Expires</h3>
<p>Expires是由HTTP1.0所提供的支持HTTP缓存的头部，由服务器返回，用GMT格式的字符串表示：</p>
<pre><code class="language-HTTP">expires: Tue, 14 Aug 2018 14:32:49 GMT
</code></pre>
<p>而读取缓存的条件则是：缓存过期时间（服务器的时间）&lt; 当前时间（客户端的时间）</p>
<p>值得注意的是，我们在expires所设置的时间是一个绝对的时间，而且所参照的是用户电脑上所设置的时间。这种绝对的时间很容易出问题，当用户本地的时间不准确，或用户进行跨时区的移动时，这个时间很可能就会过期，而无法发挥它本应该发挥的作用。</p>
<p>其次，在HTTP1.0里，没有提供相应的配置缓存的方法，只是提供了这个强缓存的头部而已，不足以满足项目对缓存多样化的需求。也正是出于以上两个原因，在HTTP1.1中对HTTP缓存又进行了升级。</p>
<h3>三、 Cache-Control</h3>
<p>正是由于Expires存在着很多不足，所以HTTP1.1又为我们提供了 </p>
<p>Cache-Control主要可配置的参数有以下几个：</p>
<ol>
<li>max-age 会指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）。例如，“max-age=60”表示可在接下来的 60 秒缓存和重用响应。</li>
<li>Public 表示响应可被任何缓存区缓存</li>
<li>Private 表示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这些响应通常只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。</li>
<li>no-cache 表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。</li>
<li>no-store则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</li>
<li>min-fresh 表示客户端可以接收响应时间小于当前时间加上指定时间的响应。（用的不多）</li>
<li>max-stale 表示客户端可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。（用的不多）</li>
</ol>
<h3>四、强缓存</h3>
<p>上面已经将Catch-Control做了一个简单的介绍，而具体使用它们二者进行缓存操作的具体实现又分为强缓存与协商缓存。首先来聊一聊强缓存。</p>
<p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。在这个有效期内当浏览器对某个资源的请求命中了强缓存时，其返回的http状态为200，并且不会去对服务器进行请求，而是直接使用其本地的缓存。</p>
<p>具体实现如下：</p>
<pre><code>expires: Tue, 21 Aug 2018 10:17:45 GMT
cache-control: max-age=691200
</code></pre>
<p>只要存在以上两个头部信息的其中一个，我们就可以对资源进行强缓存了。另外需要注意的是，当Catch-Control的优先级是要高于expires的。</p>
<p>总的来说，强缓存是前端性能优化的一大助力。当我们页面存在很多长期不变的静态资源时，都应该对其进行强缓存的处理，我们通常可以为这些静态资源全部配置一个超时时间很长的Expires或Cache-Control。当用户在访问网页时，就只会在第一次加载时从服务器请求静态资源，在往后访问该页面时，就只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。这样既节省了资源加载的时间的消耗，又不会去访问服务器，可以有效地为服务器减压。</p>
<p>不过强缓存也存在一个很大的弊端，那就是对于动态资源它就有点力不从心了。因为如果我们对动态资源进行了强缓存，那么很可能会在这动态资源更改后，浏览器还是会直接去请求没有更改前的动态资源。也这是由于这方面的考虑，在强缓存外还存在着协商缓存的缓存方案。</p>
<h3>五、协商缓存</h3>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串；
若未命中请求，则将资源返回客户端，并更新本地缓存数据，并返回200的状态码。</p>
<p>除此之外，我们也可以设置为协商缓存，以解决动态资源缓存与更新的问题，首先我们来看一张关于协商缓存的图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b788163d06?w=1074&amp;h=588&amp;f=png&amp;s=36570" alt="输入图片说明" /></p>
<p>可以看到，在这个实现了协商缓存的Cache-Control中，设置了no-catch，当我们设置为no-catch时，我们就是可以直接去访问服务器，去查看该资源的更改情况，已确定是是否需要使用缓存。而在校验的这一步我们就需要使用以下几个头来帮助验证资源的更改情况了：</p>
<ul>
<li>Last-Modified：表示这个响应资源的最后修改时间。web服务器在响应请求时，会告诉浏览器该资源的最后修改时间，但它的最小单位是秒级，也就是如果我们在1秒内多次修改该资源，那么Last-Modified也无法发挥其应有的作用。</li>
<li>If-Modified-Since：当资源过期时（强缓存失效），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li>
</ul>
<p>也正是由于 Last-Modified存在着缺陷，我们就需要ETag来帮助我们来对资源的更改进行判断：</p>
<ul>
<li>Etag：当Web服务器响应请求时，会告诉浏览器当前资源在服务器的唯一标识（生成规则是由服务器决定的）。就比如在Apache中，ETag的值，其默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li>If-None-Match：当资源过期时，如果发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。Web服务器收到请求后发现有头If-None-Match， 就会将其被请求的资源的相应校验字段进行对比，然后再决定返回200或304。</li>
</ul>
<p>这就是强缓存与协商缓存的大部分情况了，具体的流程可见下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785" alt="image" /></p>
<p>原图链接：<a href="https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785">https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785</a></p>
<h4>六、定义最佳 Cache-Control 策略</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b88bae2f00?w=595&amp;h=600&amp;f=png&amp;s=14914" alt="image" /></p>
<p>通常我们可以按照上面这张流程图来对HTTP缓存进行相应的配置，详情可以看这篇文章：</p>
<blockquote>
<p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a>?</p>
</blockquote>
<p>这位大佬对缓存的配置做了一个很好的阐述。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a>?</li>
<li><a href="https://www.cnblogs.com/lyzg/p/5125934.html#_label3">https://www.cnblogs.com/lyzg/p/5125934.html#_label3</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/5" rel="alternate"/><category term="FE"/><category term="Web"/><category term="Basis"/><published>2019-09-28T09:52:53+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/4</id><title>五分钟，简单聊一聊React Component的发展历程</title><updated>2023-03-02T09:25:50.253053+00:00</updated><content type="html"><![CDATA[<h3>一、 前言</h3>
<p>随着 react 最新的一个大版本中，给我们带来了 Hooks：<a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html">React v16.8: The One With Hooks</a>，从而将 Function component 的能力提高了一大截，成功的拥有了可以与 Class component 抗衡的能力。但话说回来，虽然 Hooks 看起来很美好，最近也有不少文章都讲解了Hooks这一“黑魔法”，但技术的不断演进，本身就是一个解决以往所存在问题的过程，因此我个人认为着眼于现在，回望过去，去看一看 react component 的发展之路，去看看 Class component 以及 Function component 为什么会出现以及它们出现的意义，所要解决的问题，也对于我们全面了解 react 是很有帮助的。</p>
<p>从 react component 的发展历程上来看，它主要是经历了一下三个阶段：</p>
<ol>
<li>createClass Component </li>
<li>Class Component </li>
<li>Function Component</li>
</ol>
<p>这个三个阶段也是react的组件不断走向轻量级的一个过程。其中 Class Component 完全替代了 createClass Component 成为了现在我们开发 react 组件的主流，而 Function Component 也在 Hooks 推出后磨刀霍霍，准备大干一场。下面就让我们去看看三者的具体情况吧~</p>
<blockquote>
<p>注：这篇文章整体只是对React Component的发展历程的一个概括或者说是我自己学习后的一个整理，想要详细了解，还请看看我在文章贴的那些链接。</p>
</blockquote>
<h3>二、 createClass Component</h3>
<p>说实话，createClass Component 我也没用过，因为我接触到 react 的时候已经是2017年下半年了，那时候 ES6 已经大行其道，class component 也已经完全取代了 createClass Component。但现在看来 createClass Component 的语法也很简单，并不复杂：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

const MyComponent = React.createClass({
  // 通过proTypes对象和getDefaultProps()方法来设置和获取props
  propTypes: {
    name: React.PropTypes.string
  },
  getDefaultProps() {
    return {

    }
  },
  // 通过getInitialState()方法返回一个包含初始值的对象
  getInitialState(){ 
        return {
            sayHello: &#x27;Hello Srtian&#x27;
        }
    }
  render() {
    return (
      &lt;p&gt;&lt;/p&gt;
    )
  }
})

export default MyComponent
</code></pre>
<p>react.createClass的语法并不复杂，它通过 createClass 来创建一个组件，并通过propTypes和getDefaultProps来获取props，通过通过getInitialState()方法返回一个包含初始值的对象，虽然从现在看来还是有点麻烦，但总体上来看代码也比较清晰，跟现在的 Class Component差别并不是太大。但 react.createClass 自从 react 15.5版本就不再为 react 官方所推介，而是想让大家的使用 class component 来代替它。而且在 react 16版本发布后，createClass 更是被废弃，当我们使用它的时候，会提示报错，也就是说，在 react 团队看来 createClass 已经完全没有存在的必要了。</p>
<p>其实 Class Component 完全替代 React.createClass 并不是说 React.createClass 有多坏，相反它还有一些 class Component 所没有的特性。它的废弃是由于ES6的出现，新增了 class 这一语法糖，让我们在 JavaScript 的开发中可以直接使用 extends 来扩展我们的对象，因此为了与标准的ES6接轨，原有的只在 react 中使用的 createClass 自然而然也成为了被抛弃的对象。但 class Component 在刚出现的时候也仍然存在的不小的争议，因为这两者还是存在一定的差别的，比如当时在Stack Overflow便出现了关于这两者的讨论，感兴趣的朋友可以去看看：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></p>
</blockquote>
<p>总的来说，除了语法上存在差异外，Class Component 和 React.createClass 的区别主要是以下两点（详情可以看看上面的回答）：</p>
<ul>
<li>React.createClass 会正确绑定 this，而 React.Component 则不行，我们需要在 constructor 里面使用 bind 或者直接使用箭头函数来绑定 this。</li>
<li>React.Component 不能使用 React mixins 特性，这一方面我们可以使用高阶组件来弥补。</li>
</ul>
<h3>三、Class Component</h3>
<p>Class Component创建的方式也很简单，就是普通的ES6的class的语法，通过extends来创建一个新的对象来创建react组件，下面是使用class Component创建一个组件的例子（由于为了给后面聊一聊hooks，所以在这里我使用了antd的例子）</p>
<pre><code class="language-JavaScript">class Modal extends React.Component {
  state = { visible: false }

  showModal = () =&gt; {
    this.setState({
      visible: true,
    });
  }
  handleOk = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  handleCancel = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Button type=&quot;primary&quot; onClick={this.showModal}&gt;
          Open Modal
        &lt;/Button&gt;
        &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={this.state.visible}
          onOk={this.handleOk}
          onCancel={this.handleCancel}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>上面就是antd中一个简单的 modal 组件的例子，其内部就是通过维护 visible 的状态来控制这个 modal 是否显示。我们可以看到，其中的一些方法都是使用箭头函数的方式来将 this 绑定到正确的属性。（具体为什么要这么做，不清楚的朋友可以看看下面这篇文章：）</p>
<blockquote>
<p><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></p>
</blockquote>
<p>而类似于上面的这种组件，也是近两年来我们在日常开发中使用最多的组件开发的方式。那为什么到了现在，我们又开始要强调使用 Function Component 来进行开发了呢？主要是由于 Class Component 所开发的组件仍然存在以下一些问题：</p>
<ol>
<li>this 绑定的问题：
我们前面也提到了，我们在使用原本的 React.createClass 时并不需要去考虑this绑定的问题，而现在我们却要时刻注意使用bind或者箭头函数来让this正确绑定，同时也让一些新上手react的同学的上手成本有所提升。虽然这不是React的锅，但这方面的问题仍然客观存在。</li>
<li>嵌套地狱： 这种情况则多发生于需要用到Context的场景下，在这种场景下，数据是同步的，因为需要通知更新所有有引用到数据的地方，因此我们就需要通过render-props 的形式定义在Context.Consumer的children中，而使用到越多的Context 就会导致嵌套层级越多，这很容易让人看代码看的一脸懵逼。比如这样：</li>
</ol>
<pre><code class="language-JavaScript">&lt;FirstContext.Consumer&gt;
  {first =&gt; (
    &lt;SecondContext.Consumer&gt;
      {second =&gt; (
        &lt;ThirdContext.Consumer&gt;
          {third =&gt; (
            &lt;Component /&gt;
          )}
        &lt;/ThirdContext.Consumer&gt;
      )}
    &lt;/SecondContext.Consumer&gt;
  )}
&lt;/FirstContext.Consumer&gt;
</code></pre>
<ol start="3">
<li>Life-cycles 的问题：生命周期函数也是我们在日常开发所经常使用到的东西。虽然生命周期函数用起来很方便，但一旦组件的逻辑变得复杂起来，这些生命周期函数也会变得难以理解和维护；同时如何让这些生命周期函数与react渲染有效结合也是一个不小的问题，这往往可能会让一些刚上手的人摸不着头脑。此外使用这些生命周期函数时也可能会出现一些预料之外的事情发生（比如在某些生命周期函数中进行数据请求，而导致组件被重复渲染多次的问题等等，这些都是有可能发生的）</li>
</ol>
<blockquote>
<p>详细可以去看看知乎上的这个回答：<a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></p>
</blockquote>
<h3>四、Function Component</h3>
<p>看到这里，大家对class Component所存在的一些问题也算是有一些了解了，但为什么它还能横行如此之久，一直占据着主流的地位呢？其本质上就是因为没有竞争对手嘛，Function Component 长期没有内部状态管理机制，只能通过外部来管理状态，因此组件的可测试性非常的高，写起来也简洁明了，符合现在前端函数式的大潮流，是个好同志。但也正是因为没有状态管理机制，所以无法和Class Component相抗衡，毕竟一旦组件内部的逻辑变得复杂之后，内部的状态管理机制是必须的。</p>
<p>因此 React 团队基于 Function Component 提出 Hooks 的概念，用以解决 Function Component 的内部状态管理，同时也希望通过 Hooks 来解决 Class Component 所存在的问题。下面就是使用 Hooks 针对 antd 中的 modal 进行的改写，大家可以自行感受一下：</p>
<pre><code class="language-JavaScript">const Modal = () =&gt; {
  const [visible , changeVisible] = useState(false)
  return (
    &lt;div&gt;
      &lt;Button type=&quot;primary&quot; onClick={()=&gt;changeVisible(true)}&gt;open&lt;/Button&gt;
      &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={visible}
          onOk={()=&gt;changeVisible(false)}
          onCancel={()=&gt;changeVisible(false)}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>我们可以看到，基于 Function Component 与 Hooks 所编写出来的组件代码是相当简洁明了的，也直接避免了我们上面所提到的 this 指向的问题。而对于上面所提到的嵌套地狱以及 Life-cycles 的问题，Hooks也提供了 useContext 和 useEffect（这个倒还是存在一些问题） 来解决，在这里我也不详细说了，详情可以去看官方文档或者是 Dan 的博客：</p>
<blockquote>
<p><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></p>
</blockquote>
<p>好了，看到这里我想大家都以为上面 Class Component 的问题都已经得到圆满解决了，Function Component好像已经圆满了，我们只管放心的使用它就好了。但世界上哪有这么好的事情，Function Component 仍然存在着下面几个 tip 是我们在使用前要知道的：</p>
<ol>
<li>Function Component 与 Class Component 表现不同，这块不清楚的可以直接去看Dan的文章，他对这方面做了很明白的阐述：</li>
</ol>
<blockquote>
<p><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></p>
</blockquote>
<ol start="2">
<li>使用useState需要注意的是，它的执行顺序要在每次 render 时必须保持一致，不可以进判断和循环，必须写在最前面，关于这一点看视频：</li>
</ol>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></p>
</blockquote>
<ol start="3">
<li>Function Component 中，外部对与函数式组件的操作只能通过 props 来进行控制，不能通过函数式组件内部暴露方法来对组件进行操作。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://ultimatecourses.com/blog/react-create-class-versus-component">https://ultimatecourses.com/blog/react-create-class-versus-component</a></li>
<li><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></li>
<li><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></li>
<li><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></li>
<li><a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></li>
<li><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></li>
<li><a href="http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/">http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/</a></li>
<li><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/4" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:52:12+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/3</id><title>浅析 Rematch 源码</title><updated>2023-03-02T09:25:50.423872+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>入职后公司用的技术栈还是 react，但状态管理由我原本熟悉的 redux 进化成了在 redux 基础上封装而成的 rematch。用起来也着实方便不少，减少了很多样板代码的编写，同时也不用引入中间件来管理异步请求了，但在用起来的过程中难免就会引起了我对 rematch 的一些小疑问：</p>
<ul>
<li>它是怎么封装 诸如action creator这些以往在 redux 中繁琐的“样本”代码的？</li>
<li>它是如何区分 reducer action 以及 effect action 的？</li>
<li>等等</li>
</ul>
<p>带着上面的这些疑问，我翻开了 rematch 的源码开始读了起来</p>
<h3>一、总览</h3>
<p>打开 rematch 的文件目录，来到 src 文件夹下，可以看到其文件的主要层级如下：</p>
<pre><code>.src
├── plugins     
│    ├── dispatch.ts    //  同于生成 dispatch
│    ├── effects.ts  //  同于处理异步 action
├── typings   //  类型约束文件
├── utils   //  工具函数 
├── index.ts    //  入口文件      
├── pluginFactory.ts  
├── redux.ts    //  基础redux
├── rematch.ts  //  Rematch基类
</code></pre>
<p>然后打开 index.ts 文件，rematch 的 index 文件非常精简，现版本只存在两个具有实际应用价值的函数：</p>
<pre><code class="language-TypeScript">// 为给定对象创建model，然后返回作为参数接收的对象
export function createModel&lt;S = any, M extends R.ModelConfig&lt;S&gt; = any&gt;(model: M) {
	return model
}

let count = 0

export const init = (initConfig: R.InitConfig = {}): R.RematchStore =&gt; {
	// 如果不指定 name，就将其迭代的次数作为 name
	const name = initConfig.name || count.toString()
	count += 1
	// 配置的对象，在这里使用 mergeConfig 来合并
	const config: R.Config = mergeConfig({ ...initConfig, name })
	// 在这里会先将 config 的信息传入 Rematch 函数中，然后会被 init 函数会执行，而它的结果也在此被返回，也就是我们新生成的 store
	return new Rematch(config).init()
}

export default {
	init,
}
</code></pre>
<p>index 文件中最为核心的就是 init 函数了，它主要做了以下工作：</p>
<ul>
<li>初始化 store 的 name</li>
<li>将 name 与传入的 config 对象，并返回新的 config 对象</li>
<li>把新的 config 对象作为参数传入，返回 new Rematch(config).init()</li>
</ul>
<h3>二、Rematch</h3>
<p>上面的 index 文件到了 new Rematch(config).init() 就截然而止了，虽然我们知道他已经在此过程中，完成了一个 store 的创建，但这个过程我却并不知晓，因此接下来就是要去翻阅 rematch.ts 文件，首先扫一眼这个文件的大概情况，为后面的阅读做个铺垫:</p>
<pre><code class="language-javascript">import pluginFactory from &#x27;./pluginFactory&#x27;
import dispatchPlugin from &#x27;./plugins/dispatch&#x27;
import effectsPlugin from &#x27;./plugins/effects&#x27;
import createRedux from &#x27;./redux&#x27;
import * as R from &#x27;./typings&#x27;
import validate from &#x27;./utils/validate&#x27;

const corePlugins: R.Plugin[] = [dispatchPlugin, effectsPlugin]

/**
 * Rematch class
 *
 * an instance of Rematch generated by &quot;init&quot;
 */
export default class Rematch {
	protected config: R.Config
	protected models: R.Model[]
	private plugins: R.Plugin[] = []
	private pluginFactory: R.PluginFactory

	constructor(config: R.Config) {
		
	}
	public forEachPlugin(method: string, fn: (content: any) =&gt; void) {
		
	}
	public getModels(models: R.Models): R.Model[] {
		
	}
	public addModel(model: R.Model) {
		
	}
	public init() {
	
    }
}
</code></pre>
<p>首先来看 rematch.ts 的类的声明部分：</p>
<pre><code class="language-JavaScript">export default class Rematch {
	protected config: R.Config
	protected models: R.Model[]
	private plugins: R.Plugin[] = []
	private pluginFactory: R.PluginFactory

	constructor(config: R.Config) {
	    // 这里的 config 就是从 index.ts 里传入的 config
		this.config = config
		this.pluginFactory = pluginFactory(config)
		// 遍历 corePlugins 以及 config 中的 plugins
		// 对其中的每个 plugins 通过 pluginFactor.create 生成 plugins 数组
		for (const plugin of corePlugins.concat(this.config.plugins)) {
			this.plugins.push(this.pluginFactory.create(plugin))
		}
		// preStore: middleware, model hooks
		// 将 middleware 执行一遍，并将 middleware 添加到 this.config.redux.middlewares 这个数组中
		this.forEachPlugin(&#x27;middleware&#x27;, (middleware) =&gt; {
			this.config.redux.middlewares.push(middleware)
		})
	}
	... ... 
}
</code></pre>
<p>通过上面的代码我们可以发现，当我们去实例化 Rematch 时，首先会去执行这里的构造函数。这个构造函数主要是为了处理 plugin，并对两类不同的 plugin 分别进行处理：</p>
<ul>
<li>一种是 corePlugin，也就是核心插件 dispatchPlugin 以及 effectsPlugin ，这里会将他们 push 到 this.plugin 数组中存储起来。</li>
<li>而对于中间件插件，由于中间件插件本身都是“不纯”的，因此本身就属于 effectsPlugin ，这里会将 effectsPlugin 中的 middleWares push 到 this.config.redux.middlewares 中去进行存储。</li>
</ul>
<p>接下来就是 rematch 中定义的三个方法了：</p>
<pre><code class="language-JavaScript">    public forEachPlugin(method: string, fn: (content: any) =&gt; void) {
        for (const plugin of this.plugins) {
            if (plugin[method]) {
                fn(plugin[method])
            }
        }
    }
    public getModels(models: R.Models): R.Model[] {
        return Object.keys(models).map((name: string) =&gt; ({
            name,
            ...models[name],
            reducers: models[name].reducers || {},
        }))
    }
    public addModel(model: R.Model) {
        validate([
            [!model, &#x27;model config is required&#x27;],
            [typeof model.name !== &#x27;string&#x27;, &#x27;model &quot;name&quot; [string] is required&#x27;],
            [model.state === undefined, &#x27;model &quot;state&quot; is required&#x27;],
        ])
        // run plugin model subscriptions
        this.forEachPlugin(&#x27;onModel&#x27;, (onModel) =&gt; onModel(model))
    }
</code></pre>
<p>从这三个方法的名字我们就不难看出这是哪个方法的具体作用了，这三个方法主要是为了协助上面的构造函数以及下面 init() ，因此在此就不一一赘述了。下面就来重头戏 init() :</p>
<pre><code class="language-JavaScript">public init() {
		// collect all models
		// 通过 getModels 获取所有的 models
		this.models = this.getModels(this.config.models)
		// 遍历所有的 models 执行 addModels 
		for (const model of this.models) {
			this.addModel(model)
		}
		// create a redux store with initialState
		// merge in additional extra reducers
		// 这里就是更新 state 的 reducer 了，后面具体会有分析
		const redux = createRedux.call(this, {
			redux: this.config.redux,
			models: this.models,
		})

		const rematchStore = {
			name: this.config.name,
			...redux.store,
			// dynamic loading of models with `replaceReducer`
			model: (model: R.Model) =&gt; {
				this.addModel(model)
				redux.mergeReducers(redux.createModelReducer(model))
				redux.store.replaceReducer(redux.createRootReducer(this.config.redux.rootReducers))
				redux.store.dispatch({ type: &#x27;@@redux/REPLACE &#x27;})
			},
		}

		this.forEachPlugin(&#x27;onStoreCreated&#x27;, (onStoreCreated) =&gt; {
			const returned = onStoreCreated(rematchStore)
			// if onStoreCreated returns an object value
			// merge its returned value onto the store
			if (returned) {
				Object.keys(returned || {}).forEach((key) =&gt; {
					rematchStore[key] = returned[key]
				})
			}
		})

		return rematchStore
	}
</code></pre>
<p>init() 会先执行 getModels 从而获取所有的 models ，并返回给 this.model, 然后通过遍历 this.model，对其中的每个 models 都执行 addModel ，然后就会去调用 forEachPlugin。这块的执行逻辑稍微有点深，但其实本质上就是为了让所有的 models 都这么执行一次:</p>
<pre><code class="language-JavaScript">plugin.onModel(model)
</code></pre>
<p>同时这里也会根据 model 的不同的情况，去执行两种plugin：dispatchPlugin 和 effectPlugin。</p>
<p>其中 dispatchPlugin 的 onModel 处理如下：</p>
<pre><code class="language-JavaScript">// dispatch.ts
onModel(model: R.Model) {
		this.dispatch[model.name] = {}
		if (!model.reducers) {
			return
		}
		for (const reducerName of Object.keys(model.reducers)) {
			this.validate([
				[
					!!reducerName.match(/\/.+\//),
					`Invalid reducer name (${model.name}/${reducerName})`,
				],
				[
					typeof model.reducers[reducerName] !== &#x27;function&#x27;,
					`Invalid reducer (${model.name}/${reducerName}). Must be a function`,
				],
			])
			// 根据 model Name 和 reducer Name 生成相应的 dispatch 函数
			this.dispatch[model.name][reducerName] = this.createDispatcher.apply(
				this,
				[model.name, reducerName]
			)
		}
	}
</code></pre>
<p>我们可以看到 onModel 函数会遍历所有的 reducer，然后生成相应的 dispatch 函数（如何实现后面讨论）</p>
<p>而 effectsPlugin 的 onModel 则是这样的：</p>
<pre><code class="language-JavaScript">onModel(model: R.Model): void {
		if (!model.effects) {
			return
		}

		const effects =
			typeof model.effects === &#x27;function&#x27;
				? model.effects(this.dispatch)
				: model.effects

		for (const effectName of Object.keys(effects)) {
			this.validate([
				[
					!!effectName.match(/\//),
					`Invalid effect name (${model.name}/${effectName})`,
				],
				[
					typeof effects[effectName] !== &#x27;function&#x27;,
					`Invalid effect (${model.name}/${effectName}). Must be a function`,
				],
			])
			this.effects[`${model.name}/${effectName}`] = effects[effectName].bind(
				this.dispatch[model.name]
			)
			// add effect to dispatch
			// is assuming dispatch is available already... that the dispatch plugin is in there
			this.dispatch[model.name][effectName] = this.createDispatcher.apply(
				this,
				[model.name, effectName]
			)
			// tag effects so they can be differentiated from normal actions
			this.dispatch[model.name][effectName].isEffect = true
		}
	},
</code></pre>
<p>这两者的 onModel 其实都差不多，最大的却别就是 effectsPlugin 的 onModel 在最后标记了 isEffect 为 true 。然后我们就可以来看 this.createDispatcher 到底做了什么：</p>
<pre><code class="language-JavaScript">/**
		 * createDispatcher
		 *
		 * genereates an action creator for a given model &amp; reducer
		 * @param modelName string
		 * @param reducerName string
		 */
createDispatcher(modelName: string, reducerName: string) {
			return async (payload?: any, meta?: any): Promise&lt;any&gt; =&gt; {
				const action: R.Action = { type: `${modelName}/${reducerName}` }
				if (typeof payload !== &#x27;undefined&#x27;) {
					action.payload = payload
				}
				if (typeof meta !== &#x27;undefined&#x27;) {
					action.meta = meta
				}
				return this.dispatch(action)
			}
		}
</code></pre>
<p>createDispatcher 函数的作用注释里说的很清楚，为 model 和 reducer 生成相应的 action creator，其内部实现是返回一个 async 函数，内部有由 model name 以及 reducer name 组成的套路化的 action type，然后再返回 dispatch(action) 的执行结果。这个 dispatch 又会到哪去呢？让我们将目光回到 rematch.ts 中的 init() 中去，我在上面的代码中有提到这么一段代码：</p>
<pre><code class="language-JavaScript">// 这里就是更新 state 的 reducer 了，后面具体会有分析
const redux = createRedux.call(this, {
	redux: this.config.redux,
	models: this.models,
})
</code></pre>
<p>实际上我们这段代码就相当于我们在 redux 中的 reducer ，他会接收到 dispatch(action) 从而变动 state。它的详情代码在 redux 中：</p>
<pre><code class="language-JavaScript">import * as Redux from &#x27;redux&#x27;
import * as R from &#x27;./typings&#x27;
import isListener from &#x27;./utils/isListener&#x27;

const composeEnhancersWithDevtools = (
	devtoolOptions: R.DevtoolOptions = {}
): any =&gt; {
	const { disabled, ...options } = devtoolOptions
	/* istanbul ignore next */
	return !disabled &amp;&amp;
		typeof window === &#x27;object&#x27; &amp;&amp;
		window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
		? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(options)
		: Redux.compose
}

export default function({
	redux,
	models,
}: {
	redux: R.ConfigRedux,
	models: R.Model[],
}) {
	const combineReducers = redux.combineReducers || Redux.combineReducers
	const createStore: Redux.StoreCreator = redux.createStore || Redux.createStore
	const initialState: any =
		typeof redux.initialState !== &#x27;undefined&#x27; ? redux.initialState : {}

	this.reducers = redux.reducers

	// combine models to generate reducers
	this.mergeReducers = (nextReducers: R.ModelReducers = {}) =&gt; {
		// merge new reducers with existing reducers
		// 将已经新的 reducers 和 存在的 reducer 合并
		this.reducers = { ...this.reducers, ...nextReducers }
		// 如果没有 reducers 就直接返回 state
		if (!Object.keys(this.reducers).length) {
			// no reducers, just return state
			return (state: any) =&gt; state
		}
		//  执行合并操作
		return combineReducers(this.reducers)
	}

	this.createModelReducer = (model: R.Model) =&gt; {
		const modelBaseReducer = model.baseReducer
		const modelReducers = {}
		// 遍历 model.reducers ，为其中的每个 reducer 创造一个命名空间，并将其赋值到 modelReducer 中去
		for (const modelReducer of Object.keys(model.reducers || {})) {
			const action = isListener(modelReducer)
				? modelReducer
				: `${model.name}/${modelReducer}`
			modelReducers[action] = model.reducers[modelReducer]
		}
		const combinedReducer = (state: any = model.state, action: R.Action) =&gt; {
			// handle effects
			if (typeof modelReducers[action.type] === &#x27;function&#x27;) {
				return modelReducers[action.type](state, action.payload, action.meta)
			}
			return state
		}

		this.reducers[model.name] = !modelBaseReducer
			? combinedReducer
			: (state: any, action: R.Action) =&gt;
					combinedReducer(modelBaseReducer(state, action), action)
	}
	// initialize model reducers
	// 创建 model 的 reducer
	for (const model of models) {
		this.createModelReducer(model)
	}

	this.createRootReducer = (
		rootReducers: R.RootReducers = {}
	): Redux.Reducer&lt;any, R.Action&gt; =&gt; {
		const mergedReducers: Redux.Reducer&lt;any&gt; = this.mergeReducers()
		if (Object.keys(rootReducers).length) {
			return (state, action) =&gt; {
				const rootReducerAction = rootReducers[action.type]
				if (rootReducers[action.type]) {
					return mergedReducers(rootReducerAction(state, action), action)
				}
				return mergedReducers(state, action)
			}
		}
		return mergedReducers
	}

	const rootReducer = this.createRootReducer(redux.rootReducers)

	const middlewares = Redux.applyMiddleware(...redux.middlewares)
	const enhancers = composeEnhancersWithDevtools(redux.devtoolOptions)(
		...redux.enhancers,
		middlewares
	)
    // 创建一个 redux store，并返回 this 对象
	this.store = createStore(rootReducer, initialState, enhancers)

	return this
}
</code></pre>
<h3>三、小结</h3>
<p>总的来说，rematch 其实就是在 redux 的基础上进行了封装，将我们本来在 redux 中要写的诸如action creator等诸多样本代码给予封装，只需要关心 model 的划分以及写出合理的 reducers 以及 effects 即可。因此简单回答上面我看源码时所带的那两个问题：</p>
<ol>
<li>如何区分reducer action以及 effect action</li>
</ol>
<ul>
<li>rematch 在内部有两种 plugin，一种是 dispatchPlugin，一种是 effectPlugin，前者只会让 reducers 进入逻辑代码，后者只会让 effects 进入逻辑代码，并且会标记 isEffect = true</li>
</ul>
<ol start="2">
<li>它是怎么封装 诸如action creator这些以往在 redux 中繁琐的“样本”代码的？</li>
</ol>
<ul>
<li>rematch 在内部的 createDispatch 函数内部会根据 model name 以及 reducer name 创建相应的 action.type，以及对应的 action.payload，然后 dispatch 到 reducer 中去即可，同时也在这个函数内部内置的 async 来支持异步的 action。</li>
</ul>
<h4>扩展阅读</h4>
<ul>
<li><a href="https://juejin.im/post/5b13fe155188257d6c046728">Redux 源码解读</a></li>
<li><a href="https://juejin.im/post/5b237569f265da59bf79f3e9">深入理解 Redux 中间件</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/3" rel="alternate"/><category term="FE"/><category term="JavaScript"/><category term="React"/><published>2019-09-28T09:41:20+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/2</id><title>《Don't Make Me Think》读书笔记</title><updated>2023-03-02T09:25:50.601831+00:00</updated><content type="html"><![CDATA[<h3>一、别让我思考</h3>
<p>网页的易用性最重要的一点就是无需用户去思考。这也代表着交互一般劲量趋向于简单化，平整化，以减少用户的认知负担，减少对用户的干扰。</p>
<p>示例：亚马逊搜索没有提及一定要去搜索什么内容，只会对你所输入的进行分析，这样就会减少用户的思考的成本（淘宝也是如此，通过自然语言处理来对用户的输入进行分析）</p>
<p>比较典型的地方：</p>
<ul>
<li>按钮是否明显</li>
<li>相同的信息是否集中</li>
<li>搜索是否便捷</li>
<li>关键功能的位置是否显眼、是否易用</li>
</ul>
<h3>二、扫描，满意即可，勉强应付</h3>
<p>根据我自身使用web的时候，突然觉得这个很有道理。往往当我们在web上进行浏览的时候，只会对我们所关注的信息进行仔细的观察。也就是说，我们在访问一个网页时，会首先对整个网页进行一次扫描，在这个扫描的过程中，我们会对我们感兴趣的知识进行提取，而那些我们在扫描过程中不是很在意的东西就会进行忽略。</p>
<p>为什么扫描：</p>
<ul>
<li>我们总是处于忙碌中</li>
<li>我们知道自己不必阅读所有内容</li>
<li>我们善于扫描</li>
</ul>
<p>也真是由于用户只是扫描页面，因此其实用户并不会去真正的寻找最佳结构，而是满意即可，即选择第一个合理的选项。（我们在作出决策也是如此，只会寻找第一个合理的决策就可能去执行）</p>
<h3>三、 广告牌设计101法则（为扫描设计，不为阅读设计）</h3>
<p>正是由于我们是扫描页面的，因此要采取以下五个原则：</p>
<ol>
<li>在每个页面上建立清楚的视觉层次</li>
<li>尽量利用习惯用法</li>
<li>把页面划分成明确定义的区域</li>
<li>明显表示可以点击的地方</li>
<li>最大限度降低干扰</li>
</ol>
<h4>3.1 建立清楚的视觉层次</h4>
<p>一个视觉层次清楚的页面有三个特点：</p>
<ol>
<li>越重要的部分越突出（h1-h6/p1-p6）</li>
<li>逻辑上相关的部分在视觉上也相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ol>
<h4>3.2 关于习惯用法</h4>
<p>首先他们很重要，正是由于习惯、所以符合用户的习惯。但由于设计师们需要造轮子来证明自己（其实工程师也是这样），所以他们一般不想直接使用习惯用法，而是设计出属于自己的一套方法论。</p>
<h4>3.3 把页面划分为明确定义的区域</h4>
<p>这可以让用户快速决定关注页面的那些位置（即重点扫描的区域）</p>
<h4>3.4 明显表示可以点击的地方</h4>
<p>颜色不同、质感不同等方式。别让用户到处去找</p>
<h4>3.5 降低视觉噪声</h4>
<p>页面的难以理解最大的原因就在于视觉噪声，视觉噪声大致分为两大类：</p>
<ul>
<li>眼花缭乱：满眼惊叹号，毫无层次等</li>
<li>背景噪声</li>
</ul>
<h3>第四章 为什么用户喜欢无需思考的选择</h3>
<p>一般来说用户在达到目标前所需要的点击次数不应过多（很多网站规定点击次数不应该超过5次）（通常来说网页越平整化越好）</p>
<blockquote>
<p>注：三次无需思考，明确无误的点击相当与一次需要思考的地点击</p>
</blockquote>
<h3>第五章 省略不必要的文字</h3>
<blockquote>
<p>去掉每个页面上一半的文字，然后把剩下的文字再去掉一般 —— krug可用性第三定律</p>
</blockquote>
<p>去掉多余文字的好处：</p>
<ul>
<li>可以降低页面的噪声</li>
<li>让有用的内容更突出</li>
<li>让页面更尖端，让用户在浏览时可以扫描的内容更多，无需滚屏</li>
</ul>
<p>那么我们可以做下面一些事情：</p>
<ol>
<li>欢迎词必须消灭</li>
<li>知识说明必须要消灭</li>
</ol>
<h3>第六章 设计导航</h3>
<p>如果网页上让大家找不到方向，人们就不会使用你的网站。</p>
<p>那么重要的事情首先要做的事就是让相关的事物集中在一块，这样当用户在浏览网页的时候，就能快速定位自己所需要找的内容的大体位置。</p>
<h4>6.1 网络导航101法则</h4>
<p>我们浏览一个网页的过程：</p>
<ul>
<li>你通常是为了寻找某个目标</li>
<li>如果选择浏览，你将通过标志的引导在层次结构中穿行</li>
<li>找不到我们就会跑路</li>
</ul>
<p>导航的作用：</p>
<ol>
<li>他给了我们一些固定的感觉</li>
<li>他告诉我们当前的位置</li>
<li>他告诉我们如何使用网站</li>
<li>他给了我们对网站建造者的信心</li>
</ol>
<p>重要的是由这两者元素：主页和表单</p>
<ul>
<li>主页：我们可以直接通过主页来确定我们当前的位置</li>
<li>表单：可以将栏目、工具都汇聚在这里，但依然要注意相关性的原则，且层级不应该过深（尽量少于3次）</li>
</ul>
<p>此外要注意的是要保证，无论用户到哪都给他一个可以直接返回主页的按钮，这可以给用户安全感，不会迷失方向。</p>
<p>此外我们还有以下几点需要避免的：</p>
<ul>
<li>花哨的用词</li>
<li>指示说明</li>
<li>选项</li>
</ul>
<p>页面名称需要注意的：</p>
<ul>
<li>大小应该要大于其他的文字</li>
<li>应该出现在合适的位置</li>
<li>每个页面都需要一个名称</li>
<li>名称要引人注意</li>
<li>名称要和点击的链接一致</li>
</ul>
<h4>6.2 层级导航</h4>
<p>除了主页面的导航外，还有就是使用层级导航来帮助用户导航。关于层级导航有以下几点最佳实践：</p>
<ul>
<li>把他们放在最顶端</li>
<li>使用&gt;对层级进行分隔</li>
<li>使用小字体</li>
<li>使用了文字“你在这里”</li>
<li>将最后一个元素加粗</li>
<li>没有把他们用作页面的名称</li>
</ul>
<h4>6.3 标签</h4>
<p>标签的好处：</p>
<ol>
<li>它们不言而喻</li>
<li>它们很难错过</li>
<li>它们很灵活</li>
<li>它们暗示了一个物理空间</li>
</ol>
<p>标签的绘制方法：</p>
<ol>
<li>正确绘制</li>
<li>颜色编码（选中的与没选中的不一样）</li>
<li>当你进入网站时，有一个标签已经选中</li>
</ol>
<h4>6.4 后备箱测试</h4>
<p>所谓的后备箱测试指的是页面设计良好，我们就能快速的答出以下的一些问题：</p>
<ul>
<li>这是什么网站</li>
<li>我在哪个网页上</li>
<li>这个网站的主要栏目是哪些</li>
<li>在这个层次上我有哪些选择</li>
<li>我在导航系统的什么位置</li>
<li>我怎么搜索</li>
</ul>
<p><strong>降低用户好感的方式：</strong></p>
<ul>
<li>隐藏我想要的信息</li>
<li>因为没有按照你们的方式行事而惩罚我</li>
<li>向我询问不必要的信息</li>
<li>敷衍我，欺骗我</li>
<li>给我设置障碍</li>
<li>你的网站看起来不专业</li>
</ul>
<p><strong>提高好感的几种方式：</strong></p>
<ul>
<li>知道人们在你网站上像做什么，并让他们明白简易</li>
<li>告诉我我想知道的</li>
<li>尽量减少步骤</li>
<li>花点心思</li>
<li>知道我可能有哪些疑问，并且给予解答</li>
<li>为我提供协助</li>
<li>容易从错误中恢复</li>
<li>如有不确定，记得道歉</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/2" rel="alternate"/><category term="Notes"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:34:00+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/1</id><title>浅析浏览器进程发展历程</title><updated>2023-03-02T09:25:50.810076+00:00</updated><content type="html"><![CDATA[<h3>一、浏览器的多进程概括</h3>
<p>要想搞明白什么是浏览器的多进程，首先得知道什么是进程。按照维基百科的说法：</p>
<blockquote>
<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>
</blockquote>
<p>简单来讲，进程就是CPU资源分配的最小单位，而线程则是CPU调度的最小单位。那什么又是单线程和多线程呢，我们来看一小段代码：</p>
<pre><code>var a = 1 + 10086
var b = 100 * 2
var c = (20 + 1) * 2
var d = 100/10
var e = a + b + c + d
console.log(e)
</code></pre>
<p>譬如上面的代码，如果是在单线程的运行环境比如JavaScript，就会需要将上面的计算一个个的去执行完成，然后得出运行结果，也就需要进行六步才能将e打印出来，但如果是在多线程的运行环境中则只需要使用四个线程来同时计算上面的四个运算，待上面的四个运算全部完成后再把他们相加，然后再打印出来。因此使用多线程的并行运算可以大大的提高程序的性能以及效率。</p>
<p>但虽然多线程可以有效的提高程序的运行效率，但它是不能单独存在的，它需要进程的启动与管理。简单来说，进程与线程之间会存在以下四种关系：</p>
<ul>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。很常见就是JavaScript出现的执行线程出错时会导致整个页面进程的崩溃，而导致页面白屏。</li>
<li>线程之间共享同进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
<li>进程之间的内容会相互隔离。每个进程都只能访问自己访问的数据，这可以有效的避免一个进程的崩溃而影响到其他的进程。如果进程之间有进行数据通信的需要，这时候就需要进程通信（IPC）机制了。</li>
</ul>
<h3>二、浏览器进程发展过程</h3>
<p>现在我们都知道浏览器都是多进程的，但其实回顾历史发展的历程，浏览器也经历了一个由单进程到多进程的发展历程。现在就让我们来理一理浏览器单线程到多线程的发展历程。</p>
<h4>2.1 青铜时代---单进程的浏览器</h4>
<p>2007年之前，所有的浏览器都是单进程的，其中的典型代表就是IE6了。在ID6的时代，页面还是单标签的，一个页面一个窗口，一个窗口一个主线程。因此顾名思义，单进程的浏览器就是指打开一个浏览器，其中包含一个页面，而这个页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。具体架构如下图所示：
<img src="https://github.com/srtian/2018-08-14-04-14-25-1534220065/blob/master/main/%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="image" />
基于这种情况，单进程的浏览器就存在以下一些问题：</p>
<h5>1. 不稳定</h5>
<p>早期的浏览器都是通过各式各样的插件来实现诸如视频、游戏等功能的，而插件本身又很不靠谱，由于插件运行在浏览器进程之中，因此一个插件的意外崩溃就会导致整个浏览器的奔溃。同样的，渲染引擎也是这个道理，往往一个JavaScript的bu就可能导致整个页面崩溃。</p>
<h5>2. 不流畅</h5>
<p>因为所有页面的JavaScript线程、渲染模块、以及第三方插件都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。此外当时国产的浏览器其实都是基于IE6来进行二次开发的，因此这些国产浏览器虽然基于自身需要，都采用的多标签页的形式，但这些多标签页其实也是跑在同一个线程里的，这就会导致其中一个标签页的卡顿会影响到整个浏览器。</p>
<h5>3. 不安全</h5>
<p>不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题</p>
<h4>2.2 白银时代---多进程浏览器时代</h4>
<p>终于随着 Chrome 浏览器的发布，浏览器架构终于来到了多进程的时代。其中 Chrome 浏览器的进程架构如下：
<img src="https://github.com/srtian/2018-08-14-04-14-25-1534220065/blob/master/main/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.png?raw=true" alt="image" />
其主要作用如下：</p>
<ol>
<li>Browser进程（浏览器进程）：这是浏览器的主进程。有且只有一个，它主要有以下几个作用：</li>
</ol>
<ul>
<li>负责浏览器页面的显示与页面交互</li>
<li>负责个页面的管理。创建和销毁其他进程</li>
<li>将 Renderer 进程得到的内存中的 Bitmap ，绘制到用户页面上。</li>
<li>网络资源的管理，下载等。</li>
</ul>
<ol start="2">
<li>第三方插件进程：主要负责插件的运行，每种类型的插件都对应着一个进程，只有当使用该插件时才会创建该进程，这样就做到了隔离插件的效果，保证插件的崩溃不会影响到浏览器以及页面。</li>
<li>GPU进程：最多一个，用于3D绘制。这个进程在最初是没有的。但为了实现 3D CSS 的效果，GPU进程成为了浏览器的普遍需求，因此Chrome浏览器也在其多进程的架构上引入了GPU进程。</li>
<li>浏览器渲染进程，也就是浏览器内核，Renderer进程，内部是多线程的：默认每个Tab页面都是一个进程，互相不影响。主要作用是页面渲染，脚本执行，事件处理等。</li>
<li>网络进程：主要负责页面的网络资源的加载，之前是作为一个模块运行在浏览器进程中的，最近几年才独立出来，作为一个单独的进程存在。</li>
</ol>
<p>然后基于以上的架构，我们来看看他们是如何解决单进程浏览器所存在的问题的：</p>
<h5>1. 解决不稳定</h5>
<p>首先浏览器渲染进程本省就是分离开来的，每个Tab也面都是一个单独的进程，互不影响。其次将第三方插件进程也单独拎了出来，这样就算一个页面的插件出现可问题，也不会影响到这个页面的渲染进程，也就不会对浏览器造成影响了。</p>
<h5>2. 解决不流畅</h5>
<p>在多进程的架构下，JavaScript 只是运行在自己的渲染进程中的，因此即使 JavaScript 代码阻塞了渲染进程，受到影响的也只是当前所渲染的页面。脚本运行也是同样的道理。而对于常常引发性能问题的内存泄漏，在这种架构下，关闭一个页面，会将整个渲染进程给关闭，这时候操作系统就会回收这个进程所占用的内存，也就会不会存在内存泄漏的问题了。</p>
<h5>3. 解决不安全</h5>
<p>采用多金策的架构的一个好处就是可以使用安全沙盒，沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。而charome浏览器就将插件进程以及渲染进程所在了沙盒之中，这样即使插件进程以及渲染进程有恶意程序在执行，也无法突破沙盒去获取系统权限，对我们的电脑造成影响。</p>
<p>虽然现在的多进程的浏览器看起来很美好，解决了原先单进程浏览器所存在的诸多的问题，但同样不可避免的存在着一些问题：</p>
<ul>
<li>资源占用更多了</li>
<li>更为复杂的体系结构</li>
</ul>
<h4>2.3  黄金时代---SOA架构</h4>
<p>为了解决现在浏览器所存在的资源占用高，体系更为复杂的问题，2016年 Chrome 团队就开始使用 “面向服务的架构”（SOA)的思想来设计新的 Chrome 架构。</p>
<p>那什么是SOA呢，简单来说SOA就是一种组件模型，他将应用程序的不同功能单元通过这些服务之间所定义好的接口或者契约联系起来。接口采用中立的方式来进行定义，独立于硬件平台、操作系统以及编程语言。这使得构建各种各样的系统中的服务都可以以一种统一和通用的方式来进行交互。</p>
<p>也就是说， Chrome要做的就是将UI进程、设备、文件、Audio等等模块都编程基础服务，每个服务都可以在独立的进程中运行，而访问这些服务也必须使用定义好的接口，并通过IPC来进行通信。从而构建一个更内聚、松耦合、更易维护和扩展的系统。</p>
<p><img src="https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png" alt="image" /></p>
]]></content><link href="https://github.com/srtian/Blog/issues/1" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:12:37+00:00</published></entry></feed>