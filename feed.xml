<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/srtian/Blog</id><title>RSS feed of srtian's Blog</title><updated>2023-03-02T09:44:02.660054+00:00</updated><author><name>srtian</name><email>shenruotian@gmail.com</email></author><link href="https://github.com/srtian/Blog"/><link href="https://raw.githubusercontent.com/srtian/Blog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/srtian/Blog/issues/35</id><title>初探 Serverless</title><updated>2023-03-02T09:44:02.968216+00:00</updated><content type="html"><![CDATA[<h1>前言</h1>
<p>这篇文章主要是讨论一下 Serverless 的发展历程以及在前端的一些落地场景，以及我在看伯克利的这篇论文：<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf">《Cloud Programming Simplified: A Berkeley View onServerless Computing》</a> 的一些记录。具体想要详细的了解 Serverless 也建议直接去阅读这篇论文，相信会有不少收获的。</p>
<h1>一、 什么是Serverless</h1>
<p>讨论一个技术的具体使用场景，首先需要将其做一个定义，确定我们说要讨论的范围。确定讨论的范围，归根结底，首先需要了解 Serverless 所产生的背景以及其具体以什么方式解决了什么样的问题。</p>
<h2>1.1 Serverless的背景以及历史</h2>
<p>在云计算已经普及的今天， Serverless 已经是一个在各大技术论坛或者演讲上，出现频率非常高的技术名词了，在前端也不例外，几乎每个大的前端技术演讲会议，都会或多或少的提到它，并扯扯它和前端的一些交集或者结合的落地场景。</p>
<p>但溯本回源，Serverless 的产生，归根结底是要解决什么问题呢？要回答这个问题，我们不得不去回顾云计算的发展历程。在云计算刚刚兴起的时候，市场上主流的两种云服务方案分别是亚马逊推出的 EC2 和谷歌推出的 App Engine (GAE)。这两种方案分别代表了两种思路：</p>
<ul>
<li>EC2 选择了提供底层基础，它的实例使用起来和一台物理服务器十分类似，没有任何的额外功能，你可以在上面运行任何类型、任何语言的服务；</li>
<li>GAE 则选择了提供高层抽象，包括令人印象深刻的自动缩扩容等能力，但同时对用户能够运行的代码做出了限制 —— 要想获得这些特性，就必须使用google提供的储存和计算服务，遵循相应的规范。</li>
</ul>
<p>最终市场选择了AWS的 EC2，这主要是因为开发者们更倾向于使用和自己本地开发环境相同的环境来运行服务，这样做，开发好的代码基本不需要什么改动就可以轻易部署到云实例上去。但这种模式虽然极大的给予了开发者自由度，但也意味着几乎所有的运维操作都交由开发者自己去解决，**因此大部分的云服务的使用者在使用云服务的同时，不得不承担复杂的运维成本以及较低的硬件使用率。**Serverless的产生就是为了解决这些问题而产生的。<br />              <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420346-a2281eb5-256e-4772-9948-f75899359077.png#align=left&amp;display=inline&amp;height=120&amp;originHeight=120&amp;originWidth=619&amp;size=0&amp;status=done&amp;style=none&amp;width=619" alt="" /></p>
<p>而回顾Serverless 这一名词的诞生，需要我们将时间线拉回到2012年，这是 Serverless 这一技术名词第一次出现在大家视野中的时间点。Ken 在他的文章：<a href="https://readwrite.com/2012/10/15/why-the-future-of-software-and-apps-is-serverless/?__cf_chl_jschl_tk__=2e846b39e94ae54ff7af11c6e12cb23f8f25fff2-1607050809-0-AeqVODmUcZBg0qZXOwSFRle_BUy9MciSv0JnWmm3Hiqwj2-jHoGnAd3tb9GI8WGww5wC-kPL2RcPcFxrTmFLM-QwUsy_sAoBzJQvnAd11W-zLVnwQUloDUsQeUzNGO2neSMmiOB_4XA9rsRy9DE4qgHGygZNjzSb2QkSA98u_ugxxccMRFFUnB0qxmdhqZJqXMzAVdQq57i9Y38dFbBqut4mfF378CGZDOZDlS1QXb_kdHB1Tcagke3c35Lhw6kNQU7OsMrEEddGEfntErkpHrMQCdEaIR8RJLsYxhI65MKw2GQuKXLNRaMlgQBWUJD9nN_fQ90SLMZJA0sTzk6bhoSNKkQokDchXc9eEzSmzK25xmynuK9oAdQ5r4D1oic601OCwrW1A64_1lGYxNA_wdaDtifGDxDztBlzsNCj2rmRyx7qAZlvPGa4nLjSFc1BtQ">Why The Future Of Software And Apps Is Serverless</a> 中提出了 Serverless 之一名词，开始让 Serverless 进入大家的视野。引述这篇文章的一段话，算是对 Serverless 早期定义的解释：</p>
<blockquote>
</blockquote>
<h2>Thinking Serverless</h2>
<blockquote>
<p>The phrase “serverless” doesn’t mean servers are no longer involved. It simply means that developers no longer have to think that much about them. Computing resources get used as services without having to manage around physical capacities or limits.</p>
</blockquote>
<p>总的来说，这个时间点的 Serverless，更多的是关于对于计算机底层运维方面的抽象的讨论，也算是去思考如何解决 <strong>复杂的运维成本</strong> 这一问题。</p>
<p>而真正让 Serverless 名声大噪的是 Amazon 在 2015 年发布的 <a href="https://aws.amazon.com/lambda/">AWS Lambda</a> ，提出了 **Cloud Function **的概念，让 Serverless 提高的一个全新的高度，它不仅仅通过抽象底层运维能力，来为云开发者提供运维能力的支持以及抽象，并且提供快速缩扩容以及按调用收费的机制，提升了资源利用率，降低使用者的成本。这也是第一个真正意义上我们今天所说的 Faas 平台，正是从那一年开始， Serverless 开始成为国际上炙手可热的名词，出现在各大云计算的会议之上。</p>
<p>而到了2017年，国内的 Paas 以及 laas 平台，也推出了自己的函数计算平台，加入到了 Serverless 的推广以及建设当中。</p>
<h2>1.2 Serverless 的技术组成</h2>
<p>明确了Serverless的产生背景，当今社区上对Serverless的定义其实还是比较模糊的，但总的来讲，翻阅一些较为权威的资料，大体上还是较为相同的，譬如号称 Serverless 白皮书的：<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf">《Cloud Programming Simplified: A Berkeley View onServerless Computing》</a>中关于 Serverless 的定义是：</p>
<blockquote>
<p>Put simply, serverless computing  =  FaaS + BaaS，In our definition, for a service to be considered serverless, it must scaleautomatically with no need for explicit provisioning, and be billed based on usage.</p>
</blockquote>
<p>提取几个关键字：serverless = FaaS + Baas，且必须能够实现<strong>自动缩扩容</strong>和<strong>按使用量计费</strong>。另外在<a href="https://martinfowler.com/articles/serverless.html">《Serverless Architectures》</a>，也是将 Serverless 视为 FaaS 和 BaaS 的结合：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420359-1a7ee5f1-7dee-4149-974e-57f72f976876.png#align=left&amp;display=inline&amp;height=716&amp;originHeight=716&amp;originWidth=3140&amp;size=0&amp;status=done&amp;style=none&amp;width=3140" alt="" /><br />因此在这里，我们在此讨论的 Serverless 也就按照 Serverless = FaaS + BaaS 的定义了（但其实我个人更倾向于将Serverless视为一种降低开发门槛，提升开发效率的架构模式） ：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420339-9f4633da-87bb-4642-892b-ad06da227022.png#align=left&amp;display=inline&amp;height=396&amp;originHeight=396&amp;originWidth=762&amp;size=0&amp;status=done&amp;style=none&amp;width=762" alt="" /></p>
<p>其中 FaaS（Functions as a Service）直译过来就是：函数即服务。FaaS 是无服务器计算的一种形式，当前使用最广泛的是 AWS 的 Lambada 函数计算平台。FaaS 本质上是一种事件驱动的由消息触发的服务，FaaS 供应商一般会集成各种同步和异步的事件源，通过订阅这些事件源，可以突发或者定期的触发函数运行。</p>
<p>而这里的函数，则是提供了比微服务更微细小的程序单元。比如，我们可以将微服务按照某个用户特定的一系列CRUD操作进行拆分。而在FaaS下，用户的每个操作，比如创建这一操作，就对应着我们在函数计算平台上的一个函数，只要通过触发器触发它，就可以执行操作事件。下面这个图就很形象的体现函数计算的特点：<br /><img src="https://cdn.nlark.com/yuque/0/2020/gif/296173/1609222420356-0994bff1-0304-457f-a6f1-597941071c2e.gif#align=left&amp;display=inline&amp;height=457&amp;originHeight=457&amp;originWidth=1024&amp;size=0&amp;status=done&amp;style=none&amp;width=1024" alt="" /><br />（图来自：<a href="https://developer.aliyun.com/article/574222">https://developer.aliyun.com/article/574222</a>）<br />而 BaaS（Backend-as-a-Service）后端即服务，它是基于 API 的第三方服务，用于实现应用程序中的后端功能核心功能，包含常用的数据库、对象存储、消息队列、日志服务等等。</p>
<p>下面这个表格列举了一下传统的Serverful(也就是云计算)和 Serverless 的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th align="left"><br />特性</th>
<th align="left">AWS Serverless 云计算</th>
<th align="left">AWS Serverful 云计算</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发者</td>
<td align="left">何时运行程序</td>
<td align="left">由用户根据事件自行选择</td>
<td align="left">除非明确停止，否则会一直运行。</td>
</tr>
<tr>
<td></td>
<td align="left">编程语言</td>
<td align="left">JavaScript、Python、Java、Go等有限的语言</td>
<td align="left">任何语言</td>
</tr>
<tr>
<td></td>
<td align="left">程序状态</td>
<td align="left">保存在存储（无状态）</td>
<td align="left">任何地方（有状态或无状态）</td>
</tr>
<tr>
<td></td>
<td align="left">最大内存大小</td>
<td align="left">0.125~3GiB（用户自行选择）</td>
<td align="left">0.5~1952GiB（用户自行选择）</td>
</tr>
<tr>
<td></td>
<td align="left">最大本地存储</td>
<td align="left">0.5GiB</td>
<td align="left">0~3600 GiB （用户自行选择）</td>
</tr>
<tr>
<td></td>
<td align="left">最长运行时间</td>
<td align="left">900秒</td>
<td align="left">随意</td>
</tr>
<tr>
<td></td>
<td align="left">最小计费单元</td>
<td align="left">0.1秒</td>
<td align="left">60秒</td>
</tr>
<tr>
<td></td>
<td align="left">每计费单元价格</td>
<td align="left">$0.0000002</td>
<td align="left">$0.0000867 - $0.4080000</td>
</tr>
<tr>
<td></td>
<td align="left">操作系统和库</td>
<td align="left">云供应商选择</td>
<td align="left">用户自行选择</td>
</tr>
<tr>
<td>系统管理员</td>
<td align="left">服务器实例</td>
<td align="left">云供应商选择</td>
<td align="left">用户自行选择</td>
</tr>
<tr>
<td></td>
<td align="left">扩展</td>
<td align="left">云供应商负责提供</td>
<td align="left">用户自己负责</td>
</tr>
<tr>
<td></td>
<td align="left">部署</td>
<td align="left">云供应商负责提供</td>
<td align="left">用户自己负责</td>
</tr>
<tr>
<td></td>
<td align="left">容错</td>
<td align="left">云供应商负责提供</td>
<td align="left">用户自己负责</td>
</tr>
<tr>
<td></td>
<td align="left">监控</td>
<td align="left">云供应商负责提供</td>
<td align="left">用户自己负责</td>
</tr>
<tr>
<td></td>
<td align="left">日志</td>
<td align="left">云供应商负责提供</td>
<td align="left">用户自己负责</td>
</tr>
</tbody></table><p>转自：<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf">https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf</a></p>
<p>总的来说，Serverless 相较于 serverful，有以下三个方面的巨大改变：</p>
<ol>
<li>弱化了存储与计算之间的联系。将服务的存储以及计算分开部署以及计费，服务的存储变成独立的服务，而计算则变得无状态化，从而变得更有利于调度和缩扩容。</li>
<li>代码的执行不再需要手动分配资源，只需提供一份代码，其他的资源的调度以及分配都交由Serverless平台去完成</li>
<li>按使用量计费。 serverless按照服务的使用量进行计费，而不是像传统的serverful服务那样，按照使用的资源（ECS实例、VM的规格等）计费。</li>
</ol>
<h1>二、 Serverless和前端结合的落地场景</h1>
<p>从实用角度出发，那Serverless从前端开发工程师的角度来讲，可以让我们更专注于业务开发，一些常见的服务端问题，我们都可以交给 Serverless 来解决，比如：</p>
<ul>
<li>Serverless 不需要关心内存泄露等问题, 因为它的云函数服务是使用完即销毁</li>
<li>Serverless 不需要我们自己搭建服务端环境, 也不需要我们自己去预估流程的峰值，以及关心资源的利用率、容灾等问题，因为它自身可以根据流量快速扩所容，并按真实使用量计费</li>
<li>Serverless 有完善的配套服务, 如云数据库, 云消息队列, 云存储等, 充分利用这些服务，可以极大的扩宽我们能力边界，做我们之前没时间或者没有能力去做的事情</li>
</ul>
<p>下面是伯克利的论文中，所列举出来的关于2018年 Serverless 的具体使用场景的分布：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420363-ca0bc095-1655-4e6f-bcbe-aa40008bc59e.png#align=left&amp;display=inline&amp;height=610&amp;originHeight=610&amp;originWidth=1700&amp;size=0&amp;status=done&amp;style=none&amp;width=1700" alt="" /></p>
<h2>2.1 小程序云开发</h2>
<p>按照上图中，Serverless使用场景中，占比最高的就是Web和API 服务，这方面比较典型的开发场景就是 小程序的云开发了。</p>
<p>在传统的小程序开发流程中，我们需要前端工程师对小程序端进行开发，而后端工程师进行服务端的开发。如果开发的团队规模较小，可能还需要前端工程师去将服务端的开发也完成了，但由于小程序的后端开发其实和其他的后端应用本质上是一样的，需要关心应用的负载均衡、容灾、监控等一些运维操作，但这些知识又触及到了大部分前端工程师的知识盲点，往往需要很多时间去了解和学习，完成的产品也往往不尽人意。</p>
<p>而在基于 Serverless 的小程序云开发的模式下，就可以做到让开发者只关心业务需求的实现，由一个前端工程师参与开发，在不具备完善的运维知识的情况下，使用云开发平台将后端功能封装而成的 BaaS 就可以完成整个应用的开发。以下是微信小程序云开发所提供的几项基础能力支持：</p>
<table>
<thead>
<tr>
<th align="left">能力</th>
<th align="left">作用</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">云函数</td>
<td align="left">无需自建服务器</td>
<td align="left">在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码</td>
</tr>
<tr>
<td align="left">数据库</td>
<td align="left">无需自建数据库</td>
<td align="left">一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库</td>
</tr>
<tr>
<td align="left">存储</td>
<td align="left">无需自建存储和 CDN</td>
<td align="left">在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理</td>
</tr>
<tr>
<td align="left">云调用</td>
<td align="left">原生微信服务集成</td>
<td align="left">基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力</td>
</tr>
<tr>
<td align="left"><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/wechatpay.html">微信支付</a></td>
<td align="left">免鉴权原生使用微信支付</td>
<td align="left">免签名计算、免 access_token 使用微信支付能力</td>
</tr>
</tbody></table><p>（详情可看：<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信官方文档-小程序-云开发</a>）</p>
<p>具体实践案例：<a href="https://github.com/cloudkits/miniprogram-foodmap">miniprogram-foodmap</a></p>
<h2>2.2. 数据编排，从 BFF 到 SFF</h2>
<p>BFF对于大多数的前端工程师已经不再陌生了，它的产生主要是基于：对不同的设备可能需要使用不同的后端 API，也可能对数据格式以及数据量有不同的要求。因此BFF所做的工作通常就是将后端的数据以及接口进行编排，适配成前端所需要的数据格式，提供给前端进行使用。具体的模型如下：<br />            <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420346-a243867b-83de-45e1-b430-cc084a2c60a3.png#align=left&amp;display=inline&amp;height=419&amp;originHeight=419&amp;originWidth=628&amp;size=0&amp;status=done&amp;style=none&amp;width=628" alt="" /><br />不过虽然这种模式虽然解决了接口协调的问题，但也带来了一些新的问题：</p>
<ul>
<li>如果针对不同的设备都需要开发一个BFF应用，这无疑回面临一些重复开发的成本，</li>
<li>BFF 层通常是由善于处理高网络 I/O 的Node 应用负责的，而传统的服务端运维 Node 应用还是较重的，需要我们去购买虚拟机或者将其托管到 PaaS 平台，但基于微服务高可用的诉求，就会导致服务器资源的浪费。</li>
<li>前端之前完全不用去考虑并发的情况，只需关系页面的渲染，而在加入BFF后，高并发的压力也集中到了 BFF 上。</li>
</ul>
<p>而 Serverless 则可以帮我们很好的解决这些问题。由于 BFF 只是做无状态的数据编排，因此它天然就是适合 FaaS 这种按需分配，弹性扩容，用完即毁的模型进行替换。我们可以使用一个个函数来实现对各个接口的聚合或者裁剪，前端向 BFF 发起请求，就相当于是 FaaS 的一个 HTTP 触发器，触发一个函数的执行，由这个函数来针对具体的业务逻辑来发起请求获取数据，再对数据进行聚合以及裁剪，最后将数据返回给前端。<br />                  <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420357-7d75c80a-0417-462b-920a-c1815e765645.png#align=left&amp;display=inline&amp;height=497&amp;originHeight=497&amp;originWidth=570&amp;size=0&amp;status=done&amp;style=none&amp;width=570" alt="" /><br />这样做的好处就是一方面可以节省资源，降低成本，不用去一直维持Node服务的虚拟机的开销，另一方面，将运维的压力也从BFF转移到来FaaS 服务，前端无需关心BFF的维护以及并发等场景。此外，我们还可以在FaaS平台中去充分利用云服务提供商所提供的其他功能，从而实现服务编排，增强我们在SFF层的能力。</p>
<h1>三、 Serverless 的未来与展望</h1>
<h2>3.1  对 Serverless 的“火”保持理性</h2>
<p>虽然现在 Serverless 这一概念已经被市场上的相关利益者吹的很火，仿佛已经马上就可以对传统的开发方式进行革命，但作为普通的开发者，我们需要保持相对理性，才能更为客观的去了解一门技术。</p>
<p>首先，Serverless 是真的已经火热到家喻户晓，成为一个大家都应该去了解的技术，去拥抱的开发模式了么？<br />下面是 Google Trends 对于三个名词的搜索热度的排名，可以看到与前端强相关的两个技术名词 graphql 和 BFF 都比 Serverless 的搜索热度高出不少。<img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420351-9d8ad812-36d8-47df-956a-904514f78727.png#align=left&amp;display=inline&amp;height=1272&amp;originHeight=1272&amp;originWidth=2596&amp;size=0&amp;status=done&amp;style=none&amp;width=2596" alt="" /><br />其次，作为一个出自美国的技术，同时AWS 的 <a href="https://aws.amazon.com/lambda/">Lambda</a> 无论在技术成熟度已经服务水平都比国内走在前面的情况下，按 Google Trends 区域搜索热度划分，也很有意思：其中中国以100遥遥领先于其他国家，第二名的新加坡才17的热度。</p>
<p>因此，至少从这个数据来看，Serverless 在国内的关注度远高于国外的（当然这也与国内的实际项目发展需求有关，serverless天然的具有一定的落定场景）</p>
<h2>3.2 当前 Serverless 的局限性</h2>
<p>那 Serverless 在经过这几年的发展，为什么没有真正的火起来呢，首先就是这项技术本身所存在的一些问题，下列是伯克利的论文中列举出的 Serverless 现今仍然存在的四个不足，或者说是阻碍它快速发展的因素：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/296173/1609222420371-d265405f-9e81-42f1-8250-0c46e946f5f7.jpeg#align=left&amp;display=inline&amp;height=556&amp;originHeight=556&amp;originWidth=1382&amp;size=0&amp;status=done&amp;style=none&amp;width=1382" alt="" />而正式由于存在以上一些原因，导致复杂的企业级的业务系统无法基于现在这么简单的Faas来实现，只有一些业务场景较为简单的应用才是它现在的落地场景，而一个架构思想想要成为主流，得到快速的发展，必须要应用在企业主要流程的业务系统之中，只有这样，才能体现它在企业中所带来的巨大价值与收益。因此如何结合Serverless 的思想，落地于企业的核心业务场景中去，展现其真正价值，为企业带来降本增效的收益，并沉淀出强大的 Serverless 开发框架以及最佳实践，才能将 Serverless 推向云时代的主流架构这一宝座。</p>
<h2>3.3 Serverless 的发展展望</h2>
<p>这里直接引用伯克利对与 Serverless 计算在未来十年的发展展望以及趋势的预测：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1609222420424-9060ab13-8ea7-4cf1-b324-140a11070b65.png#align=left&amp;display=inline&amp;height=1044&amp;originHeight=1044&amp;originWidth=1746&amp;size=0&amp;status=done&amp;style=none&amp;width=1746" alt="" /><br />其中对我个人印象最为深刻的是最后一条：</p>
<blockquote>
<p>Serverless computing will become the default computing paradigm of the Cloud Era, largely replacing serverful computing and thereby bringing closure to the Client-Server Era.</p>
</blockquote>
<p>简单来说，他们认为 Serverless Computing 将会成为云时代的默认范例大面积的替换传统的云计算，并革命掉客户端-服务器端的时代。我对这个展望个人是比较认同的，因为从宏观角度来看，技术的发展必定是一个不断降低门槛的过程，抽象底层逻辑，提升开发效率的过程。而 Serverless 架构的核心思想，按照 AWS 的 CTO 的说法, Serverless 作为一个架构模式，要做的到的是：</p>
<blockquote>
<p>&quot;Everyone wants just to focus on business logic.&quot;</p>
</blockquote>
<p>而这也真符合商业发展对降本增效的诉求，因此从这个角度出发，Serverless架构的落地以及推广，未来可期。</p>
<p>参考链接</p>
<ul>
<li><a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.pdf">《Cloud Programming Simplified: A Berkeley View onServerless Computing》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77095720">Serverless For Frontend 前世今生</a></li>
<li><a href="https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/">从IaaS到FaaS—— Serverless架构的前世今生</a></li>
<li><a href="https://developer.aliyun.com/article/574222">当我们在聊Serverless时你应该知道这些</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZJBWGxkQezCIl2MFnHIsbQ">探索 Serverless 中的前端开发模式(多场景)</a></li>
<li><a href="https://martinfowler.com/articles/serverless.html">Serverless Architectures</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/35" rel="alternate"/><category term="Top"/><category term="Serverless"/><published>2023-03-02T09:42:20+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/34</id><title>五分钟，简单聊一聊React Component的发展历程</title><updated>2023-03-02T09:44:03.108153+00:00</updated><content type="html"><![CDATA[<hr />
<h3>一、 前言</h3>
<p>随着 react 最新的一个大版本中，给我们带来了 Hooks：<a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html">React v16.8: The One With Hooks</a>，从而将 Function component 的能力提高了一大截，成功的拥有了可以与 Class component 抗衡的能力。但话说回来，虽然 Hooks 看起来很美好，最近也有不少文章都讲解了Hooks这一“黑魔法”，但技术的不断演进，本身就是一个解决以往所存在问题的过程，因此我个人认为着眼于现在，回望过去，去看一看 react component 的发展之路，去看看 Class component 以及 Function component 为什么会出现以及它们出现的意义，所要解决的问题，也对于我们全面了解 react 是很有帮助的。</p>
<p>从 react component 的发展历程上来看，它主要是经历了一下三个阶段：</p>
<ol>
<li>createClass Component</li>
<li>Class Component</li>
<li>Function Component</li>
</ol>
<p>这个三个阶段也是react的组件不断走向轻量级的一个过程。其中 Class Component 完全替代了 createClass Component 成为了现在我们开发 react 组件的主流，而 Function Component 也在 Hooks 推出后磨刀霍霍，准备大干一场。下面就让我们去看看三者的具体情况吧~</p>
<blockquote>
<p>注：这篇文章整体只是对React Component的发展历程的一个概括或者说是我自己学习后的一个整理，想要详细了解，还请看看我在文章贴的那些链接。</p>
</blockquote>
<h3>二、 createClass Component</h3>
<p>说实话，createClass Component 我也没用过，因为我接触到 react 的时候已经是2017年下半年了，那时候 ES6 已经大行其道，class component 也已经完全取代了 createClass Component。但现在看来 createClass Component 的语法也很简单，并不复杂：</p>
<pre><code class="language-javascript">import React from &#x27;react&#x27;

const MyComponent = React.createClass({
  // 通过proTypes对象和getDefaultProps()方法来设置和获取props
  propTypes: {
    name: React.PropTypes.string
  },
  getDefaultProps() {
    return {

    }
  },
  // 通过getInitialState()方法返回一个包含初始值的对象
  getInitialState(){ 
        return {
            sayHello: &#x27;Hello Srtian&#x27;
        }
    }
  render() {
    return (
      &lt;p&gt;&lt;/p&gt;
    )
  }
})

export default MyComponent
</code></pre>
<p>react.createClass的语法并不复杂，它通过 createClass 来创建一个组件，并通过propTypes和getDefaultProps来获取props，通过通过getInitialState()方法返回一个包含初始值的对象，虽然从现在看来还是有点麻烦，但总体上来看代码也比较清晰，跟现在的 Class Component差别并不是太大。但 react.createClass 自从 react 15.5版本就不再为 react 官方所推介，而是想让大家的使用 class component 来代替它。而且在 react 16版本发布后，createClass 更是被废弃，当我们使用它的时候，会提示报错，也就是说，在 react 团队看来 createClass 已经完全没有存在的必要了。</p>
<p>其实 Class Component 完全替代 React.createClass 并不是说 React.createClass 有多坏，相反它还有一些 class Component 所没有的特性。它的废弃是由于ES6的出现，新增了 class 这一语法糖，让我们在 JavaScript 的开发中可以直接使用 extends 来扩展我们的对象，因此为了与标准的ES6接轨，原有的只在 react 中使用的 createClass 自然而然也成为了被抛弃的对象。但 class Component 在刚出现的时候也仍然存在的不小的争议，因为这两者还是存在一定的差别的，比如当时在Stack Overflow便出现了关于这两者的讨论，感兴趣的朋友可以去看看：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></p>
</blockquote>
<p>总的来说，除了语法上存在差异外，Class Component 和 React.createClass 的区别主要是以下两点（详情可以看看上面的回答）：</p>
<ul>
<li>React.createClass 会正确绑定 this，而 React.Component 则不行，我们需要在 constructor 里面使用 bind 或者直接使用箭头函数来绑定 this。</li>
<li>React.Component 不能使用 React mixins 特性，这一方面我们可以使用高阶组件来弥补。</li>
</ul>
<h3>三、Class Component</h3>
<p>Class Component创建的方式也很简单，就是普通的ES6的class的语法，通过extends来创建一个新的对象来创建react组件，下面是使用class Component创建一个组件的例子（由于为了给后面聊一聊hooks，所以在这里我使用了antd的例子）</p>
<pre><code class="language-javascript">class Modal extends React.Component {
  state = { visible: false }

  showModal = () =&gt; {
    this.setState({
      visible: true,
    });
  }
  handleOk = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  handleCancel = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Button type=&quot;primary&quot; onClick={this.showModal}&gt;
          Open Modal
        &lt;/Button&gt;
        &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={this.state.visible}
          onOk={this.handleOk}
          onCancel={this.handleCancel}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>上面就是antd中一个简单的 modal 组件的例子，其内部就是通过维护 visible 的状态来控制这个 modal 是否显示。我们可以看到，其中的一些方法都是使用箭头函数的方式来将 this 绑定到正确的属性。（具体为什么要这么做，不清楚的朋友可以看看下面这篇文章：）</p>
<blockquote>
<p><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></p>
</blockquote>
<p>而类似于上面的这种组件，也是近两年来我们在日常开发中使用最多的组件开发的方式。那为什么到了现在，我们又开始要强调使用 Function Component 来进行开发了呢？主要是由于 Class Component 所开发的组件仍然存在以下一些问题：</p>
<ol>
<li>this 绑定的问题：<br />
我们前面也提到了，我们在使用原本的 React.createClass 时并不需要去考虑this绑定的问题，而现在我们却要时刻注意使用bind或者箭头函数来让this正确绑定，同时也让一些新上手react的同学的上手成本有所提升。虽然这不是React的锅，但这方面的问题仍然客观存在。</li>
<li>嵌套地狱： 这种情况则多发生于需要用到Context的场景下，在这种场景下，数据是同步的，因为需要通知更新所有有引用到数据的地方，因此我们就需要通过render-props 的形式定义在Context.Consumer的children中，而使用到越多的Context 就会导致嵌套层级越多，这很容易让人看代码看的一脸懵逼。比如这样：</li>
</ol>
<pre><code class="language-javascript">&lt;FirstContext.Consumer&gt;
  {first =&gt; (
    &lt;SecondContext.Consumer&gt;
      {second =&gt; (
        &lt;ThirdContext.Consumer&gt;
          {third =&gt; (
            &lt;Component /&gt;
          )}
        &lt;/ThirdContext.Consumer&gt;
      )}
    &lt;/SecondContext.Consumer&gt;
  )}
&lt;/FirstContext.Consumer&gt;
</code></pre>
<ol start="3">
<li>Life-cycles 的问题：生命周期函数也是我们在日常开发所经常使用到的东西。虽然生命周期函数用起来很方便，但一旦组件的逻辑变得复杂起来，这些生命周期函数也会变得难以理解和维护；同时如何让这些生命周期函数与react渲染有效结合也是一个不小的问题，这往往可能会让一些刚上手的人摸不着头脑。此外使用这些生命周期函数时也可能会出现一些预料之外的事情发生（比如在某些生命周期函数中进行数据请求，而导致组件被重复渲染多次的问题等等，这些都是有可能发生的）</li>
</ol>
<blockquote>
<p>详细可以去看看知乎上的这个回答：<a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></p>
</blockquote>
<h3>四、Function Component</h3>
<p>看到这里，大家对class Component所存在的一些问题也算是有一些了解了，但为什么它还能横行如此之久，一直占据着主流的地位呢？其本质上就是因为没有竞争对手嘛，Function Component 长期没有内部状态管理机制，只能通过外部来管理状态，因此组件的可测试性非常的高，写起来也简洁明了，符合现在前端函数式的大潮流，是个好同志。但也正是因为没有状态管理机制，所以无法和Class Component相抗衡，毕竟一旦组件内部的逻辑变得复杂之后，内部的状态管理机制是必须的。</p>
<p>因此 React 团队基于 Function Component 提出 Hooks 的概念，用以解决 Function Component 的内部状态管理，同时也希望通过 Hooks 来解决 Class Component 所存在的问题。下面就是使用 Hooks 针对 antd 中的 modal 进行的改写，大家可以自行感受一下：</p>
<pre><code class="language-javascript">const Modal = () =&gt; {
  const [visible , changeVisible] = useState(false)
  return (
    &lt;div&gt;
      &lt;Button type=&quot;primary&quot; onClick={()=&gt;changeVisible(true)}&gt;open&lt;/Button&gt;
      &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={visible}
          onOk={()=&gt;changeVisible(false)}
          onCancel={()=&gt;changeVisible(false)}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>我们可以看到，基于 Function Component 与 Hooks 所编写出来的组件代码是相当简洁明了的，也直接避免了我们上面所提到的 this 指向的问题。而对于上面所提到的嵌套地狱以及 Life-cycles 的问题，Hooks也提供了 useContext 和 useEffect（这个倒还是存在一些问题） 来解决，在这里我也不详细说了，详情可以去看官方文档或者是 Dan 的博客：</p>
<blockquote>
<p><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></p>
</blockquote>
<p>好了，看到这里我想大家都以为上面 Class Component 的问题都已经得到圆满解决了，Function Component好像已经圆满了，我们只管放心的使用它就好了。但世界上哪有这么好的事情，Function Component 仍然存在着下面几个 tip 是我们在使用前要知道的：</p>
<ol>
<li>Function Component 与 Class Component 表现不同，这块不清楚的可以直接去看Dan的文章，他对这方面做了很明白的阐述：</li>
</ol>
<blockquote>
<p><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></p>
</blockquote>
<ol start="2">
<li>使用useState需要注意的是，它的执行顺序要在每次 render 时必须保持一致，不可以进判断和循环，必须写在最前面，关于这一点看视频：</li>
</ol>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></p>
</blockquote>
<ol start="3">
<li>Function Component 中，外部对与函数式组件的操作只能通过 props 来进行控制，不能通过函数式组件内部暴露方法来对组件进行操作。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://ultimatecourses.com/blog/react-create-class-versus-component">https://ultimatecourses.com/blog/react-create-class-versus-component</a></li>
<li><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></li>
<li><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></li>
<li><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></li>
<li><a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></li>
<li><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></li>
<li><a href="http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/">http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/</a></li>
<li><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/34" rel="alternate"/><category term="React"/><published>2023-03-02T09:41:37+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/33</id><title>Node.js爬虫初体验</title><updated>2023-03-02T09:44:03.223043+00:00</updated><content type="html"><![CDATA[<h3>一、准备阶段</h3>
<p>当我们需要使用Node.js进行爬虫爬取网页时，我们通常需要下载两个库request和cheerio来帮助我们队网页进行爬取：</p>
<pre><code>cnpm i request cheerio
</code></pre>
<p>其中request帮助我们对网页进行加载，而cheerio则是为服务器特别定制的，快速、灵活、实施的jQuery核心实现。有了这两个库，爬取简单的网页就没有太大的问题了。</p>
<h3>二、网页分析</h3>
<p>本次我的目标是爬取豆瓣电影Top250的第一页，因此打开浏览器对其页面结构进行了一番分析，就比如第一步电影——《肖申克的救赎》：<br />
<img src="https://images.gitee.com/uploads/images/2018/0726/154313_2415be33_1575229.png#align=left&amp;display=inline&amp;height=687&amp;originHeight=687&amp;originWidth=712&amp;status=done&amp;width=712" alt="" /></p>
<p>通过上面的页面结构，我们不难看出，每一部电影都是一个li，且li下面的class都是item,因此当我们需要爬取一部电影的数据时，可以先取得item，再对内部的数据进行获取。其次，每部电影的数据的class命名很明确，因此当我们获取数据时，直接可以根据页面的class命名进行数据获取。而根据对页面的分析，我打算爬取的数据如下：</p>
<ul>
<li>电影名称——name</li>
<li>评分——score</li>
<li>评语——quote</li>
<li>排名——ranking</li>
<li>封面地址——coverUrl</li>
</ul>
<h3>三、代码编写</h3>
<p>既然确定所要获取的数据，我们就可以着手写代码了，首先我们需要引入上面我们下载好的两个包：</p>
<pre><code class="language-javascript">const request = require(&#x27;request&#x27;)
const cheerio = require(&#x27;cheerio&#x27;)
</code></pre>
<p>然后我们要创造一个类，用以保存我们想要获取的数据：</p>
<pre><code class="language-javascript">const Movie = function() {
    this.name = &#x27;&#x27;
    this.score = 0
    this.quote = &#x27;&#x27;
    this.ranking = 0
    this.coverUrl = &#x27;&#x27;
}
</code></pre>
<p>然后我们就能根据我们在上面所创造的类以及利用cheerio来定义一个函数，来通过传入的元素对数据进行获取：</p>
<pre><code class="language-javascript">const getMovieFromDiv = (div) =&gt; {
    const movie = new Movie()
    const load = cheerio.load(div)
    const pic = load(&#x27;.pic&#x27;)
    movie.name = load(&#x27;.title&#x27;).text()
    movie.score = load(&#x27;.rating_num&#x27;).text()
    movie.quote = load(&#x27;.inq&#x27;).text()
    movie.ranking = pic.find(&#x27;em&#x27;).text()
    movie.coverUrl = pic.find(&#x27;img&#x27;).attr(&#x27;src&#x27;)
    return movie
}
</code></pre>
<p>将数据获取到了后，当然就需要将其保存了，我们可以调用Node.js的fs模块来对数据进行保存。在这里我们同样也可以定义一个函数，用以保存数据，鉴于在前端界数据通常是JSON，因此在这里就将数据保存为JSON格式：</p>
<pre><code class="language-javascript">const saveMovie = (movies) =&gt; {
    const fs = require(&#x27;fs&#x27;)
    const path = &#x27;DouBanTop25.json&#x27;
    const s = JSON.stringify(movies, null, 2)
    fs.writeFile(path, s, (error) =&gt; {
        if (error === null) {
            console.log(&#x27;保存成功&#x27;)
        } else {
            console.log(&#x27;保存文件错误&#x27;, error)
        }
    })
}
</code></pre>
<p>好了，上面两步主要为了处理数据以及保存数据。下面就是主要部分了，我们需要下载页面，并执行上面两个函数，已达到爬取网页数据并保存的目的：</p>
<pre><code class="language-javascript">const getMoviesFromUrl = (url) =&gt; {
    request(url, (error, response, body) =&gt; {
        if (error === null &amp;&amp; response.statusCode == 200) {
            const load = cheerio.load(body)
            const movieDiv = load(&#x27;.item&#x27;)
            const movies = []
            for(let i = 0; i &lt; movieDiv.length; i++) {
                let element = movieDiv[i]
                const div = load(element).html()
                const movie = getMovieFromDiv(div)
                movies.push(movie)
            }
            saveMovie(movies)
        } else {
            console.log(&#x27;请求失败&#x27;, error)
        }
    })
}
</code></pre>
<p>在上面，当我们下载好页面后，先利用cheerio.load解析页面，然后我们创建一个数组，用于保存电影的数据。再然后通for循环遍历页面的item，并通过getMovieFromDiv来对每个item内的数据进行获取，然后push到数组内。在循环结束后，使用saveMovie将存有数据的数组进行保存。</p>
<p>基本的爬取数据的代码完成了，现在让我们来启动这些函数进行页面爬取吧！</p>
<pre><code class="language-javascript">const getMovie = () =&gt;{
    const url = &#x27;https://movie.douban.com/top250&#x27;
    getMoviesFromUrl(url)
}

getMovie()
</code></pre>
<p>最后：</p>
<pre><code>node doubantop25.js
</code></pre>
]]></content><link href="https://github.com/srtian/Blog/issues/33" rel="alternate"/><category term="Node"/><published>2023-03-02T09:41:05+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/32</id><title>Jest 入门实践</title><updated>2023-03-02T09:44:03.318052+00:00</updated><content type="html"><![CDATA[<h1>一、基础</h1>
<p>前端自动化测试所带来的收益：</p>
<ul>
<li>杜绝由于各种疏忽而引起的功能Bug</li>
<li>快速反馈，例如：对于UI组件，可以让脚本代替手动点击</li>
<li>有利于多人协作</li>
</ul>
<p>前端现今主流测试框架：</p>
<ul>
<li>MOCHA：是一个功能丰富的JS测试框架，运行在Node.js和浏览器中，使异步测试变得简单有趣。</li>
<li>Jest：由FB开源的前端测试框架，也是我们公司现在所使用的测试框架。</li>
</ul>
<p>Jest前端测试框架的优点：</p>
<ul>
<li>新：前端娱乐圈了解一下</li>
<li>基础好，出身好：FB出品</li>
<li>速度快：具有单独模块测试功能</li>
<li>API简单</li>
<li>隔离性好</li>
<li>IDE配合：VSCode</li>
<li>支持多项目并行</li>
<li>快出覆盖率</li>
</ul>
<h1>二、Jest的使用实践</h1>
<h2>2.1、基础实践</h2>
<p>Jest的下载非常简单，只需要在本地由Node.js的运行环境，然后就可以使用npm包来对Jest进行下载来：</p>
<pre><code class="language-javascript">&gt; mkdir learnJest
&gt; npm init
&gt; npm install jest@24.8.0 -D
</code></pre>
<p>这里的-D就是保存到dev里边，而在线上就不使用它。</p>
<p>然后我们就可以在我们的基础目录下面新建一个叫做 <code>demo.js</code> 的文件以及一个叫做 demo.test.js的文件，然后敲些代码：<br /></p>
<pre><code class="language-javascript">// demo.js
function add(a, b){
    return a + b
}

function menus(a, b){
    return a - b
}
module.exports = {
    add,
  	menus
}

// demo.test.js
const demo = require(&quot;./demo.js&quot;);
const { add, menus } = demo;

test(&quot;测试add&quot;, () =&gt; {
  expect(add(2, 5)).toBe(7);
});
test(&quot;测试add&quot;, () =&gt; {
  expect(menus(3, 2)).toBe(1);
});
</code></pre>
<p>至此，我们就将我们的代码以及测试用例给完成了。没有使用过Jest的同学可能到这里就会要问，上面这种语法所代表的含义是什么呀？别慌，其实 <code>expect</code> 和 <code>test</code> 的内部逻辑大致是这样的：</p>
<pre><code class="language-javascript">const expect = result =&gt; {
  return {
    toBe: function(actual) {
      if (result !== actual) {
        throw new Error(`没有通过测试, 预期${actual}, 结果为${result}`)
      }
    }
  }
}

const test = (desc, fn) =&gt; {
  try {
    fn()
    console.log(`${desc} 通过测试`)
  } catch(e) {
    console.error(`${desc}没有通过测试, ${e}`)
  }
}
</code></pre>
<p>接下来，我们就可以进行测试了。那么我们如何进行测试呢，其实也很简单，我们只需要将package.json 文件。将里面的 <code>scripts</code> 标签的值改一下就行了：</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;jesttest&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;jest&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;jest&quot;: &quot;^24.8.0&quot;
  }
}
</code></pre>
<p>然后我们在终端中执行 <code>npm run test</code> 即可：</p>
<pre><code class="language-bash">&gt; npm run test

&gt; jeststydy@1.0.0 test /Users/ruotian.shen/My-Study/jestStydy
&gt; jest

 PASS  src/demo.test.js
  ✓ 测试add (2ms)
  ✓ 测试add
Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.468s
Ran all test suites.
</code></pre>
<h2>2.2、基础配置</h2>
<p>我们可以使用来生成默认的 <code>jest</code>  文件：</p>
<pre><code class="language-bash">&gt; npx jest --init
</code></pre>
<p>然后需要回答三个问题，最后就可以生成一个叫做 <code>jest.config.js</code> 的配置文件。这个配置文件里面就可以去配置一些关于 Jest 的相关东西。其中有一项 coverageDirectory 的东西，就和我们经常听到的代码测试覆盖率有关。</p>
<p>所谓的代码测试覆盖率，就是我们的测试代码，对功能性代码和业务逻辑代码作了百分多少的测试，这个百分比，就叫做代码测试覆盖率。如果我们开启了这一项：<br /></p>
<pre><code class="language-json">coverageDirectory : &quot;coverage&quot; 
</code></pre>
<p>我们就可以生成对应的覆盖率：</p>
<pre><code class="language-bash">&gt; npx jest --coverage
 PASS  src/demo.test.js
  ✓ 测试add (2ms)
  ✓ 测试add (1ms)

----------|----------|----------|----------|----------|-------------------|
File      |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |
----------|----------|----------|----------|----------|-------------------|
All files |      100 |      100 |      100 |      100 |                   |
 demo.js  |      100 |      100 |      100 |      100 |                   |
----------|----------|----------|----------|----------|-------------------|
Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.715s
Ran all test suites.
</code></pre>
<p>除了生成一个终端的报表。其中：</p>
<ul>
<li><code>% Stmts</code>  表示的是语句覆盖率，即语句的测试覆盖范围</li>
<li><code>% Branch</code> 表示的是分支覆盖率，即if代码块测试覆盖范围</li>
<li><code>% Funcs</code> 表示的是函数覆盖率，即函数的测试覆盖范围</li>
<li><code>% Lines</code> 表示的是行覆盖率，即代码行数的测试覆盖范围</li>
</ul>
<p>这条命令还能会生成一个叫做 <code>coverage</code> 的文件夹，里面有个 <code>index.html</code> 的文文件，这里就有一个花里胡哨的页面，也可以展示对应的代码覆盖率：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589962550737-d2e5f8d8-fde0-49f8-986c-281d19319a39.png#align=left&amp;display=inline&amp;height=185&amp;name=image.png&amp;originHeight=556&amp;originWidth=2774&amp;size=80207&amp;status=done&amp;style=none&amp;width=924.6666666666666" alt="image.png" /><br />此外，Jest默认支持的是 <code>CommonJS</code> 的语法，目前还不支持 <code>import form</code> 的语法，使用的时候会报错。如果我们想要使用ES6的语法，就需要使用babel来代码转成 <code>CommonJS</code> 代码。</p>
<pre><code class="language-bash">npm install @babel/core@7.4.5 @babel/preset-env@7.4.5 -D
</code></pre>
<p>然后我们新建一个 <code>babelrc</code> 的文件：</p>
<pre><code class="language-json">{
    &quot;presets&quot;:[
        [
                &quot;@babel/preset-env&quot;,{
                &quot;targets&quot;:{
                    &quot;node&quot;:&quot;current&quot;
                }
            }
        ]
    ]
}
</code></pre>
<p>这样我们就可以愉快的使用使用ES6的语法来用Jest了。</p>
<h2>2.3、Jest的匹配器</h2>
<p>Jest匹配器在Jest中，可以说是最重要的功能之一，前面我们说的 <code>toBe()</code> 就是匹配器的一种，Jest 使用“匹配器”让你使用不同方式测试数值。</p>
<h3>1、toBe</h3>
<p>toBe()适配器，可以说是Jest中最常用的适配器，我们可以简单的将其理解为<strong>严格相等</strong>也就是我们常用的 <code>===</code> 。</p>
<pre><code class="language-bash">test(&#x27;two plus two is four&#x27;, () =&gt; {
  expect(2 + 2).toBe(4);
});
</code></pre>
<h3>2、toEqual</h3>
<p>toBe和toEqual的区别就在与，toBe是严格相等的判断，而 toEqual 则是只要内容相等即可，比如这样：</p>
<pre><code class="language-javascript">test(&#x27;测试严格相等&#x27;,()=&gt;{
    const a = {name:&#x27;srtian&#x27;}   
    expect(a).toBe({name:&#x27;srtian&#x27;})
})
test(&#x27;测试内容相等&#x27;,()=&gt;{
    const a = {name:&#x27;srtian&#x27;}   
    expect(a).toEqual({name:&#x27;srtian&#x27;})
}) 
</code></pre>
<p>然后我们执行一下test，就可以发现这两个API之间的区别：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589964776202-ad3d5e3f-22d2-4c40-8ce6-eb159d909eba.png#align=left&amp;display=inline&amp;height=354&amp;name=image.png&amp;originHeight=1062&amp;originWidth=1482&amp;size=193644&amp;status=done&amp;style=none&amp;width=494" alt="image.png" /></p>
<h3>3、Truthiness</h3>
<p>有时候，我们需要来判断匹配null、undefined、false。Jest也提供了相对应的 API 来进行匹配：</p>
<ul>
<li><code>toBeNull</code> 只匹配 <code>null</code></li>
<li><code>toBeUndefined</code> 只匹配 <code>undefined</code></li>
<li><code>toBeDefined</code> 是 <code>toBeUndefined</code> 反义词</li>
<li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句当作真值的表达式</li>
<li><code>toBeFalsy</code> 匹配任何 <code>if</code> 语句当作假值的表达式</li>
</ul>
<pre><code class="language-javascript">test(&#x27;null&#x27;, () =&gt; {
  const n = null
  expect(n).toBeNull()
  expect(n).toBeDefined()
  expect(n).not.toBeUndefined()
  expect(n).not.toBeTruthy()
  expect(n).toBeFalsy()
})

test(&#x27;zero&#x27;, () =&gt; {
  const z = 0
  expect(z).not.toBeNull()
  expect(z).toBeDefined()
  expect(z).not.toBeUndefined()
  expect(z).not.toBeTruthy()
  expect(z).toBeFalsy()
})
</code></pre>
<h3>4、Number匹配</h3>
<p>Jest针对 <code>number</code> 也提供了相关的api来进行匹配：</p>
<ul>
<li>toBeGreaterThan</li>
<li>toBeLessThan</li>
<li>toBeGreaterThan</li>
<li>toBeGreaterThanOrEqual</li>
<li>toBeLessThanOrEqual</li>
<li>toBeCloseTo：这个是可以自动消除 <code>JavaScript</code>浮点精度错误的匹配器</li>
</ul>
<p>前面几个匹配器，看名字就非常直观，而最后一个匹配器 <code>toBeCloseTo</code> 是一个可以自动清除浮动 <code>JavaScript</code> 浮点精度错误的匹配器</p>
<pre><code class="language-javascript">test(&#x27;toEqual匹配器&#x27;,()=&gt;{
    const a = 0.1
    const b = 0.2
    expect(a + b).toEqual(0.3)
}) // 不会通过测试用例

test(&#x27;toBeCloseTo匹配器&#x27;,()=&gt;{
    const c = 0.1
    const d = 0.2
    expect(c + d).toBeCloseTo(0.3)
}) // 可以通过测试用例
</code></pre>
<h2>2.4、测试异步代码</h2>
<p>当我们使用Jest来测试异步代码时，Jest需要知道当前测试的代码是否已经完成，若已经完成，它就可以转移到另一个测试。</p>
<h3>1. 回调</h3>
<pre><code class="language-javascript">test(&#x27;the data is peanut butter&#x27;, done =&gt; {
  function callback(data) {
    try {
      expect(data).toBe(&#x27;peanut butter&#x27;);
      done();
    } catch (error) {
      done(error);
    }
  }

  fetchData(callback);
});
</code></pre>
<h3>2. Promise</h3>
<p>如果fetchData 不使用回调函数，而是返回一个Promise，我们可以这样测试它：</p>
<pre><code class="language-javascript">test(&#x27;the data is peanut butter&#x27;, () =&gt; {
  return fetchData().then(data =&gt; {
    expect(data).toBe(&#x27;peanut butter&#x27;);
  });
});
</code></pre>
<p>需要注意的是，我们要将 <code>Promise</code> 作为 <code>return</code> 的值。如果不这样做的话，在 <code>fetchData</code> 返回的这个 <code>Promise</code> 被 <code>resolve</code> 和 <code>then</code> 执行结束之前，测试就已经被视为完成了。</p>
<p>如果我们向匹配 <code>Promise</code>  的状态为 <code>rejected</code> ，我们可以使用 <code>catch</code>  方法来捕获对应的错误信息。需要注意的是 要确保使用 <code>expect.assertions</code> 来验证一定数量的断言被调用。否则一个 fulfilled 状态的 Promise 不会让测试失败：</p>
<pre><code class="language-javascript">test(&#x27;the fetch fails with an error&#x27;, () =&gt; {
  expect.assertions(1);
  return fetchData().catch(e =&gt; expect(e).toMatch(&#x27;error&#x27;));
});
</code></pre>
<p>我们也可以使用 expect 语句中使用 <code>resolves</code> 匹配器， <code>Jest</code> 将等待此 <code>Promise</code> 解决。如果承诺被拒绝，则测试将自动失败：</p>
<pre><code class="language-javascript">// 匹配成功
test(&#x27;the data is peanut butter&#x27;, () =&gt; {
  return expect(fetchData()).resolves.toBe(&#x27;peanut butter&#x27;);
});
// 匹配失败            
test(&#x27;the fetch fails with an error&#x27;, () =&gt; {
  return expect(fetchData()).rejects.toMatch(&#x27;error&#x27;);
});
</code></pre>
<h3>3. async await</h3>
<p>既然可以使用Promise 来进行测试，那么使用async也同理可以了，并且写起来也很直观简单：</p>
<pre><code class="language-javascript">test(&#x27;the data is peanut butter&#x27;, async () =&gt; {
  const data = await fetchData();
  expect(data).toBe(&#x27;peanut butter&#x27;);
});

test(&#x27;the fetch fails with an error&#x27;, async () =&gt; {
  expect.assertions(1);
  try {
    await fetchData();
  } catch (e) {
    expect(e).toMatch(&#x27;error&#x27;);
  }
});
</code></pre>
<p>也可以这样：</p>
<pre><code class="language-javascript">test(&#x27;the data is peanut butter&#x27;, async () =&gt; {
  await expect(fetchData()).resolves.toBe(&#x27;peanut butter&#x27;);
});

test(&#x27;the fetch fails with an error&#x27;, async () =&gt; {
  await expect(fetchData()).rejects.toThrow(&#x27;error&#x27;);
});
</code></pre>
<h2>2.5、Jest中的钩子函数</h2>
<p>Jest中也提供了4个钩子函数，来帮助我们在执行测试期间去进行一些操作：</p>
<ul>
<li>beforeAll()：运行在所有测试开始之前</li>
<li>afterAll()：运行在所有测试完成之后</li>
<li>beforeEach()：运行在每个测试开始之前</li>
<li>afterEach()：运行在每个测试完成之后</li>
</ul>
<p>具体例子：</p>
<pre><code class="language-javascript">import { add, menus } from &quot;./demo&quot;;

beforeAll(() =&gt; {
  console.log(&quot;这个会最先执行&quot;);
});

beforeEach(() =&gt; {
  console.log(&quot;这个会执行两次&quot;);
});
test(&quot;test add&quot;, () =&gt; {
  expect(add(1, 2)).toBe(3);
});
test(&quot;test menus&quot;, () =&gt; {
  expect(menus(3, 1)).toBe(2);
});

afterEach(() =&gt; {
  console.log(&quot;这个也会执行两次&quot;);
});

afterAll(() =&gt; {
  console.log(&quot;这个会最后执行&quot;);
});

</code></pre>
<p>运行 <code>npm run test</code> ，即可得到以下的结果:<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1590738307693-5d8f0642-62fe-4a21-b77c-61461b208de9.png#align=left&amp;display=inline&amp;height=313&amp;name=image.png&amp;originHeight=938&amp;originWidth=1192&amp;size=271035&amp;status=done&amp;style=none&amp;width=397.3333333333333" alt="image.png" /></p>
<h2>2.6、Jest中的Mock</h2>
]]></content><link href="https://github.com/srtian/Blog/issues/32" rel="alternate"/><category term="FE"/><published>2023-03-02T09:40:48+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/31</id><title>React Hooks 不完全踩坑实践指南</title><updated>2023-03-02T09:44:03.465658+00:00</updated><content type="html"><![CDATA[<h2>前言</h2>
<p>使用Hooks开发也有一年多了，期间踩了一些坑，也收获了一些体会，撑国庆有点时间小小的总结梳理了一下，后续有时间会一直补充。</p>
<h1>一、常用的 Hook 以及它们的一些注意事项</h1>
<h2>1.1 useState</h2>
<p>useState 就不用多说了，它的作用就在于可以让函数式组件拥有状态。在使用它的时候，需要注意的是：<strong>永远不要将可以通过计算得到的值保存为 state</strong>。包括但不限于：</p>
<ul>
<li>从 props 传递而来的值，但不能直接使用，需要通过一些计算来对数据进行处理，才能进行使用。常见的场景为：前端实现的搜索，在保持搜索值 searchValue 的同时，还维护一个搜索后的列表 searchedList 的 state。实际上这个 searchedList 是不必要的，我们实际上只需要维护 searchValue 即可。</li>
<li>从 URL、cookie、localStorage 中获取到的值，对于这些从前端存储中获取的，我们都应该是即用即取，而不是单独使用一个状态去将其维护起来。</li>
</ul>
<p>这样做的好处有：</p>
<ol>
<li><strong>保证了状态的最小化</strong>。一般情况下，状态的数量和代码的复杂程度是成正比的。当我们维护了很多的状态时，会需要注意各个状态之间的依赖关系，以及它们对于组件渲染的影响。因此，在一般情况下，保持状态的最小化，有利于我们写出易于维护的组件。</li>
<li><strong>保持唯一数据源</strong>。这一点主要对应于我们上述所说的从前端存储以及url上获取的值转化为state，从而增加中间状态。我曾自身体会过以及多次见过，前端的状态来源于 url 或者 前端存储，但没有做好状态同步，而导致这些来源值变化时，前端组件维护的状态没有更新而导致的bug。因此，正确的方式应该是，直接从数据的来源获取数据，即去即用，做到数据源以及用数据的地方的双向同步即可。</li>
</ol>
<h2>1.2 useEffect</h2>
<p>useEffect，顾名思义即执行副作用的地方。很多情况下，使用过 class 组件的同学会将其与 class 组件中的一些生命周期函数相绑定。但其实它的机制是不太一样的，class 组件的生命周期函数是按照一定的标准去顺序执行的，而 useEffect 则是每次组件 render 完后判断其 **依赖 **然后执行的。</p>
<p>对于useEffect 的依赖，有以下几点可以参考的：</p>
<ol>
<li>单个useEffect 依赖的值别过多，一般最好别超过 5 个。因为一旦过多，就表示这个useEffect有频繁调用或者预料之外调用的风险。这时，我们可以考虑对无关状态进行剔除，以及相关状态的合并，以及对单个 useEffect 进行分离，让单个 useEffect 的职责变得更小。</li>
<li>依赖项一般是一个常量数组，而不是一个变量，早创建回调时，就应该明确要依赖于哪些值了。</li>
<li>依赖值定义的变量一定是会在回调函数中用到的。</li>
<li>React 是用浅比较来对依赖项进行比较的，因此对于依赖项为数组或者对象的情况下，很容易出现bug。</li>
</ol>
<h2>1.3 useCallback 和 useMemo</h2>
<p>我自己在面试时，很喜欢问一些熟悉 react 技术栈的同学一个问题：在函数式组件中，是否需要对那些 inline 的函数都套上一层 useCallback 来提升性能？有不少同学回答的是：是，需要。</p>
<p>咋一看，因为react函数组件会在UI发生变化时重新执行一次。因此如果每次重新执行，都需要创建这些 inline 的函数，可能会对性能造成影响，因此需要用 useCallback 包上一层。但实际上，JavaScript对于创建函数式很快的（<a href="https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">官方解释</a>），相反纯粹的给一个组件套上 useCallback 只会更慢，因此 inline 函数无论如何都会创建，useCallback还需要比较依赖项的变化。</p>
<p>因此我们应该在以下一些场景下，才考虑使用 useCallback：</p>
<ul>
<li>该函数在初始化的时候需要大量的计算（这种场景极少）</li>
<li>该函数会作为props传递给子组件供子组件使用（这种情况较多）</li>
<li>该函数会作为其他 hooks 的依赖项（这种情况也较少）</li>
</ul>
<p>而 useMemo 也是用于缓存，和 useCallback 不同的是，useCallback 缓存的是函数引用，而useMemo则是缓存计算结果。通常用于：<strong>一个数据是根据其他数据计算而来的，且这个数据只有当其他数据发生变化时，发需要重新计算。</strong></p>
<p>有意思的是，useCallback其实也可以通过useMemo来进行实现，因为它们本质上都是做同一件事情：<strong>建立一个结果和数据的依赖关系，只有依赖数据发生变化，结果才会发生改变。</strong></p>
<pre><code class="language-typescript">const myUseCallback = useMemo(() =&gt; {
  // 返回一个函数作为结果
	return () =&gt; {}
}, [deps])
</code></pre>
<h2>1.4 useRef</h2>
<p>ref 是 react 中一直存在的。在class组件中，我们通常使用 createRef 来创建ref；而在函数组件中，我们则使用 useRef 来创建 ref。这会让人直观的感觉 useRef 就是 createRef 在函数组件的替代品，但其实它们还是存在差异的。useRef 的 current 像一个变量，其.current属性被初始化为传入的参数(initialValue)，返回的对象将在组件的整个生命周期内持续存在。而createRef 则会在每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。因此，当我们使用 useRef 时，通常我们是需要在<strong>多次渲染之间共享一个数据</strong>；除此之外，也可用于保存某个 DOM 节点的引用，对某个节点去进行操作。</p>
<p>至于其他需要注意的是：useRef 的内容发生变化时，它不会通知我们，且更改 current 属性也不会导致重新刷新，因为它只是一个引用而已。</p>
<h1>二、自定义 Hook</h1>
<p>自定义 hook 也是React开发中非常重要的一环。我们可以通过自定义hook来有效的提升我们代码的可复用性以及可维护性。在使用 hook 的过程中，我想大家不难发现，hook 带来的收益其实主要是在于两点：</p>
<ol>
<li>逻辑复用</li>
<li>关注分离</li>
</ol>
<p>而自定义hook，其实也主要是集中于这两点来进行扩展开发的，其使用场景大体上也主要是以下两种场景：</p>
<ol>
<li>封装通用逻辑</li>
<li>对复杂组件进行拆分</li>
</ol>
<h2>2.1 封装通用逻辑</h2>
<p>对通用逻辑进行封装，是自定义 hook 中非常常见的一种使用场景。譬如说，我们以往在 class 组件中经常使用 componentDidUpdate 来实现组件更新是才需要触发的一些逻辑。然而在函数组件中，我们并不能直接使用 useEffect 来实现这个功能，因为 useEffect 的执行时和 render 相关联的，因此在组件初次渲染时也会执行。在这种情况下，我们就可以封装一个 useDidUpdate 来实现类似于 componentDidUpdate 的功能：</p>
<pre><code class="language-typescript">const useDidUpdate = (callback: () =&gt; void, array: unknown[]) =&gt; {
  const mounted = useRef(false);
  useEffect(() =&gt; {
    if (mounted.current) {
      callback();
    } else {
      mounted.current = true;
    }
  }, [...array]);
};
</code></pre>
<p>这是从通用逻辑的角度的自定义 hook 的封装，对于一些业务逻辑，我们同样也可以进行处理。譬如说在微前端方案中，主子应用的通信也是其中重要的一环，而 BPM 中单据的审批也需要主子应用进行通信，然后进行相应的回调函数的执行。考虑到这种情况，在经过一些调研后，我当时就选用了使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CustomEvent">CustomEvent</a> 来作为我们主子应用的通信方案，用自定义 hook 便可对这种业务逻辑进行抽象，实现复用：</p>
<pre><code class="language-typescript">import { useEffect } from &#x27;react&#x27;;

type Options = boolean | AddEventListenerOptions;

interface CustomEventParams&lt;T&gt; {
  key: string;
  callback?: (e: CustomEvent&lt;T&gt;) =&gt; void;
  options?: Options;
}
/**
 * @param key - 一个表示 event 名字的字符串
 * @return callback: (data) =&gt; void
 */
export const useEmitter = &lt;T&gt;(key: string) =&gt; {
  const callback = (data: T) =&gt; {
    const event = new CustomEvent(key, { detail: data });
    window.dispatchEvent(event);
  };

  return callback;
};

/**
 * @param key - 一个表示 event 名字的字符串
 * @param callback - 回调函数
 * @param options - 可选参数
 * @return void
 */
export const useListener = &lt;T&gt;(
  key: string,
  callback: (e: CustomEvent&lt;T&gt;) =&gt; void,
  options: Options = {}
) =&gt; {
  useEffect(() =&gt; {
    if (typeof callback === &#x27;function&#x27;) {
      const fn = (e: Event) =&gt; {
        callback(e as CustomEvent);
      };

      window.addEventListener(key, fn, options);

      return () =&gt; window.removeEventListener(key, fn, options);
    }
  }, [key, callback, options]);
};
/**
 * @param key - 一个表示 event 名字的字符串
 * @param callback - 回调函数
 * @param options - 可选参数
 * @return useEmitter:（key: string）=&gt; callback
 */
export const useCustomEvent = &lt;T&gt;({ key, callback, options = {} }: CustomEventParams&lt;T&gt;) =&gt; {
  let fn;
  if (typeof callback === &#x27;function&#x27;) {
    fn = callback;
  } else {
    fn = () =&gt; console.log(&#x27;no function&#x27;);
  }
  useListener&lt;T&gt;(key, fn, options);

  return useEmitter&lt;T&gt;(key);
};

</code></pre>
<p>大家看到以上主要有三个API组成：</p>
<ul>
<li>useEmitter</li>
<li>useListener</li>
<li>useCustomEvent</li>
</ul>
<p>其中，在BPM的业务场景中， useEmitter 单独使用的较少，而  useListener 则通常适用于监听业务方传递过来的相关消息，而 useCustomEvent 则主要使用于在 BPM 发出事件后，根据业务方的回传消息作出响应的场景。</p>
<h2>2.2 对复杂组件进行拆分</h2>
<p>我相信很多同学在接手一些老项目的代码时，时常会发现有些组件的代码量会超出自己的控制范围（譬如我接手的一个项目，一个组件写了7000行，里面嵌套的一个组件也有6000行）。这样的代码是非常不好维护的，因此保持每个组件的短小，是一个非常有用的最佳实践。</p>
<p>那如何做到不让单个组件变得太过于冗余呢？其实做法很简单，就是尽量将相关的逻辑做成独立的 hooks，然后在函数组件中使用这些 Hooks。其实在 Vue 中也有类似的做法， Vue 的文档对于这种代码组织的方式介绍的很清楚，在这里我也就不做过多的赘述了：<a href="https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api">why-composition-api </a>。其核心要点就在于，<strong>对单个大的组件，进行业务逻辑上的分离，将拥有共同逻辑的代码拆分为 hooks，从而降低代码的耦合程度，减少单个组件的代码量。</strong></p>
<h1>三、其他</h1>
<h2>3.1 使用 ESlint 插件监督 Hooks 的使用</h2>
<p>由于 Hooks 是通过闭包和数组组成的环形链表来实现的，因此在开发过程中，我们也需要遵循一些开发规范才行，包括：</p>
<ul>
<li>在不能在条件语句、循环、return之后使用 hooks。</li>
<li>hooks只能在函数组件以及自定义 hooks 中使用</li>
<li>useEffect的回调函数使用的变量，都必须在依赖项中进行声明</li>
</ul>
<p>这些规范虽然我们都知道，但难免有时会忘记，因此我们可以通过 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 来检查我们 hooks的使用情况，在下载完这个插件后，直接在配置文件加上这两个配置即可：</p>
<pre><code class="language-typescript">    &quot;react-hooks/exhaustive-deps&quot;: &quot;warn&quot;,
    &quot;react-hooks/rules-of-hooks&quot;: &quot;error&quot;,
</code></pre>
<h2>3.2 自定义Hook注释</h2>
<p>对于自定义的 hooks，在定义完后尽量加上较为完备的注释，注释的方式也推荐使用 ts doc 的格式去进行声明，这样一方面有利于后来的开发者（也可能是你自己）可以较快的明白这个自定义hook 所要完成的目的，另一方面也可能让你自己在写这个 hooks 的时候，可以二次思考这个 hooks 的入参和返回值是否合理。譬如说，上述的 useCustomEvent：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1633781378395-322dca49-ef98-4a6c-ad42-75852dd368ab.png#clientId=uee6368bf-bbf4-4&amp;from=paste&amp;height=349&amp;id=u72866a38&amp;name=image.png&amp;originHeight=1046&amp;originWidth=2518&amp;originalType=binary&amp;ratio=1&amp;size=267673&amp;status=done&amp;style=none&amp;taskId=u776a85b4-64c1-4e3a-9eff-23691f9278d&amp;width=839.3333333333334" alt="image.png" /><br />我们只需看注释即可只要这个hooks的入参以及返回值。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/</a></li>
<li><a href="https://time.geekbang.org/column/intro/100079901">https://time.geekbang.org/column/intro/100079901</a></li>
<li><a href="https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api">https://v3.vuejs.org/guide/composition-api-introduction.html#why-composition-api</a></li>
<li><a href="https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render">https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/31" rel="alternate"/><category term="FE"/><category term="React"/><published>2023-03-02T09:40:12+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/30</id><title>七天学会Node.js——学习笔记</title><updated>2023-03-02T09:44:03.604207+00:00</updated><content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/296173/1586333536866-f558ad17-fd98-42ff-980a-8fe22828c820.svg" alt="" /></p>
<h2>一、模块</h2>
<p>Node.js模块分为三种：</p>
<ul>
<li>require</li>
<li>export</li>
<li>module</li>
</ul>
<h3>1.1、require</h3>
<p>require1函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可以使用相对路径（./）以及绝对路径（以<code>/</code>或<code>C:</code>之类的盘符开头）</p>
<pre><code class="language-javascript">// foo1至foo4中保存的是同一个模块的导出对象
var foo1 = require(&#x27;./foo&#x27;);
var foo2 = require(&#x27;./foo.js&#x27;);
var foo3 = require(&#x27;/home/user/foo&#x27;);
var foo4 = require(&#x27;/home/user/foo.js&#x27;);
</code></pre>
<h3>1.2、export</h3>
<p>export 对象是当前模块的导出对象，用于导出模块的共有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的export对象：</p>
<pre><code class="language-javascript">exports.sayhai = () =&gt; {
  console.log(&quot;hi, node&quot;);
};
console.log(1);
</code></pre>
<h3>1.3、module</h3>
<p>通过module对象可以访问当前模块的一些相关信息，但用途最多的当属替换当前模块的导出对象：</p>
<pre><code class="language-javascript">module.exports = function () {
    console.log(&#x27;Hello node!&#x27;);
};
</code></pre>
<p>以上代码，便将默认导出对象被替换为一个函数</p>
<h3>1.4、模块初始化</h3>
<p>一个模块的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象，之后，缓存起来的导出对象被重复利用</p>
<pre><code class="language-javascript">// example.js
let count = 0;

const add = () =&gt; {
  return ++count;
};

exports.add = add;

// app.js
var example1 = require(&#x27;./example&#x27;);
var example2 = require(&#x27;./example&#x27;);

console.log(example1.add());
console.log(example2.add());
console.log(example1.add());

// 输出：1 2 3
</code></pre>
<p>由输出我们可以得出example.js并没有被require初始化两次。</p>
<blockquote>
<p>具体的关于模块的记录：<a href="https://www.yuque.com/srtian/fe/agw824#TZgDs">https://www.yuque.com/srtian/fe/agw824#TZgDs</a></p>
</blockquote>
<h2>二、代码的组织和部署</h2>
<h3>2.1、模块路径解析规则</h3>
<p>上面已经知晓，require函数支持相对路径以及绝对路径，但这两种路径在模块之间建立了强耦合关系，一旦某个文件存放位置需要变更，使用该模块的其他模块的代码也需要调整。因此，require函数支持第三种路径，类似于 <code>foo/bar</code> 并依次按照下列规则解析路径，直到找到模块位置。</p>
<ol>
<li>内置模块：如果传递给require函数的是Node.js的内置模块名称，不做路径解析，直接返回内部模块的导出对象</li>
<li>node_modules目录：Node.js定义了一个特殊的 <code>node_modules</code> 目录存放模块。例如在该模块中使用<code>require(&#x27;foo/bar&#x27;)</code>方式加载模块时，则NodeJS依次尝试使用以下路径：</li>
</ol>
<pre><code class="language-javascript"> /home/user/node_modules/foo/bar
 /home/node_modules/foo/bar
 /node_modules/foo/bar
</code></pre>
<ol start="3">
<li>NODE_PATH环境变量：与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量：</li>
</ol>
<pre><code>NODE_PATH=/home/user/lib:/home/lib
</code></pre>
<p>当使用<code>require(&#x27;foo/bar&#x27;)</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p>
<pre><code>/home/user/lib/foo/bar
/home/lib/foo/bar
</code></pre>
<h3>2.2、包</h3>
<p>JS模块的基本单位是单个的JS文件，但复杂的模块往往会由多个子模块组成。为了方便管理以及使用，我们可以将多个子模块组成的大模块称之为包，并把所有子模块放在同一个目录里。</p>
<p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被称为包的导出对象：</p>
<pre><code>- /home/user/lib/
    - cat/
        head.js
        body.js
        main.js
</code></pre>
<p>上面的cat目录就定义了一个包，包括三个自模块，main作为入口模块：</p>
<pre><code class="language-javascript">var head = require(&#x27;./head&#x27;);
var body = require(&#x27;./body&#x27;);

exports.create = function (name) {
    return {
        name: name,
        head: head.create(),
        body: body.create()
    };
};
</code></pre>
<p>在其他模块中使用包的时候，就需要加载包的入口模块，使用<code>require(&#x27;/home/user/lib/cat/main&#x27;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。因此我们可以让模块的文件名为index.js，这样加载模块时可以使用模块所在目录的路径代替模块文件路径：</p>
<pre><code class="language-javascript">// 等价的：
var cat = require(&#x27;/home/user/lib/cat&#x27;);
var cat = require(&#x27;/home/user/lib/cat/index&#x27;);
</code></pre>
<p>此外我们可以使用package.json文件来指定入口模块的路径，比如这样：</p>
<pre><code>// 路径
- /home/user/lib/
    - cat/
        + doc/
        - lib/
            head.js
            body.js
            main.js
        + tests/
        package.json

// package.json
{
    &quot;name&quot;: &quot;cat&quot;,
    &quot;main&quot;: &quot;./lib/main.js&quot;
}
</code></pre>
<p>如此一来，就同样可以使用<code>require(&#x27;/home/user/lib/cat&#x27;)</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p>
<h3>2.3 NPM</h3>
<p>NPM能解决很多Node.js代码部署上的问题，使用场景如下：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的三方包到本地使用。<br /></li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br /></li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br /></li>
</ul>
<p>npm常用命令：</p>
<ul>
<li>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</li>
<li>使用npm help 可查看某条命令的详细帮助，例如npm help install。</li>
<li>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</li>
<li>使用npm update  -g可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用npm unpublish @可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h2>三、文件操作</h2>
<h3>3.1、文件拷贝</h3>
<h4>小文件拷贝</h4>
<p>对于小文件的拷贝，我们可以使用fs.readFileSync从源路径读取内容，并使用fs.writeFileSync将文件内容写入目标路径。</p>
<blockquote>
<p><code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于NodeJS执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
</blockquote>
<pre><code class="language-javascript">var fs = require(&#x27;fs&#x27;);

function copy(src, dst) {
    fs.writeFileSync(dst, fs.readFileSync(src));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));
</code></pre>
<h4>大文件拷贝</h4>
<p>对于大文件，我们就不能一次将所有文件内容都读取到内存中然后一次写入磁盘，会导致内存爆仓。因此，我们只能读一点写一点，直到完成文件拷贝：</p>
<pre><code class="language-javascript">var fs = require(&#x27;fs&#x27;);

function copy(src, dst) {
    fs.createReadStream(src).pipe(fs.createWriteStream(dst));
}

function main(argv) {
    copy(argv[0], argv[1]);
}

main(process.argv.slice(2));
</code></pre>
<p>我们使用fs.createReadStream创建一个源文件的读取数据流，并使用fs.createWriteStream创建一个目标文件的只写数据流，并且用pipi方法将两个数据流连接起来。</p>
<h3>3.2、API</h3>
<h4>Buffer（数据块）</h4>
<p><code>Buffer</code>将JS的数据处理能力从字符串扩展到了任意二进制数据</p>
<pre><code class="language-javascript">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
bin[0]; // =&gt; 0x68;
var str = bin.toString(&#x27;utf-8&#x27;); // =&gt; &quot;hello&quot;
var bin = new Buffer(&#x27;hello&#x27;, &#x27;utf-8&#x27;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;
bin[0] = 0x48; //可更改

// slice方法不会返回一个新Buffer，而更像是返回了指向原Buffer中间的某个位置的指针
var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var sub = bin.slice(2);
sub[0] = 0x65;
console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt;

// 拷贝Buffer
var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);
var dup = new Buffer(bin.length);
bin.copy(dup);
dup[0] = 0x48;
console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;
console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;
</code></pre>
<h4>Stream（数据流）</h4>
<p>当内存中无法一次装下需要处理的数据，或者一边读取一边处理更加高效时，我们就需要使用数据流。NodeJS中通过各种<code>Stream</code>来提供对数据流的操作。<code>Stream</code>基于事件机制工作，所有<code>Stream</code>的实例都继承于NodeJS提供的<a href="http://nodejs.org/api/events.html">EventEmitter</a>。</p>
<pre><code class="language-javascript">var rs = fs.createReadStream(src);
var ws = fs.createWriteStream(dst);
rs.on(&#x27;data&#x27;, function (chunk) {
    if (ws.write(chunk) === false) {
        rs.pause();
    }
});
rs.on(&#x27;end&#x27;, function () {
    ws.end();
});
// 根据drain事件来判断什么时候只写数据流已经将缓存中的数据写入目标
ws.on(&#x27;drain&#x27;, function () {
    rs.resume();
});
</code></pre>
<h4>File System（文件系统）</h4>
<p><code>fs</code>模块提供的API基本上可以分为以下三类：</p>
<ul>
<li>文件属性读写。<br />其中常用的有<code>fs.stat</code>、<code>fs.chmod</code>、<code>fs.chown</code>等等。<br /></li>
<li>文件内容读写。<br />其中常用的有<code>fs.readFile</code>、<code>fs.readdir</code>、<code>fs.writeFile</code>、<code>fs.mkdir</code>等等。<br /></li>
<li>底层文件操作。<br />其中常用的有<code>fs.open</code>、<code>fs.read</code>、<code>fs.write</code>、<code>fs.close</code>等等。</li>
</ul>
<p>基本上所有fs模块API的回调参数都有两个：</p>
<ol>
<li>第一个参数在有错误发生时等于异常对象</li>
<li>第二个参数始终用于返回API方法执行结果</li>
</ol>
<p>fs模块所有 API 都有对应的同步版本，用于无法使用异步操作，或者图标操作跟为方便的情况下使用，主要区别是：</p>
<ul>
<li>同步API除了方法名的末尾多了一个<code>Sync</code></li>
<li>异常对象与执行结果的传递方式不一样</li>
</ul>
<pre><code class="language-javascript">try {
    var data = fs.readFileSync(pathname);
    // Deal with data.
} catch (err) {
    // Deal with error.
}
</code></pre>
<h4>Path（路径）</h4>
<p>NodeJS提供了<code>path</code>内置模块来简化路径相关操作，并提升代码可读性:</p>
<pre><code class="language-javascript">var cache = {};
  function store(key, value) {
    // 将传入的路径转换为标准路径
      cache[path.normalize(key)] = value;
  }
  store(&#x27;foo/bar&#x27;, 1);
  store(&#x27;foo//baz//../bar&#x27;, 2);
  console.log(cache);  // =&gt; { &quot;foo/bar&quot;: 2 }

// 将传入的多个路径拼接为标准路径
path.join(&#x27;foo/&#x27;, &#x27;baz/&#x27;, &#x27;../bar&#x27;); // =&gt; &quot;foo/bar&quot;
// 获取扩展名
 path.extname(&#x27;foo/bar.js&#x27;); // =&gt; &quot;.js&quot;
</code></pre>
<h2>四、网络操作</h2>
<p>NodeJS内置了 <code>http</code> 模块，可以让我们实现一个简单的HTTP服务器:</p>
<pre><code class="language-javascript">const http = require(&quot;http&quot;);
http.createServer((request, response) =&gt; {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text-plain&quot; });
    response.end(&quot;Hello World
&quot;);
  }).listen(8124);
</code></pre>
<h3>API</h3>
<h4>HTTP</h4>
<p><code>http</code> 模块提供了两种使用方式：</p>
<ul>
<li>作为服务端时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应</li>
<li>作为客户端时，发起一个HTTP客户端请求，获取服务端响应</li>
</ul>
<p>HTTP请求本质上是一个数据流，由请求头和请求体组成。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数，在回调函数中，除了可以使用request对象访问请求头数据外，还能把request对象当作一个只读数据流来访问请求体数据。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/30" rel="alternate"/><category term="Notes"/><category term="Node"/><published>2023-03-02T09:39:28+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/29</id><title>TypeScript小技巧记录</title><updated>2023-03-02T09:44:03.730029+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>用了TypeScript挺久了，工具链这边显著的特点就是不少模块由于业务原因亦或者是出于其他的一些考虑，后端所传输过来的数据很复杂，因此处理起来需要小心翼翼的，稍有不慎就会出现TypeError，因此之前在团队内部有做过一个小的分享，即如何使用TS让自己的数据处理更安全。这里将之前的PPT内容写成文章，此外也去除一些与具体业务有关的东西，方便后续补充以及沉淀～（话说PPT迷之找不到了，只剩下一些截图来和思维导图了）</p>
<h4>思维导图</h4>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/296173/1589540812033-d9479ca5-0ca1-4a40-a22f-dd9934a0f7dc.svg" alt="" /></p>
<h2>1.关于keyof，小东西有大能量</h2>
<pre><code class="language-javascript">interface IDataSet {
  name: string
  id: number
  type: string
  sampleImages: {
    imagePath: &#x27;&#x27;
    list: []
    algoType: &#x27;&#x27;
  }
}

const transformData = (data: IProps) =&gt; {
    Object.keys(data).map(item =&gt; {
        if(item === &#x27;sampleImege&#x27;) {
            // ...做些小操作
        }
      // ...code
    })
}
</code></pre>
<p>上面一段代码乍一看没啥问题，但其实永远也无法执行到小操作那里去，因为  <code>sampleImages</code>  这个单词我们错误拼写成了 <code>sampleImege</code> ，而类似的拼写错误也正是我们经常容易所忽视的，因此正确的做法是使用 <code>keyof</code> ，来保护我们的粗心大意：</p>
<pre><code class="language-javascript">type dataset = keyof IDataSet

const transformData = (data: IDataSet) =&gt; {
    Object.keys(data).map((item: dataset) =&gt; {
        if(item === &#x27;sampleImage&#x27;) {
            return &#x27;haha&#x27;
        }
    })
}
</code></pre>
<p>这样就可以写代码的时候获得相关提示：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589529553178-51c76a2f-39e9-4c93-991b-94435859fa60.png#align=left&amp;display=inline&amp;height=176&amp;name=image.png&amp;originHeight=528&amp;originWidth=1738&amp;size=81204&amp;status=done&amp;style=none&amp;width=579.3333333333334" alt="image.png" /><br />（实际上在使用vscode的时候，只要打出了那个空字符串，就会提示有哪些可选的参数了，完全不用自己再去打一遍，十分方便快捷且安全）</p>
<p>同时，在获取对象的值的时候，我们也可以使用keyof来保护我们的代码，还是直接是用我们上面的 <code>IDataSet</code> 为例，这样写我们完成发现不了问题:</p>
<pre><code class="language-javascript">const getData = (data: IProps) =&gt; {
  if(data[&#x27;ids&#x27;] === 10086) {
  	...
  }
}
</code></pre>
<p>这个时候我们就可以使用 由<code>keyof</code> 所实现的 <code>get</code> 来武装我们的代码，让我们的代码变得更安全：</p>
<pre><code class="language-javascript">function get&lt;T extends object, K extends keyof T&gt;(o: T, name: K): T[K] {
  return o[name]
}
const getData = (data: IDataSet) =&gt; {
  if(get(data, &#x27;ids&#x27;)) {
    // ...code
  }
}
</code></pre>
<p>这样当我们不小心将key写错的时候，就会有相应的提示来:<img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589532010316-cd8cf056-4ba1-41ba-841f-ee50bc0c7b4b.png#align=left&amp;display=inline&amp;height=119&amp;name=image.png&amp;originHeight=358&amp;originWidth=1770&amp;size=76948&amp;status=done&amp;style=none&amp;width=590" alt="image.png" /><br />// 待续</p>
]]></content><link href="https://github.com/srtian/Blog/issues/29" rel="alternate"/><published>2023-03-02T09:38:42+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/28</id><title>TypeScript 装饰器--踩坑小日记</title><updated>2023-03-02T09:44:03.819680+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>最近在思考如何实现一个类型错误拦截的功能，意外的发现了基于装饰器实现的这个:</p>
<blockquote>
<p><a href="https://www.npmjs.com/package/reflect-metadata">https://www.npmjs.com/package/reflect-metadata</a></p>
</blockquote>
<p>加之之前实现国际化以及之前用 python的时候也使用到了装饰器，因此利用闲余时间学习了学习装饰器的一些特质以及使用技巧，越发感受到了装饰器功能的强大，写上这么一篇文章作为总结与记录，不过鉴于JS装饰器的语法介绍文章已经很多了，因此在此就不多做赘述了，只将TS中使用装饰器时需要注意的总结一下。</p>
<h1>一、何为装饰器</h1>
<p>关于装饰器模式的定义，我看到一个比较好的定义是：</p>
<blockquote>
<p><strong>Design Patterns</strong> - <strong>Decorator Pattern</strong>. <strong>Decorator pattern</strong> allows a user to add new functionality to an existing object without altering its structure</p>
</blockquote>
<p>即可以在不改变原有结构的基础上添加新功能。而这种编程方式也有一个编程范式与之相对应：面向切面编程（AOP）。AOP允许我们分离横切关注点，以此达到增加模块化程度的目标，它可以在不修改代码自身的前提下，给已有代码增加额外的行为。</p>
<p>其优点在于：装饰器和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<h1>二、在TavaScript中的实践。</h1>
<h2>2.1、TypeScript中装饰器的基本使用</h2>
<p>其实在JS中，装饰器本质上就是一个函数，他可以接受一些参数，并对这些参数进行修改，从而达到对被装饰对象进行赋能的目的。举个简单的栗子，我在下方声明了一个很简单的装饰器，其作用是打印一个字符串以及该class的constructor：</p>
<pre><code class="language-javascript">import * as React from &quot;react&quot;;
import &quot;./styles.css&quot;;
const decoratorDemo = (constructor: any) =&gt; {
  console.log(&quot;it is a demo by decorator&quot;, constructor);
};
@decoratorDemo
export default class App extends React.Component {
  render() {
    return (
      &lt;div className=&quot;App&quot;&gt;
        &lt;h1&gt;Hello CodeSandbox&lt;/h1&gt;
        &lt;h2&gt;Start editing to see some magic happen!&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

// 输出：
// it is a demo by decorator 
// function App() {}

</code></pre>
<p>在TypeScript中使用装饰器并无太多坑，但以下几点需要注意：</p>
<ul>
<li>装饰器是在被装饰的类创建好之后立即去进行修饰的，与这个类被调用了多少次无关。（比如我们上面所举出的栗子，虽然 <code>&lt;App /&gt;</code> 被调用了三次，但装饰器函数之被调用了一次）</li>
<li>允许多个装饰器同时去修饰一个类，但它会从下往上依次执行，具体也可以去看我上面所举的那个链接。</li>
</ul>
<h2>2.2、干掉Any</h2>
<p>上面我们在进行装饰器的定义时，对于 <code>constructor</code> 使用了any类型，这显然不符合我们使用TS的初衷：类型提示以及类型检查。因此我们在TS中使用装饰器，第二步要做的就是将这个 <code>any</code> 类型给干掉，代码如下：</p>
<pre><code class="language-javascript">type IConstructor = new (...args: any[]) =&gt; any;

const decoratorDemo1 = &lt;T extends IConstructor&gt;(constructor: T) =&gt; {
  return class extends constructor {
    getName() {
      console.log(this.name);
    }
    name = &quot;srtian&quot;;
  };
};

@decoratorDemo1
class Demo {
  name = &quot;Bob&quot;;
}


</code></pre>
<p>如此这般我们就可以愉快享受TS给予我们的提示了：</p>
<pre><code class="language-javascript">const decoratorDemo = &lt;T extends IConstructor&gt;(constructor: T) =&gt; {
  console.log(&quot;it is a demo by decorator&quot;, constructor);
  console.log(constructor.prototype); // -&gt; 写这里的时候就会有如下的提示了
};
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589020333962-b65c40b3-118e-422f-81e5-3d3aa845100d.png#align=left&amp;display=inline&amp;height=173&amp;name=image.png&amp;originHeight=518&amp;originWidth=1074&amp;size=68840&amp;status=done&amp;style=none&amp;width=358" alt="image.png" /></p>
<h2>2.3、解决类型检查</h2>
<p>好了，咱们现在已经解决了，定义装饰器时，所需要定义的类型。但这里还有一个问题，当我们在使用它的时候还是会报错，比如我们这样写：</p>
<pre><code class="language-javascript">const decoratorDemo1 = &lt;T extends IConstructor&gt;(constructor: T) =&gt; {
  return class extends constructor {
    getName() {
      console.log(this.name);
    }
    name = &quot;srtian&quot;;
  };
};
@decoratorDemo1
class Demo {
  name = &quot;Bob&quot;;
}
const demo = new Demo();
demo.getName() // &lt;-这里会报错，如下
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589020966210-9b7ccb28-5446-4b2b-9ce9-2120ab7e4f6b.png#align=left&amp;display=inline&amp;height=73&amp;name=image.png&amp;originHeight=218&amp;originWidth=1100&amp;size=32883&amp;status=done&amp;style=none&amp;width=366.6666666666667" alt="image.png" /><br />遇到这种问题，我们就需要使用函数柯里化来帮助我们解决这个任务：</p>
<pre><code class="language-javascript">const decoratorDemo2 = () =&gt;
  function&lt;T extends IConstructor&gt;(constructor: T) {
    console.log(&quot;decorator Demo1&quot;);
    return class extends constructor {
      getName() {
        console.log(this.name);
      }
      name = &quot;srtian&quot;;
    };
  };
const demo3 = new demo2()
 demo3.getName()
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1589021223372-876e3255-10f3-49fa-8763-66d41b02ee54.png#align=left&amp;display=inline&amp;height=71&amp;name=image.png&amp;originHeight=214&amp;originWidth=1056&amp;size=32897&amp;status=done&amp;style=none&amp;width=352" alt="image.png" /><br />这样我们就可以愉快的使用装饰器来修饰我们的类了</p>
<p>所有代码链接：</p>
<blockquote>
<p><a href="https://codesandbox.io/s/affectionate-darwin-5zmuj?file=/src/App.tsx">https://codesandbox.io/s/affectionate-darwin-5zmuj?file=/src/App.tsx</a></p>
</blockquote>
]]></content><link href="https://github.com/srtian/Blog/issues/28" rel="alternate"/><category term="TS"/><published>2023-03-02T09:38:21+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/27</id><title>Node 多进程和 cluster 原理</title><updated>2023-03-02T09:44:04.097354+00:00</updated><content type="html"><![CDATA[<h1>一、概述</h1>
<p>由于node.js 主线程是单线程的，因此当我们的 node 程序运行时，通常只启动了一个进程，只能在一个 CPU 中进行运算，无法运用服务器中的多核 CPU。这显然是对于多核CPU服务器性能的浪费，因此我们需要寻求一些解决方案，来充分利用服务器的多核CPU，从而提升我们程序的运行效率。而对于这种情况，我们通常的做法就是 多进程分发策略：即主进程接收所有的请求，通过一定的负载均衡策略分发到不同的子进程中。而这一方案，其实也有两种不同的实现方式：</p>
<ol>
<li>主进程监听一个端口，子进程不监听端口，主进程分发请求到子进程中。这样做的好处在于，通常只需要占用一个端口，通信相对简单，转发策略也更为灵活。缺点则是实现相对会比较复杂，对主进程的稳定性也有更高的要求。</li>
<li>主进程和子进程分别监听不同的端口，通过主进程分发请求到子进程。即创建一个主进程，以及若干个子进程。由主进程监听客户端连接请求，并根据特定的策略，转发给子进程。这样做的优势在于：实现相对简单，各实例相对独立，这对服务稳定性有好处。而缺点则是：增加端口的占用，且进程之间通信会比较麻烦。</li>
</ol>
<p>而node 的 cluster 模块就是第一个方案的实现。cluster 模块是对child_process 模块的进一步封装，专用于解决单进程NodeJS Web服务器无法充分利用多核CPU的问题。</p>
<p>cluster 具体使用起来很简单，node官方文档也将的非常仔细，在此也就不多做赘述了：</p>
<blockquote>
<p><a href="http://nodejs.cn/api/cluster.html#cluster_cluster">http://nodejs.cn/api/cluster.html#cluster_cluster</a></p>
</blockquote>
<p>其原理官方文档也有所提及：其工作进程是由 child_process.fork() 方法创建，因此它们可以使用 IPC 和 父进程通信，从而使其各进程交替处理连接服务。在 node 的主从模型中，master 主管监听端口，以及将对应任务分发给 worker 子进程，起着一个中枢的作用。按照我们通常的理解，如果根据使用各 worker 进程的负载情况来挑选woker来执行对应的任务，效率应该会比直接循环发放要来的高，但 node 文档中提到这种声明方式会受到操作系统的调度机制影响，使其分发变得不稳定，因此 node 也就将 循环法 作为了默认的分发策略。</p>
<blockquote>
<p>需要注意的是，node 官方文档中使用 worker 来表示主进程fork出的子进程，这其实会让不少前端开发者会将其与浏览器环境中的 worker 多线程相混淆，但他们其实不是一个东西。</p>
</blockquote>
<h1>二、线程和进程</h1>
<p>上面提到，cluster 是解决单进程的问题。但大家估计也听说过JavaScript是单线程的语言（实际上，我在面试一些候选人的时候，问到 node 的多进程实现，他们也会反问我JavaScript是单线程的，关多进程什么事情）。因此为了方便后续的讨论，我们再次还需要再说明一下，线程和进程的区别。</p>
<p>首先，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程是资源分配的基本单位，而线程是独立调度的基本单位，一个进程中可以有多个线程，它们可以共享进程资源。它们的主要区别如下：</p>
<ul>
<li>拥有资源：进程是资源分配的基本单位，而线程则不拥有资源，只能去访问其隶属于的进程的资源</li>
<li>调度：线程中是独立调度的基本单位</li>
<li>系统开销：线程的切换，只需保存和设置少许的寄存器内容，开销很小。而进程的切换，则涉及当前执行CPU环境的保存和新调度进程CPU环境的设置</li>
<li>通信方面：线程间可以通过直接读取同一进程中的数据进行通信，但是进程通信需要借助 IPC。</li>
</ul>
<h1>三、Cluster原理</h1>
<p>对于 cluster 模块，我们主要需要关注两部分的内容：</p>
<ol>
<li>cluster 是如何做到多个进程监听同一端口的</li>
<li>node 是如何实现负载均衡请求分发的</li>
</ol>
<h2>3.1、多进程监听同一端口</h2>
<p>在 cluster 模式中，存在 master 和 worker 的概念。我在上面也提到了，这个 worker 并不是我们在浏览器中的worker。在这里，master 指的是主进程，而 worker 指的是子进程。它们的创建也非常简单：<br />                       <img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618838760382-aef9b538-5d9a-4369-a03c-9c30914ef595.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=366&amp;id=u2dbe4144&amp;name=image.png&amp;originHeight=732&amp;originWidth=1070&amp;originalType=binary&amp;ratio=1&amp;size=146177&amp;status=done&amp;style=none&amp;taskId=uc17db156-8851-4a2e-8bf1-ebdca56983d&amp;width=535" alt="image.png" /><br />在上述代码中，第一次 require 的 cluster 对象就模式是一个 master。对应的源码也非常简单，本质上是通过进程环境变量设置来进程判断，这是node的主进程在进行子进程管理时的标识，当调用<code>cluster.fork()</code> 时，会生成一个子进程时会以一个自增ID的形式生成这个环境变量。如果没有设置就是 master 进程，反之即为 worker：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618838731846-8471dae5-7759-445e-838f-602b37f1d7d6.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=258&amp;id=u42e5a9bb&amp;name=image.png&amp;originHeight=516&amp;originWidth=1598&amp;originalType=binary&amp;ratio=1&amp;size=125649&amp;status=done&amp;style=none&amp;taskId=u3dd6f8a3-a633-4440-be32-7e00e2d7ad4&amp;width=799" alt="image.png" /><br /><a href="https://github.com/nodejs/node/blob/master/lib/cluster.js">                             https://github.com/nodejs/node/blob/master/lib/cluster.js</a><br />因此我们第一次调用 cluster 模块就是 master 进程，后续的则都为 worker。另外主进程和子进程 require 文件也不同：</p>
<ul>
<li>主进程：internal/cluster/primary</li>
<li>子进程：internal/cluster/child</li>
</ul>
<h3>主进程模块</h3>
<p>先让我们来瞅瞅 master 进程的创建过程，由于代码其实还挺多，因此就不全部粘贴出来了，可自行去浏览：</p>
<blockquote>
<p><a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/primary.js">https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/primary.js</a></p>
</blockquote>
<p>可以看到，当我们执行 <code>cluster.fork</code> 时，一开始会调用 <code>setupPrimary</code> 方法，创建主进程。因为这个方法是通过 <code>cluster.fork</code> 调用，因此会调用多次，但该模块有个全局变量 <code>initialized</code> 用于区分是否为首次创建，如果是首次则进行创建，如果不是则跳过。代码如下：<br />               <img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618838827871-b8222a8e-ebe8-4fc2-a0da-20e421a77d9e.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=258&amp;id=u861d27c6&amp;name=image.png&amp;originHeight=516&amp;originWidth=1296&amp;originalType=binary&amp;ratio=1&amp;size=107800&amp;status=done&amp;style=none&amp;taskId=u2763db2a-d6c9-4ab8-93dd-169a68089a6&amp;width=648" alt="image.png" /><br />而  <code>cluster.fork</code> 方法，其实也很简单，具体代码如下：<br />              <img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618839042529-ec225098-fd5d-4a9f-8258-aeb7b6827dd0.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=384&amp;id=ued1fad08&amp;name=image.png&amp;originHeight=768&amp;originWidth=1260&amp;originalType=binary&amp;ratio=1&amp;size=170944&amp;status=done&amp;style=none&amp;taskId=ud948b475-2948-4c62-8976-9d9842cff8c&amp;width=630" alt="image.png" /><br />首先是进程进程的初始化，也就是创建 master。然后就是进行id的递增，再创建 worker 子进程。而在 <code>createWorkerProcess</code> 方法中，实际是使用 <code>child_process</code> 来创建子进程的。</p>
<p>需要注意的是，在初始化代码时，我们调用了两次 <code>cluster.fork</code> 方法，因此会创建两个子进程，在创建后又会调用我们项目根目录下的 <code>cluster.js</code> 启动一个新实例，但此时 <code>cluster.isMaster</code> 为 false，因此会 <code>reuqire</code>到子进程的方法。</p>
<p>且由于是 worker 进程，因此代码会<code>require(&#x27;./app.js&#x27;)</code>模块，在该模块中会监听具体的端口：<br />                   <img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618841656732-a347e092-9c55-4b61-bbd3-25f6cf3d3c64.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=294&amp;id=u83915fcc&amp;name=image.png&amp;originHeight=588&amp;originWidth=1210&amp;originalType=binary&amp;ratio=1&amp;size=124836&amp;status=done&amp;style=none&amp;taskId=u0fc9ae2c-ceba-495b-8ace-0c9090b1a57&amp;width=605" alt="image.png" /><br />这里的 <code>server.listen</code> 会调用 <code>net</code> 模块中的 <code>listenInCluster</code> 方法，该方法中有一个关键信息：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618841835848-d3623e88-8076-4d1f-a922-e88f2fb5547f.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=492&amp;id=ue6c3029b&amp;name=image.png&amp;originHeight=984&amp;originWidth=1582&amp;originalType=binary&amp;ratio=1&amp;size=215723&amp;status=done&amp;style=none&amp;taskId=uc5febabc-b6a5-4975-bbe6-b198610034e&amp;width=791" alt="image.png" /><br />上面代码中，首先判断是否为<strong>主进程</strong>，如果是就是<strong>真实的监听端口启动服务</strong>，而如果非主进程则调用 <code>internal/cluster/child</code>  中的<code>cluster._getServer</code>方法。</p>
<p>然后就会通过一个<code>send</code>方法，如果监听到 <code>listening</code> 就发送一个 <code>messgae</code> 给主线程，而主线程同样的也有一个 <code>listening</code> 时间，监听到该事件后将子进程通过 <code>EventEmitter</code> 绑定到主进程上，这样就完成了主子进程的关联绑定，并且只监听了一个端口。而主子进程之间的通信方式，就是我们常说的 IPC 通信。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618842084917-26fa359d-d461-42b7-8faf-2417927ece06.png#clientId=u7f471342-e022-4&amp;from=paste&amp;height=312&amp;id=u6b17498a&amp;name=image.png&amp;originHeight=624&amp;originWidth=1396&amp;originalType=binary&amp;ratio=1&amp;size=147078&amp;status=done&amp;style=none&amp;taskId=u3d390777-fb40-4b14-8485-12d438cfaa2&amp;width=698" alt="image.png" /></p>
<p>总结起来如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1618924368949-8d5487aa-39b8-4644-821d-3e0e1cb86ad5.png#clientId=u00e4b072-6445-4&amp;from=paste&amp;height=1670&amp;id=ueff375cb&amp;name=image.png&amp;originHeight=1670&amp;originWidth=1460&amp;originalType=binary&amp;ratio=1&amp;size=197021&amp;status=done&amp;style=none&amp;taskId=u463a2351-8add-4733-86d3-db952c1de12&amp;width=1460" alt="image.png" /><br />（图转自：<a href="https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md">https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md</a>）</p>
<h2>3.2、负载均衡原理</h2>
<p>cluster 模块进行负载均衡处理，主要涉及两个模块：</p>
<ul>
<li>round robin handle.js  此模块是针对于非 Windows 平台应用的模式，主要的做法是轮询处理，也就是轮询调度分发给空闲的子进程，处理完成后回到 worker 空闲池中。需要注意的是如果已经完成绑定了子进程，就会复用该子进程，如果没有就会重新进行判断。</li>
<li>shared handle.js 此模块针对 Windows 平台应用的模式，通过将文件描述符、端口等信息传递给子进程，子进程通过复写掉 <code>cluster._getServer</code> 方法，从而在 <code>server.listen</code> 中保证只有主进程监听端口，主子进程通过 IPC 进程通信，其次主进程根据平台或者协议不同，应用不同模块来进行分发请求给子进程处理。</li>
</ul>
<h1>参考资料</h1>
<ol>
<li><a href="https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md">https://github.com/chyingp/nodejs-learning-guide/blob/master/%E6%A8%A1%E5%9D%97/cluster.md</a></li>
<li><a href="http://nodejs.cn/api/cluster.html">http://nodejs.cn/api/cluster.html</a></li>
<li><a href="https://www.cnblogs.com/dashnowords/p/10958457.html">https://www.cnblogs.com/dashnowords/p/10958457.html</a></li>
<li><a href="https://juejin.cn/post/6844903764093042695">https://juejin.cn/post/6844903764093042695</a></li>
</ol>
]]></content><link href="https://github.com/srtian/Blog/issues/27" rel="alternate"/><category term="Top"/><category term="Node"/><published>2023-03-02T09:36:37+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/26</id><title>《领域驱动设计》</title><updated>2023-03-02T09:44:04.228598+00:00</updated><content type="html"><![CDATA[<p>之前在接手BPM的工作时，被大佬推荐学习一下领域驱动设计，因此花了不少时间阅读了 Eric 的这本经典著作，不少章节翻了很多次，也有不少章节则选择性的放弃了（有一说一，很多模式实在不太理解），自我感觉总结起来主要有两点核心的思想：</p>
<ol>
<li>创造统一语言：领域专家和开发人员用同一语言讨论问题，术语和概念相统一。</li>
<li>模型驱动开发：模型和代码相统一，并对数据的更改进行收敛以及限制。</li>
</ol>
<p>这一过程从中收获了不少，也从中发现了现存的一些问题，在这里总结一下。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/296173/1651839623745-85bce0f1-fadb-4201-944e-4ad85d2b4d4b.jpeg#clientId=u57978bd7-8216-4&amp;from=paste&amp;id=u0d294a34&amp;originHeight=4032&amp;originWidth=3024&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ubd871e89-4c90-4dd8-8adf-b88a61ca099&amp;title=" alt="" /></p>
<h2>一、为什么我们需要领域建模</h2>
<p>对于B端产品来说，核心的难点在于如何处理隐藏在业务中的复杂度。这些复杂度一方面来自于业务本身，另一方面则是在多次需求迭代中，需要保证一些关键的“知识”不在其中丢失。而降低这些复杂度，一个非常好的方式就是建立一套业务模型，通过模型来对复杂度进行简化与精炼。而这也正是领域驱动所提倡的方法论：通过领域模型来整理领域知识，从而使用领域模型来构造更易维护的软件。<br />总的来说，通过模型来驱动代码开发有以下三个优点：</p>
<ul>
<li>通过模型可以反映代码的结构，理解了模型，也就大致了解的代码的结构。</li>
<li>以模型为基础形成团队的统一语言，方便沟通合作。</li>
<li>将模型作为精炼的知识，用于传递，降低知识的传递成本。</li>
</ul>
<h2>二、领域建模的有效步骤</h2>
<p>上面总结了一下模型给我们带来的优点，那如何有效的进行建模呢？Eric 提到了以下五点：</p>
<ol>
<li>模型与实践的绑定。</li>
<li>建立一种基于模型的统一语言。</li>
<li>开发富含丰富知识的模型。</li>
<li>精炼模型。</li>
<li>头脑风暴与试验。</li>
</ol>
<p>其中前两点，是进行模型提炼的基础，而后三点则是构成了一个提炼知识的闭环。大致关系如下：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/296173/1651839623653-83e5a209-948d-43cc-8ef9-9b3be7df7a34.png#clientId=u57978bd7-8216-4&amp;from=paste&amp;id=u8e1a6ae9&amp;originHeight=784&amp;originWidth=1012&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ude0eea2c-2f13-4cc6-bd83-19ae2a2fd35&amp;title=" alt="" /><br />不得不说，这块最初读的还是去年，那会儿格局不够，没有体会到统一语言 &amp; 领域建模的重要性，但随着今年开发的不断深入以及迭代的不断进行，遇到了很多问题，愈发对于统一语言和领域建模带来的收益，有了更为深刻的理解。</p>
<h3>2.1 模型与实践的绑定</h3>
<p>Eric 在他的知识消化中并没有去强调模型的好坏，而更多的强调模型与软件在具体实现上的关联。这里的原因在于：知识消化所提倡的方法，本质上是一种迭代改进的试错法，最初的模型可能不够完善，但通过一次次的迭代，逐步将其优化，因此比起模型最初时候的好坏，关联模型和代码的实现要显得格外重要。 <br />另一个原因就是历史问题了。Eric 写书的时正是面向过程编程大行其道的时候，由此又可以引生出两个东西：充血模型和贫血模型。</p>
<ul>
<li>充血模型：与某个概念相关的行为与逻辑，都被封装到对应的领域对象中，这也是 DDD 中强调的富含知识的模型</li>
<li>贫血模型：对象仅仅对简单的数据进行封装，而关联关系和业务计算都散落在对象的范围之内</li>
</ul>
<p>提到这里，不由想起了前端近几年框架的一些修改，譬如 react hooks 和 Vue 的Componzition API 其实都有在逻辑聚合方面发力。<br />那么一个具体的模型又是由哪些元素组成的呢，下图是我在学习领域驱动设计时，所做的思维导图，可以参考参考：一个具体的领域模型具体会通过界限上下文划分为多个相互独立的子域，子域又由很多的实体组成。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/296173/1651839623620-8d67e17f-b7a5-4918-b827-6bf6cc29b2a2.png#clientId=u57978bd7-8216-4&amp;from=paste&amp;id=u1cd76732&amp;originHeight=1474&amp;originWidth=1766&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u989b6a4f-24d9-4982-9bf2-56cb8767cbe&amp;title=" alt="" /><br />在基于以上的方式建立起一套模型后，我们要做的就是基于我们所设计好的模型将我们的代码实现出来。需要注意的是，后续有关于模型方面的代码的变更，需要同步更新模型以及文档，反之亦然。只有做到这点，才能达到真正的模型和代码的绑定。</p>
<h3>2.2 建议一种基于模型的统一语言</h3>
<p>Eric 在他的书中在第二章用了整整一章，去阐述统一语言的重要性。所谓的统一语言，其实就是一种在项目内部，多方共同使用的语言，需要注意的是这里的多方可以包含项目中的所有成员。沟通中的共同语言其实有很多种，比如产品之间使用的用户旅程、用户画像等，也可以是研发之间的RPC、OpenAPI等黑话。不过在 DDD 中，统一语言特指的是根据领域模型构造出来的共同语言，且这种语言可为所有项目相关方进行使用。<br />但单纯基于模型构造出统一语言，会存在一些问题：因为模型其实本质上是一种数据结构，描述的是在不同业务维度下，数据将会如何改变，以及如何支撑起对应的计算与数据。而业务更为关心的是一些流程、交互、规则、所产生的价值等，这其中存在一定的 gap。因此，倘若单纯使用模型构建统一语言，会使其他各方不能很好的 get 到业务价值。<br />因此，更好的方式是，从模型的基础上，关联出一套可以准确描述业务价值的共同语言，它既能让模型在核心位置扮演关键角色，又能抹平不同角色因为自身背景而存在的代沟。<br />还有一点需要注意的是，上面我们强调了模型和代码的绑定，而在这里，我们则要做到模型与统一语言的关联。所以相对应的，当我们的代码发生变化时，模型也需要变化，所对应的统一语言应该也要随之变化。只有这样，让能更好的去描述事情，做到沟通信息无代差。</p>
<h3>2.3 开发富含丰富知识的模型</h3>
<p>在领域模型中，有个很有意思的概念——上下文过载：指领域模型中的某个对象会在多个上下文中发挥重要的作用，甚至是聚合根。<br />当出现上下文过载时，往往会发生以下一些问题</p>
<ul>
<li>对象本身会变得过于复杂，导致模型僵化，令人难以理解</li>
<li>会有潜在的性能问题</li>
</ul>
<p>因此我们将过载的上下文进行有效的分离很有必要。而对于将上下文的分离有很多的方法，其中比较常见的是增加上下文对象来对模型进行上下文隔离。<br />其实对应的不只是领域模型中的上下文过载，在很多其他的领域也存在一样的问题。<br />首先我们需要明确的是，上下文过载的根本问题在于：实体在不同的上下文中扮演的多个角色，再借由聚合关系，将不同上下文中的逻辑富集于实体中，就造成了上下文过载。<br />因此我们可以通过分离不同的上下文，增加上线对象，从而来对单个大的实体进行职责的分离。</p>
<h3>2.4 精炼模型</h3>
<p>当我们对模型进行分离时，算是有方法论对单个大的模型进行分离了。但在开发的过程中，还有一个需要注意的问题：如何组织领域逻辑和非领域逻辑，才能避免非领域逻辑对模型进行了污染？这里就不得不提及分层架构了。分层架构可以说是存在于软件开发领域的方方面面，小到组件，大到计算机网络，都有分层架构的思路在里面。它的目的也很简单，即：将不同关注点的逻辑封装到不同的层中。<br />而在领域驱动设计中，我们通常可以将系统分成四层，而依据主要是基于不同层之间需求变化的速率是不同的：</p>
<ol>
<li>展现层：人机交互</li>
<li>应用层：负责支撑具体的业务，将业务逻辑组织为软件的功能</li>
<li>领域层：核心的领域概念、信息、规则。</li>
<li>基础设施层：提供通用的技术能力</li>
</ol>
<p>当然基础设施层也不一定是必要的，我们也可以通过一些诸如：能力提供商模式来对分层进行精简。</p>
<h3>2.5 头脑风暴与试验</h3>
<p>通过以上的几个步骤，我们终于可以将模型以及统一语言，直面于业务了。那么我们怎么通过在业务中的不断锤炼，来改进我们的模型呢。<br />在讨论这个之前，我们可以先了解一种建模方式：事件建模法，它是通过事件捕获系统中信息的改变，再发掘出发这些改变的源头，然后通过这些源头发现背后参与的实体与操作，最终完成对系统的建模。那么我们如何进行事件建模呢：</p>
<ol>
<li>
通过事件表示交互。这里的难点主要有二：<ol>
<li>融入领域模型 </li>
<li>恰当的颗粒度 </li>
</ol>
</li>
</ol>
<p>对于第一点，主要的问题在于，业务关心的是用户的行为，而模型关心的是数据，这两者存在一个的 gap 。而事件就是其中的桥梁。我们可以将事件看做行为的印记。而事件发生的时间点则是事件最重要的属性。当事件发生时，就可能存在数据的变更。</p>
<ol>
<li>通过时间线划分不同事件。其实这个原则，就回答了上述难点的第二个——恰当的颗粒度 ，我们可以通过时间线来区分事件，在同一时间线发生的事件，我们可以理解为同一事件。而在不同时间线发生的，我们则可以理解为不同的事件，这样也是将颗粒度保持在一个理想的范围内的一个好的思路。</li>
</ol>
<p>事件建模法的整体流程大致有以下五步：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/296173/1651839623719-ad68ffd6-2f8f-4fde-a92f-6fefa09decdd.png#clientId=u57978bd7-8216-4&amp;from=paste&amp;id=ubc0445fa&amp;originHeight=476&amp;originWidth=2766&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u163e6d02-044f-422a-a8fc-62313499ce7&amp;title=" alt="" /><br />这里也有几个名词需要解释一下：</p>
<ul>
<li>行动者：系统的使用者。（可能是真实的用户，也可能是别的系统）</li>
<li>命令：由行动者发起的行为，它代表了某种决定，通常是事件的起因，也称为行动者发出命令</li>
<li>聚集：领域驱动设计的聚合，可以看作一组领域对象，在头脑风暴阶段泛指某些领域概念，不需要细化。</li>
<li>系统：指代不需要了解细节的三方系统</li>
<li>阅读模型：用以支撑决策的信息，通常与界面布局有关</li>
<li>策略：是对于事件的响应，通常表示不属于某些聚集的逻辑，通过策略可以触发新的命令，而由策略触发的命令，被称为系统触发命令。</li>
</ul>
<p>而通过事件建模建立起的模型，我们就可以通过不断的事件风暴以及实践，去对事件进行收敛，从而提升我们的模型。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/26" rel="alternate"/><category term="Notes"/><category term="Basis"/><category term="Top"/><published>2023-03-02T09:34:40+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/25</id><title>《白帽子讲安全》</title><updated>2023-03-02T09:44:04.388884+00:00</updated><content type="html"><![CDATA[<h1>结构：</h1>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/296173/1655191089154-1918e60a-b4f9-465e-8066-4cfc3d047347.jpeg" alt="" /></p>
<h1>一、安全世界观</h1>
<p><strong>安全问题的本质的信任的问题</strong>。</p>
<h3>安全三要素：</h3>
<ul>
<li>机密性（Confidentiality）：保护数据内容不被泄漏，加密是实现机密性要求的常见手段。</li>
<li>完整性（Integrity）：保护数据内容是完整的，没有被篡改的。常见的手段是数字签名</li>
<li>可用性（Availability）：随需所得，这一方面主要需要防御 拒绝访问攻击（DOS）</li>
</ul>
<h3>安全评估的四个阶段</h3>
<ol>
<li>资产等级划分：明确目标是什么，要保护什么。**互联网安全的核心问题，是数据安全的问题。**因此对于数据等级性质不同，确认不同等级构建对应的信任模型，很重要。</li>
<li>威胁分析：我们把可能造成危害的来源称为威胁（Threat），而把可能会出现的损失称为风险（Risk）。需要构建威胁模型，并不断对模型进行更新</li>
<li>风险分析：<strong>Risk = Probability * Damage Potential</strong></li>
<li>
确认解决方案: 一个好的安全方案应该有以下特点：<ol>
<li>能够有效解决问题</li>
<li>用户体验好</li>
<li>高性能</li>
<li>低耦合</li>
<li>易于扩展与升级</li>
</ol>
</li>
</ol>
<h3>白帽子兵法，设计安全方案的方法论：</h3>
<ol>
<li>
Secure By DefauIt原则，最为基本的原则，<ol>
<li>可归纳为白名单、黑名单的思想，更多的使用白名单，系统会更加安全。</li>
<li>最小权限原则，要求系统只授予主体必要的权限，而不要过度授权。</li>
</ol>
</li>
<li>
纵深防御原则：<ol>
<li>要在各个不同的层面，方面实施安全方案，避免出现纰漏，不同方案之间需要相互配合，构建一个整体</li>
<li>要在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。</li>
</ol>
</li>
<li>不可预测性原则：本质上就是产出一些攻击者无法预知的东西，比如 Token 的应用。</li>
</ol>
<h1>二、浏览器安全</h1>
<h2>2.1、同源策略</h2>
<p>同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也最基本的安全功能。<strong>浏览器的同源策略，限制了来自不同源的“document”或者脚本，对当前“document”读取或者设置某些属性。</strong><br />影响源的因素有：</p>
<ul>
<li>host</li>
<li>子域名</li>
<li>端口</li>
<li>协议</li>
</ul>
<p>在浏览器中，&lt;script>、<img>、&lt;iframe>、<link>等标签都可以跨域加载资源，而不受同源策略的限制。这些带“src”属性的标签每次加载时，实际上是由浏览器发起了一次GET请求。不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器限制了JavaScript的权限，使其不能读、写返回的内容。</p>
<h2>2.2、浏览器沙箱</h2>
<p>这种在网页中插入一段恶意代码，利用浏览器漏洞执行任意代码的攻击方式，在黑客圈子里被形象地称为“挂马”。<br />在Windows系统中，浏览器密切结合DEP、ASLR、SafeSEH等操作系统提供的保护技术，对抗内存攻击。与此同时，浏览器还发展出了多进程架构，从安全性上有了很大的提高。浏览器的多进程架构，将浏览器的各个功能模块分开，各个浏览器实例分开，当一个进程崩溃时，也不会影响到其他的进程。<br />Google Chrome是第一个采取多进程架构的浏览器。Google Chrome的主要进程分为：浏览器进程、渲染进程、插件进程、扩展进程。插件进程如flash、java、pdf等与浏览器进程严格隔离，因此不会互相影响。[插图]Google Chrome的架构渲染引擎由Sandbox隔离，网页代码要与浏览器内核进程通信、与操作系统通信都需要通过IPC channel，在其中会进行一些安全检查。<br />Sandbox即沙箱，计算机技术发展到今天，Sandbox已经成为泛指“<strong>资源隔离类模块</strong>”的代名词。<strong>Sandbox的设计目的一般是为了让不可信任的代码运行在一定的环境中，限制不可信任的代码访问隔离区之外的资源</strong>。如果一定要跨越Sandbox边界产生数据交换，则只能通过指定的数据通道，比如经过封装的API来完成，在这些API中会严格检查请求的合法性。</p>
<h2>2.3、恶意网址拦截</h2>
<p>目前各个浏览器的拦截恶意网址的功能都是基于“黑名单”的。<br />恶意网址拦截的工作原理很简单，一般都是浏览器周期性地从服务器端获取一份最新的恶意网址黑名单，如果用户上网时访问的网址存在于此黑名单中，浏览器就会弹出一个警告页面。<br />常见的恶意网址分为两类：一类是挂马网站，这些网站通常包含有恶意的脚本如JavaScript或Flash，通过利用浏览器的漏洞（包括一些插件、控件漏洞）执行shellcode，在用户电脑中植入木马；另一类是钓鱼网站，通过模仿知名网站的相似页面来欺骗用户。</p>
<h1>三、跨站脚本攻击（XSS）</h1>
<p>跨站脚本攻击，英文全称是Cross Site Script，本来缩写是CSS，但是为了和层叠样式表（Cascading Style Sheet, CSS）有所区别，所以在安全领域叫做“XSS”。<br />XSS攻击，通常指黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。由于XSS破坏力强大，且产生场景复杂，业内达成的共识是：针对各种不同场景产生的XSS，需要区分情景对待。</p>
<h2>3.1、XSS简介</h2>
<h3>1、反射形XSS</h3>
<p>反射型XSS只是简单地把用户输入的数据“反射”给浏览器。也就是说，黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功。反射型XSS也叫做“非持久型XSS”（Non-persistent XSS）。</p>
<h3>2、存储型XSS</h3>
<p>存储型XSS会把用户输入的数据“存储”在服务器端。这种XSS具有很强的稳定性。比如：黑客在一篇 blog 中，写下了恶意代码，就可能会造成所有看到这篇 blog 的人都收到攻击</p>
<h3>3、DOM Based XSS</h3>
<p>实际上也是反射形 XSS，但由于形成原因比较特别，因此单独划分，即：通过修改页面的 DOM 节点形成的 XSS，即称为  DOM Based XSS</p>
<h2>3.2、XSS攻击进阶</h2>
<h3>1. 初探 XSS Payload</h3>
<p>XSS攻击成功后，攻击者能够对用户当前浏览的页面植入恶意脚本，通过恶意脚本，控制用户的浏览器。这些用以完成各种具体功能的恶意脚本，被称为“XSS Payload”。XSS Payload实际上就是JavaScript脚本（还可以是Flash或其他富客户端的脚本），所以任何JavaScript脚本能实现的功能，XSSPayload都能做到。</p>
<h3>2. 强大的 XSS Payload</h3>
<ul>
<li>构造GET与POST请求</li>
<li>XSS钓鱼：对于验证码，XSS Payload可以通过读取页面内容，将验证码的图片URL发送到远程服务器上来实施——攻击者可以在远程XSS后台接收当前验证码，并将验证码的值返回给当前的XSS Payload，从而绕过验证码。</li>
<li>
识别用户浏览器<ul>
<li>攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS能够帮助攻击者快速达到收集信息的目的。</li>
<li>浏览器的扩展和插件也能被XSS Payload扫描出来。比如对于Firefox的插件和扩展，有着不同的检测方法。</li>
</ul>
</li>
<li>CSS History Hack： 其原理是利用style的visited属性——如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同</li>
<li>获取用户的真实IP地址：JavaScript本身并没有提供获取本地IP地址的能力，有没有其他办法？一般来说，XSS攻击需要借助第三方软件来完成。比如，客户端安装了Java环境（JRE），那么XSS就可以通过调用Java Applet的接口获取客户端的本地IP地址。</li>
<li>XSS Worm</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/25" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:33:51+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/24</id><title>《远见》</title><updated>2023-03-02T09:44:04.493026+00:00</updated><content type="html"><![CDATA[<p>职业生涯是长期的，可以分为三个阶段：</p>
<ol>
<li>初期，积攒燃料，补足短板</li>
<li>中期，发挥长板，合作共赢</li>
<li>后期，稳定发挥</li>
</ol>
<p>初期要做的</p>
<ol>
<li>
建立足够的可迁移技能<ol>
<li>解决问题的能力</li>
<li>说服力</li>
<li>演讲能力</li>
<li>完成任务的能力</li>
<li>吸引人才的能力（让人想要为你工作）</li>
<li>情商</li>
<li>帮助和求助的能力</li>
<li>学会如何和人进行眼神交流以及握手</li>
<li>如何搜寻信息</li>
<li>如何呼吸</li>
</ol>
</li>
<li>
有意义的经验<ol>
<li>经历不同的环境，在不同环境下锻炼不同的做事方法</li>
</ol>
</li>
<li>
持久的关系<ol>
<li>和雇主的关系</li>
<li>
人际关系<ol>
<li>我的上司</li>
<li>我的客户</li>
<li>商业伙伴</li>
<li>身边的人才</li>
<li>同类</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>我们总是会低估在未来才能兑现的好处，这种现象被称为‘时间贴现’（temporal discounting）。我们都不愿意用当前的痛苦，比如更辛苦的工作、更低的薪水、更低的声望等，来换取未来的某样东西，即使未来的好处其实更加丰厚。作为人类，我们本能地不相信未来的好处能够兑现，所以会在当前对它们打很大的折扣。”克里斯还在观察中发现了“损失厌恶”（loss aversion）的效应：“人们对后果和风险看得比好的方面更加清楚。我们的美梦很模糊，但噩梦却很清晰。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/24" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:33:03+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/23</id><title>重学前端之语义化</title><updated>2023-03-02T09:44:04.613533+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>本来很早前我就自认为对前端语义化有了一些了解，但在看完winter大大的专栏后才发现，自己对语义化的理解并不是很透彻，只存在于表面的理解而已，因此决定在学习winter老师的专栏后结合自己的一些理解，好好对其进行进行一个总结。</p>
<h3>一、语义化是什么</h3>
<p>从维基百科所得到的结果：</p>
<blockquote>
<p>The Semantic Web provides a common framework that allows data to be shared and reused across application, enterprise, and community boundaries. --Wikipedia</p>
</blockquote>
<p>Web语义化提供了一个通用框架，允许跨应用的程序，企业和社区共享和复用数据。简单来说，Web语义化是指使用恰当语义的html标签、class类名等内容，让页面具有良好的结构与含义，从而让人和机器都能快速理解网页内容。</p>
<p>我们都知道，对于Web来说，HTML就是负责联系大部分的Web资源的承载体和纽带，也就是我们常说的<strong>内容</strong>的载体。但在web刚被设计出来之初，设计者也没想到web会达到现在如此巨大的规模，因此早期的的HTML标准中所提供的元素也并不多，只有常见的h1-h6、ul、ol等标签。但随着Web的快速发展，网页的数量以及开发规模越来越大，为了能让用户在使用搜索引擎时能够更快、更精确的定位所要查询的网页，以及减少一些开发的维护余合作的成本，HTML在后面又提供了诸多的语义化标签，从而让页面有更为良好的结构，让搜索引擎可以更好的去查询定位网页，同时也使人更易于去理解网页的结构，这在团队协作开发中很重要。</p>
<h3>二、为什么要语义化</h3>
<p>既然知道了上面是语义化，也大概的知晓的语义化为我们带来的一些好处，但这些好处对于我们来说好像并不够具体。因为好像我们在平常进行开发的时候就只使用了div和span，也能写出一个完整的页面出来，简称span、div一把嗦，这也是我平时的做法（当然，现在在使用react的时候更加如此了）。我一直觉得这种做法其实挺不好的，至少挺low的，毕竟很多类似的文章都告诉我们，要做好web语义化，做好SEO。但在winter老师的专栏中又对此进行了分析：</p>
<blockquote>
<p>这样做行不行呢？毫无疑问答案是行。那这样做好不好呢？按照正确的套路，我应该说不好，但是在很多情况下，答案其实是好。
这是因为在现代互联网产品里， HTML 用于描述 “ 软件界面 ” 多过于 “ 富文本 ” ，而软件界面里的东西，实际上几乎是没有语义的。比如说，我们做了一个购物车功能，我们一定要给每个购物
车里的商品套上 ul 吗？比如说，加入购物车这个按钮，我们一定要用 Button 吗？
实际上我觉得没必要，因为这个场景里面，跟文本中的列表，以及表单中的 Button ，其实已经相差很远了，所以，我支持在任何 “ 软件界面 ” 的场景中，直接使用 div 和 span 。</p>
</blockquote>
<p>但话虽这样说，winter老师所说的前提是在软件界面的条件下如此，如果是其他的工作场景，语义类的标签就拥有其自身的优点了：</p>
<ul>
<li>增强代码可读性，有利于团队协作与维护。</li>
<li>有利于SEO</li>
<li>支持读屏软件，可以自动生成目录。</li>
<li>无CSS的情况下也容易阅读，便于用户阅读和理解</li>
</ul>
<h3>三、如何“正确”的进行语义化</h3>
<p>前面提到，语义化是好的。但winter老师在专栏中也提到了，对于语义标签来说：“用对”比“不用”好，“不用”比“用错”好。因此如何正确的使用语义标签，是我们进行web语义化的重中之重。下面是winter老师所提到的比较重要的语义标签的使用场景。</p>
<h4>3.1 作为自然语言延伸的语义类的标签</h4>
<p>所谓的作为自然语言延伸的语义类的标签，就是为自然语言和纯文本的补充，用来表达一定的结构或者消除歧义。比较常见的就是是em和strong这两者了。我们可以通过使用类似的标签来消除一些歧义，让读者与机器都能更为准确的把握我们一句话的意思。至于具体的区别可以看下面这篇文章，作者对em和strong的区别做了一个较为全面和详细的探讨：</p>
<p><a href="https://segmentfault.com/a/1190000002481725">em和strong的区别</a></p>
<h4>3.2 作为标题摘要的语义类标签</h4>
<p>此类标签的用途是用于表现文章的结构，让文章的目录结构显得更加清晰有序。在HTML里，我们通常使用h1-h6来作为最基本的标题，而当我们需要副标题的时候，我们就需要使用hgroup，以免让副标题也产生一个层级。</p>
<pre><code class="language-html">&lt;hgroup&gt;
    &lt;h1&gt;这是一个主标题&lt;/h1&gt;
    &lt;h2&gt;这是一个副标题&lt;/h2&gt;
&lt;/hgroup&gt;
</code></pre>
<p>此外在HTML5也提供了section标签，它会改变 h1-h6 的语义。section 的嵌套会使得其中的 h1-h6 下降一级。</p>
<h4>3.3 作为整体结构的语义类标签</h4>
<p>最后一个比较常见的场景就是很多浏览器所推出的“阅读模式”，以及各种非浏览器终端的出现，这让web语义化变得越来越重要。</p>
<p>而应用语义化标签来表现网页的结构，可以明确的表现出页面信息的主次关系，从而能更为精确的表现出阅读视图功能。也能让SEO更好。</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;
        &lt;nav&gt;
          ……
        &lt;/nav&gt;
    &lt;/header&gt;
    &lt;aside&gt;
        &lt;nav&gt;
        ……
        &lt;/nav&gt;
    &lt;/aside&gt;
    &lt;section&gt;……&lt;/section&gt;
    &lt;section&gt;……&lt;/section&gt;
    &lt;section&gt;……&lt;/section&gt;
    &lt;footer&gt;
        &lt;address&gt;……&lt;/address&gt;
    &lt;/footer&gt;
&lt;/body&gt;
</code></pre>
<p>上面这一块HTML就是一个语义化标签构成的body。其中 header 元素<br />代表“网页”或者“section”的页眉，通常包含h1-h6 元素或者 hgroup, 作为整个页面或者某个内容块的标题。也可以包裹一小节的目录，一个搜索框，一个nav等。需要注意的是：</p>
<ul>
<li>没有数量的限制</li>
<li>可以使“网页”或者任意“section”的头部部分</li>
</ul>
<p>至于nav元素则代表页面的导航链接区域，用于定义页面的<strong>主要导航部分</strong>。</p>
<p>aside 元素经常被包含在article元素中，作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料，标签，名词解释等。<br />在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。值得注意的是，aside 很容易被理解为侧边栏，实际上二者是包含关系，侧边栏是 aside ， aside 不一定是侧边栏。aside 和 header 中都可能出现导航（ nav 标签），二者的区别是， header 中的导航多数是到文章自己的目录，而 aside 中的导航多数是到关联页面或者是整站地图。</p>
<p>footer元素代表“网页”或任意“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果footer元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。在这里它包含了 address ，这也是个非常容易被误用的标签。 这里的address 并非像 date 一样，表示一个给机器阅读的地址，而是表示 “ 文章（作者）的联系方式 ” ， address 明确地只关联到 article 和 body 。</p>
<p>除此之外，还有 article ，article 代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。所以， article 和 body 具有相似的结构，除了它的内容，article通常也会有一个标题(通常会在header里)，一个footer页脚等。同时，一个 HTML 页面中，可能有多个 article 存在。<br />一个典型的场景是多篇新闻展示在同一个新闻专题页面中，这种类似报纸的多文章结构适合用 article 来组织。</p>
<pre><code class="language-html">&lt;article&gt;

    &lt;header&gt;
        &lt;h1&gt;web 语义化的那些事儿&lt;/h1&gt;
        &lt;p&gt;&lt;time pubdate datetime=&quot;2018-03-23&quot;&gt;2019-02-15&lt;/time&gt;&lt;/p&gt;
    &lt;/header&gt;

    &lt;p&gt;文章内容..&lt;/p&gt;

    &lt;article&gt;
        &lt;h2&gt;评论&lt;/h2&gt;
        &lt;article&gt;
            &lt;header&gt;
                &lt;h3&gt;评论者: 太平洋水军&lt;/h3&gt;
            &lt;/header&gt;
            &lt;p&gt;楼下真帅&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;header&gt;
                &lt;h3&gt;评论者: 黄海水军&lt;/h3&gt;
            &lt;/header&gt;
            &lt;p&gt;楼上长得帅&lt;/p&gt;
        &lt;/article&gt;
    &lt;/article&gt;
&lt;/article&gt;
</code></pre>
<p>参考链接：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000002481725">https://segmentfault.com/a/1190000002481725</a></li>
<li><a href="https://www.zhihu.com/question/20455165">https://www.zhihu.com/question/20455165</a></li>
<li><a href="https://time.geekbang.org/column/intro/154">https://time.geekbang.org/column/intro/154</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/23" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:32:09+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/22</id><title>重学前端之JavaScript语法</title><updated>2023-03-02T09:44:04.728569+00:00</updated><content type="html"><![CDATA[<h1>一、脚本与模块</h1>
<p>JavaScript中又两种源文件，这个区分从ES6开始：</p>
<ul>
<li>脚本</li>
<li>模块</li>
</ul>
<p>其中脚本可以由浏览器或者node环境引入执行，而模块只能由JavaScript 代码用 import 引入执行。</p>
<p>因此从概念上来讲，我们可以认为脚本是具有主动性的 JavaScript 代码段，是控制宿主完成一定任务的代码；而模块则是被动性的代码段，等待被调用的库。<br /> <br />现代的浏览器都支持使用script标签引入模块或者脚本，如果要引入模块，就必须给script标签添加 <code>type=&quot;module&quot;</code> 。</p>
<p>脚本中可以包含语句，而模块则是由三部分组成：</p>
<ul>
<li>import声明</li>
<li>export声明</li>
<li>语句</li>
</ul>
<h3>import声明</h3>
<p>import声明有两种使用方式</p>
<ul>
<li>直接import一个模块</li>
<li>使用import form</li>
</ul>
<p>直接import 一个模块，只能保证这个模块被执行，引用它的模块无法获得它的任何信息。</p>
<p>而 <code>import from</code> 则是引入模块中的一部分信息，可以将它们变成本地变量。他有三种用法：</p>
<pre><code class="language-javascript">import x from &quot;./a.js&quot; // 引入模块中导出的默认值。
import {a as x, modify} from &quot;./a.js&quot;; // 引入模块中的变量。
import * as x from &quot;./a.js&quot; // 把模块中所有的变量以类似对象属性的方式引入
// 第一种方式还可以和后两种组合使用
import d, {a as x, modify} from &quot;./a.js&quot;
import d, * as x from &quot;./a.js&quot;
</code></pre>
<p>需要注意的是使用没使用 as 的默认值永远在最前，且这里的as只是换一个名字而已，当变量被改变的时候，as所产生的值也会随着改变。</p>
<h3>export</h3>
]]></content><link href="https://github.com/srtian/Blog/issues/22" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:31:39+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/21</id><title>重学前端之JavaScript类型</title><updated>2023-03-02T09:44:04.834380+00:00</updated><content type="html"><![CDATA[<p>按照JavaScript最新标准，一共定义了7种数据类型：</p>
<ol>
<li>Undefined；</li>
<li>Null；</li>
<li>Boolean；</li>
<li>String；</li>
<li>Number；</li>
<li>Symbol；</li>
<li>Object；</li>
</ol>
<h3>一、七大数据类型</h3>
<h4>1、Undefined和Null；</h4>
<p>区别：</p>
<ul>
<li>Undefined是一个全局变量，而 null 则是一个关键字</li>
<li>在语义上来讲，null表示为：“定义了，但是为空”；而Undefined则表示任何变量在复制前都是undefined类型的。</li>
</ul>
<h4>2、Boolean</h4>
<p>只有两个值，true和false，表示逻辑上的真和假</p>
<h4>3、String</h4>
<p>String用于文本数据，最大长度为2^53-1。需要注意的是String的意义并非字符串，而是字符串的UTF16编码，因此字符串的方法都是针对UTF16编码的。</p>
<p>此外，JavaScript的字符串是永远无法变更的，一旦字符串构造出来，就不能以任何形式的方式改变字符串的内容，所以字符串具有值类型的特征。（这个和Java类似）</p>
<h4>4、Number</h4>
<p>Number对应的就是数字，大致对应数学中的有理数。JavaScript的Number类型有18437736874454810627(即 2^64-2^53+3)个值。</p>
<p>Number中有三个需要注意的值：</p>
<ul>
<li>NaN，占用了 9007199254740990，这原本是符合 IEEE 规则的数字；</li>
<li>Infinity，无穷大；</li>
<li>-Infinity，负无穷大。</li>
</ul>
<p>一段经典的代码：</p>
<pre><code class="language-javascript">console.log( 0.1 + 0.2 == 0.3);
</code></pre>
<p>其原因就是因为浮点数运算的精度问题所导致的。正确的运算方法应该是：</p>
<pre><code class="language-javascript">console.log( Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON);
</code></pre>
<h4>5. Symbol</h4>
<p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合，在 ES6 规范中，整个对象系统被用 Symbol 重塑。Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等</p>
<h4>6. Object</h4>
<p>JavaScript中，对象的定义是“属性的集合”。其中属性有分为：数据属性和访问器属性，二者都是key-value的结构，key可以是字符串和Symbol。<br />JavaScript 中的几个基本类型，都在对象类型中有一个“亲戚”。它们是：</p>
<ul>
<li>Number；</li>
<li>String；</li>
<li>Boolean；</li>
<li>Symbol。</li>
</ul>
<p>需要注意的是， 3 与 new Number(3)是完全不一样的，一个是Number类型一个是对象类型。而Number、String 和 Boolean这三个构造器也是两用的，当和new搭配时，会产生对象，当直接调用时，会进行强制类型转换。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/21" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:31:15+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/20</id><title>重学前端之JavaScript执行</title><updated>2023-03-02T09:44:04.964362+00:00</updated><content type="html"><![CDATA[<p>一个JavaScript引擎会常驻内存中，它等待着我们把JavaScript代码或者函数传递给它。</p>
<p>按照JSC引擎术语，我们把宿主发起的任务称为宏观任务，将JavaScript引擎发起的任务称为微观任务。</p>
<h2>一、宏观任务和微观任务</h2>
<p>JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，因此在 Node 术语中，也会把这个部分称为事件循环。</p>
<p>每次代码的执行过程，其实就是一个宏观任务，因此我们可以理解为：宏观任务的队列相当于事件循环。而在宏观任务中，JavaScript的Promise还会产生异步代码，而JS必须保证这些异步代码在一个宏观任务中完成，因此每个宏观任务都包含一个微观任务队列。</p>
<p>在有了宏观任务和微观任务机制，我们就可以实现 JS 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务</p>
<h3>1.1 Promise</h3>
<p>Promise的总体思想是：需要进行io,等待或者其他异步操作的函数，不反回真实结果，而是返回一个承诺，函数的调用方可以在合适的实际，选择等待这个承诺的兑现。</p>
<h3>1.2 async await</h3>
<p>async/await 是 ES2016 新加入的特性，它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise。</p>
<h2>二、闭包和执行上下文</h2>
<h3>2.1 闭包</h3>
<p>闭包的英文单词是closure,在不同领域有这不同含义：</p>
<ol>
<li>在编译原理中，它是处理语法产生式的一个步骤</li>
<li>在计算几合中，他表示的平面点集的凸多边形</li>
<li>在编程语言中，他表示一种函数</li>
</ol>
<p>闭包可以简单理解为一个绑定了执行环境的函数，和普通函数的区别是，它携带了执行的环境</p>
<blockquote>
<p>简单类比：人在外太空需要携带吸氧设备</p>
</blockquote>
<h3>2.2 执行上下文</h3>
<p>JavaScript 标准把一段代码，执行所需的所有信息定义为“执行上下文”。<br /><strong>执行上下文在ES3中包括三个部分：</strong></p>
<ul>
<li>scope：作用域</li>
<li>variable object: 变量对象，用于存储变量的对象</li>
<li>this value: this 值</li>
</ul>
<p><strong>在ES5中，改进了命名方式：</strong></p>
<ul>
<li>lexical environment：词法环境，当获取变量时使用</li>
<li>variable environment：变量环境，当声明变量时使用</li>
<li>this value：this值</li>
</ul>
<p><strong>ES2018中，this值被归入 lexical environment ，但增加了不少内容：</strong></p>
<ul>
<li>lexical environment：词法环境，当获取变量时使用</li>
<li>variable environment：变量环境，当声明变量时使用</li>
<li>code evaluation state：用于恢复代码执行位置</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码</li>
<li>Realm: 使用的基础库和内置对象实例</li>
<li>Generator：仅生成器上下文有这个实例，表示当前生成器。</li>
</ul>
<h2>三、函数的分类</h2>
<pre><code class="language-javascript">// 1.普通函数
function foo(){
    // code
}
// 2。箭头函数
const foo = () =&gt; {
    // code
}
// 3.方法：在class中定义的函数
class C {
    foo(){
        //code
    }
}
// 4.生成器函数，用function*定义的函数
function* foo(){
    // code
}
// 5. 类：用class定义的类，实际上也是函数
class Foo {
    constructor(){
        //code
    }
}
// 6，7，8 异步函数
async function foo(){
    // code
}
const foo = async () =&gt; {
    // code
}
async function foo*(){
    // code
}

</code></pre>
<p>对于普通变量来说买这些函数没有本质上的区别名都遵循“继承定义时环境”的原则，他们的一个行为差异在this关键字。</p>
<h3>3.1 this</h3>
<p>this是JavaScript的关键字，是执行上下文中很重要的一部分，同一个函数抵用方式不同，得到的this的值也不同，简单来讲就是：调用函数时使用的引用，决定函数执行时的this的值。</p>
<p>另外new也很有意思：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1585727679930-6a977fda-b932-477c-830d-3de9b39202d6.png#align=left&amp;display=inline&amp;height=226&amp;name=image.png&amp;originHeight=452&amp;originWidth=462&amp;size=39370&amp;status=done&amp;style=none&amp;width=231" alt="image.png" /></p>
<h2>四、javaScript语句</h2>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1585728933377-9b738526-3b45-4509-a9bf-1545170d305d.png#align=left&amp;display=inline&amp;height=436&amp;name=image.png&amp;originHeight=872&amp;originWidth=555&amp;size=155551&amp;status=done&amp;style=none&amp;width=277.5" alt="image.png" /></p>
<h3>4.1 普通语句</h3>
<p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中，只有表达式语句会产生 [[value]]，当然，从引擎控制的角度，这个 value 并没有什么用处</p>
<h3>4.2 语句块</h3>
<p>语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套</p>
<h3>4.3 控制性语句</h3>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1585731140634-686a89bf-e455-46a7-921e-e35bc7f0a221.png#align=left&amp;display=inline&amp;height=232&amp;name=image.png&amp;originHeight=463&amp;originWidth=840&amp;size=67554&amp;status=done&amp;style=none&amp;width=420" alt="image.png" /></p>
<h3>4.4 带标签的语句</h3>
<p>任何 JavaScript 语句是可以加标签的，在语句前加冒号即可</p>
<pre><code class="language-javascript"> firstStatement: var i = 1;
</code></pre>
]]></content><link href="https://github.com/srtian/Blog/issues/20" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:30:37+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/19</id><title>重学前端之JavaScript对象</title><updated>2023-03-02T09:44:05.068700+00:00</updated><content type="html"><![CDATA[<h2>一、基于对象的JavaScript</h2>
<p>JavaScript是一门基于对象的编程语言，其标准对基于对象的定义如下：</p>
<blockquote>
<p>语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合”</p>
</blockquote>
<p>通过下图，也可以潜窥对象之于JavaScript的重要性：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/296173/1585536244224-f652545d-6b3a-4ba1-bf41-a0bcc1c37078.svg" alt="" /></p>
<h3>1、面向对象</h3>
<h4>1.1、什么是面向对象</h4>
<p>对象其实并不是计算机领域凭空造出来的概念，而是对于人类思维模式的一种抽象，在《面向对象分析与设计》中从人类的认知角度出发，对象应该是以下事物的一种：</p>
<ul>
<li>一个可以触摸或者可以看见的东西；</li>
<li>人的智力可以理解的东西；</li>
<li>可以指导思考或行动（进行想象或施加动作）的东西</li>
</ul>
<p>有了对对象的基本定义，语言的设计者们就可以通过相应的语言特性来对对象进行描述来，其最主要的实现方式有两种：</p>
<ol>
<li>基于类的对象描述方式（典型代表Java）</li>
<li>基于原型的对象描述方式(典型代表JavaScript)</li>
</ol>
<h4>1.2、JavaScript对象特征</h4>
<p>《面向对象分析与设计》一书中对于对象特征的描述主要有以下三点：</p>
<ul>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</li>
<li>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</li>
</ul>
<p>其中第一点，对象具有唯一标识性。一般来说，各种语言的对象唯一标识性都是用内存地址来体现的， 对象具有唯一标识的内存地址，所以具有唯一的标识，JavaScript也不例外：</p>
<pre><code class="language-javascript">var o1 = { a: 1 };
var o2 = { a: 1 };
console.log(o1 == o2); // false
</code></pre>
<p>让对于对象的第二和第三哥特征，在不同语言中也会用不同的术语去描述他们，比如C++ 中的“成员变量”和“成员函数”，Java 中的属性”和“方法”。但JavaScript则和他们不同，它将状态和行为统一抽象为“属性”，这是由于在JavaScript中，函数其实也是作为一种特殊的对象存在，因此状态和行为都可以统一用属性来抽象。比如下面的代码，在javaScript中，d以及f都是属性，对于其对象o来说，并无太大区别。</p>
<pre><code class="language-javascript">var o = {
  d: 1,
  f() {
    console.log(this.d)
  }
}
</code></pre>
<p>其次在JavaScript中，对象具有高度的动态性，JavaScript赋予了使用者可以在运行时为对象动态的添加状态和行为的能力。而为了提高抽象能力，JavaScript属性又被设计为两大类，并用一组特征来描述属性：</p>
<ul>
<li>数据属性</li>
<li>访问器属性</li>
</ul>
<p><strong>数据属性</strong></p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p><strong>访问器属性</strong></p>
<ul>
<li>getter：函数或 undefined，在取属性值时被调用。</li>
<li>setter：函数或 undefined，在设置属性值时被调用。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值。VUE2.0就是利用来对象的这一特性来实现双向绑定的。当我们想要改变属性的特征，或者定义访问器属性，我们可以使用 Object.defineProperty：</p>
<pre><code class="language-javascript">var o = { a: 1 };
Object.defineProperty(o, &quot;b&quot;, {value: 2, writable: false, enumerable: false, configurable: true});
//a 和 b 都是数据属性，但特征值变化了
Object.getOwnPropertyDescriptor(o,&quot;a&quot;); // {value: 1, writable: true, enumerable: true, configurable: true}
Object.getOwnPropertyDescriptor(o,&quot;b&quot;); // {value: 2, writable: false, enumerable: false, configurable: true}
o.b = 3;
console.log(o.b); // 2
</code></pre>
<p>因此，我们可以将对象的运行时理解为一个“属性的集合”，属性以字符串或Symbol为key,以树枝属性特征值或访问器属性特征值为value。</p>
<p>因此由上我们不难看出，虽然JavaScript实现对象的方式与其他的传统的面向对象的编程语言Java等不一样，但其实本质上都满足来对象的基本特征，因此将JavaScript归类为面向对象的编程语言其实并不为过。</p>
<h3>2、基于原型实现的对象</h3>
<p>上面以及说明JavaScript是基于原型实现了自身的对象系统，那它和基于类所实现的对象系统有什么区别呢？</p>
<p>首先“基于类”，就是提倡使用一个关注和类之间关系开发模型，在这类实现中，总是先有类，再从类去实例化一个对象。而类与类之间又会形成继承，组合等关系。类又往往与语言的类型系统整合，形成一定编译时的能力。</p>
<p>而基于“原型”则更提倡程序员去关注一系列对象实例的行为，然后再去关心如何将这些对象，划分到最近使用方式相似的原型对象，而不是将他们分成类。基于原型的面向对象的系统通过复制的方式来创建新的对象，从实现上来讲，原型系统的“复制操作”有两种实现思路：</p>
<ul>
<li>并不真的去复制一个原型对象，而是使得新对象持有一个原型的引用；<br /></li>
<li>切实地复制对象，从此两个对象再无关联。<br /></li>
</ul>
<p>很明显JavaScript是基于第一种方式实现复制操作的。</p>
<h4>2.1、JavaScript原型</h4>
<p>抛开JavaScript模拟Java的那些语法，原型系统可以用两句话来总结：</p>
<ul>
<li>如果所有对象都有私有字段 [[prototype]]，就是对象的原型；</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，直到原型为空或者找到为止。</li>
</ul>
<p>这个模型并无太大的区别，到了ES6提供了三个内置函数来直接访问和操作原型：</p>
<ul>
<li>Object.create 根据指定的原型创建新对象，原型可以是 null；</li>
<li>Object.getPrototypeOf 获得一个对象的原型；</li>
<li>Object.setPrototypeOf 设置一个对象的原型。</li>
</ul>
<p>具体使用如下：</p>
<pre><code class="language-javascript">var cat = {
    say(){
        console.log(&quot;meow~&quot;);
    },
    jump(){
        console.log(&quot;jump&quot;);
    }
}
 
var tiger = Object.create(cat,  {
    say:{
        writable:true,
        configurable:true,
        enumerable:true,
        value:function(){
            console.log(&quot;roar!&quot;);
        }
    }
})
 
 
var anotherCat = Object.create(cat);
 
anotherCat.say();
 
var anotherTiger = Object.create(tiger);
 
anotherTiger.say();
</code></pre>
<h4>2.2、早期的类和原型</h4>
<p>在早期版本（ES3以及更早的版本）中，类的定义是一个私有属性[[class]]，语言标准为内置类型Number等都制定了[[class]]属性，而我们唯一能访问它的方式就是Object.prototype.toString，我们通常也是使用这个方式来判断数据类型。因此，在早期版本中，类是一个相当容的概念，仅仅是运行时的一个字符串属性。</p>
<p>在 ES5 开始，[[class]] 私有属性被 Symbol.toStringTag 代替，Object.prototype.toString 的意义从命名上不再跟 class 相关。我们甚至可以自定义 Object.prototype.toString 的行为，以下代码展示了使用 Symbol.toStringTag 来自定义 Object.prototype.toString 的行为：</p>
<pre><code class="language-javascript">var o = { [Symbol.toStringTag]: &quot;MyObject&quot; }
console.log(o + &quot;&quot;);
</code></pre>
<p>对于new，我们不能说“new 运算是针对构造器对象，而不是类”，我们也要将其理解成JavaScript的面向对象的一部分。</p>
<p>new运算接受一个构造器和一组调用参数，实际上做了几件事：</p>
<ul>
<li>以构造器的prototype属性（注意与私有[[prototype]]的区分）为原型，创建新对象；</li>
<li>将this和调用参数传给构造器，执行；</li>
<li>如果构造器返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ul>
<p>new的出现，主要是试图让函数对象在语法上和类相似，它提供了两种方式来为对象添加属性：</p>
<ol>
<li>构造器中添加属性</li>
<li>在构造器的prototype属性上添加属性</li>
</ol>
<pre><code class="language-javascript">function c1(){
    this.p1 = 1;
    this.p2 = function(){
        console.log(this.p1);
    }
} 
var o1 = new c1;
o1.p2();
 
 
 
function c2(){
}
c2.prototype.p1 = 1;
c2.prototype.p2 = function(){
    console.log(this.p1);
}
 
var o2 = new c2;
o2.p2();
</code></pre>
<p>在没有 Object.create、Object.setPrototypeOf 的早期版本中，new 运算是唯一一个可以指定 [[prototype]] 的方法。所以就有人使用这个方法来代替Object.create，比如这种Object.create的polyfill:</p>
<pre><code class="language-javascript">Object.create = function(prototype){
  var cls = function(){}
  cls.prototype = prototype
  return new cls
}
</code></pre>
<p>这段代码就是创建了一个空函数作为类，并把传入的原型挂在他的prototype上，最后创建一个它的实例，这就产生例一个以传入的第一个参数作为原型的对象。</p>
<h4>2.3、ES6的类</h4>
<p>ES6中引入了class关键字，并在标准中删除了所有[[class]]相关的私有属性描述，类的概念正式从属性升级成为了语言的基础设施。</p>
<pre><code class="language-javascript">class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
}
</code></pre>
<h3>3、JavaScript对象分类</h3>
<p>JavaScript的对象大致可以分为以下几类：</p>
<ul>
<li>宿主对象（host object）: 由JavaScript宿主环境提供对象，他们的行为完全由宿主环境提供。</li>
<li>
内置对象（built in Object): 由JavaScript语言提供的对象<ul>
<li>固有对象（Intrinsic Objects）：由标准规定，随着JavaScript运行时创建而自动创建的对象实例。</li>
<li>原生对象（Native Obejct）: 可以由对象通过Array，RegExp等内置构造器或特殊语法创建的对象</li>
<li>普通对象（Ordinary Object）:由{}语法，Obejct构造器或者Class关键字定义类创建的对象，他能够被原型继承。</li>
</ul>
</li>
</ul>
<h4>3.1、宿主对象</h4>
<p>JavaScript宿主对象会随着其运行环境的不同而不同，但前端最熟悉的当属浏览器环境中的宿主了。</p>
<p>在浏览器中，我们所熟悉的全局对象是window，而window上又有很多属性，如document。实际上，这个全局对象window上的属性，一部分来自javaScript语言本身，一部分来自浏览器环境。JavaScript标准规定了全局对象属性，w3c的各种标准中规定了window对象的其他属性。</p>
<p>宿主对象也分为固有的以及用户可创建两种，比如document.createElement就可以创建一些dom对象。宿主对象也会提供一些构造器，比如我们可以使用 new Image 来创建 img 元素。</p>
<h4>3.2、内置对象·固有对象</h4>
<p>固有对象是由标准规定的，随着JavaScript运行时创建而自动创建的对象实例。</p>
<p>固有对象在任何JS代码执行前就已经被创建出来了，他们通常扮演着基础库的角色。我们常说的类就是固有对象的一种，ECMA标准为我们提供类一份固有对象表（150+）：</p>
<blockquote>
<p><a href="https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects">https://www.ecma-international.org/ecma-262/9.0/index.html#sec-well-known-intrinsic-objects</a></p>
</blockquote>
<h4>3.3、原生对象</h4>
<p>我们吧JavaScript中，能够通过语言本身的构造器创建的对象称为原生对象。在javaScript中，提供了30多个构造器：<br /><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1585204239995-b28b5bf7-52f6-46a4-be1a-bfde1779c723.png#align=left&amp;display=inline&amp;height=188&amp;name=image.png&amp;originHeight=375&amp;originWidth=988&amp;size=99855&amp;status=done&amp;style=none&amp;width=494" alt="image.png" /><br />这些构造器创建的对象多数使用了私有字段：</p>
<ul>
<li>Error: [[ErrorData]]</li>
<li>Boolean: [[BooleanData]]</li>
<li>Number: [[NumberData]]</li>
<li>Date: [[DateValue]]</li>
<li>RegExp: [[RegExpMatcher]]</li>
<li>Symbol: [[SymbolData]]</li>
<li>Map: [[MapData]]</li>
</ul>
<p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”</p>
<h4>3.4、用对象来模拟函数与构造器：函数对象与构造器对象</h4>
<p>在 JavaScript 中，还有一个看待对象的不同视角，这就是用对象来模拟函数和构造器。JavaScript 为这一类对象预留了私有字段机制，并规定了抽象的函数对象与构造器对象的概念。</p>
<p>函数对象的定义是：具有 [[call]] 私有字段的对象，构造器对象的定义是：具有私有字段 [[construct]] 的对象。</p>
<p>JavaScript 用对象模拟函数的设计代替了一般编程语言的函数，它们可以像其他语言的函数一样被调用，传参。任何宿主只要提供了[[call]]私有字段的对象，就可以被 JavaScript 函数调用语法支持。</p>
<blockquote>
<p>[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换，这些内容，我将会在属性访问和执行过程两个章节详细讲述。</p>
</blockquote>
<p>我们可以说任何对象只要实现了[[call]]，那么他就是一个函数对象，而如果实现了[[construct]]，他就是一个构造器对象，可以作为构造器对象使用</p>
<blockquote>
<p>对于这两个方法，我们也可以对其进行设置，来定制对象的具体调用方式的限制</p>
</blockquote>
<p>对于宿主和内置对象来讲，，他们实现[[call]]和[[construct]]不总是一致的。比如内置对象 Date 在作为构造器调用时产生新的对象，作为函数调用是则产生字符串。</p>
<pre><code class="language-javascirpt">console.log(new Date); // 1
console.log(Date())
</code></pre>
<p>而浏览器宿主环境中，提供的 Image 构造七，则不允许作为函数调用。</p>
<p>需要注意的是，在 ES6 之后的箭头函数语法创建的函数仅仅只是函数，不能作为构造器使用。而对用使用 function 语法或者 Function 构造器创建的对象来讲，[[call]] 和 [[construct]] 的行为总是相似的。</p>
<p>我们可以大致认为，他们[[construct]]的执行过程如下：</p>
<ul>
<li>以 Object.prototype 为原型创建一个新对象</li>
<li>以新对象为 this, 执行函数的[[call]]</li>
<li>如果[[call]]的返回值是对象，那么就返回这个对象，否则返回第一步创建的对象。</li>
</ul>
<p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p>
<pre><code class="language-javascript">function cls(){
    this.a = 100;
    return {
        getValue:() =&gt; this.a
    }
}
var o = new cls;
o.getValue(); //100
//a 在外面永远无法访问到
</code></pre>
<p>一些特殊行为的对象：</p>
<ul>
<li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li>
<li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li>
<li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li>
<li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li>
<li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li>
<li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li>
<li>bind 后的 function：跟原来的函数相关联。</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/19" rel="alternate"/><category term="Notes"/><published>2023-03-02T09:30:02+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/18</id><title>《写给大家看的色彩书：设计配色基础》</title><updated>2023-03-02T09:44:05.192551+00:00</updated><content type="html"><![CDATA[<p>《写给大家看的色彩书：设计配色基础》国内著名由设计师梁景红编写，主要谈及配色的基础技巧和必备理念。非常适合初学配色的专业人士来学习。仔细阅读此书后，我对配色有了非常全面的认识，也巩固了之前零散的色彩知识。很希望和大家交流分享。<br />这是一本非常不错的配色入门书，从色彩最基础的知识点讲起，逐渐深入到专业的理论，层层递进。配合相应的案例，虽然大部分在讲理论，却也一点都不枯燥。</p>
<p>之前都认为，配色只是一种感觉，只要根据常识和已有的审美走就可以了。其实不然，学习了解专业的理论知识，不仅能让你在配色过程中更加有自信，而且可以举一反三，从现有的经验推导至未知的领域，如果在工作上遇到以前没有接触过的内容，也可以轻松入手。</p>
<p>本书的主要内容包括：<br />1.颜色的基础只是，配色基础原则：不超过三种颜色<br />2.主色、辅色、点缀色的使用<br />3.色彩集合：图像、文字、图案、图表都可以看成一种颜色<br />4.在不确定的时候，使用黑、白、灰调色<br />5.基础色调：相近色调或对比色调<br />6.根据色彩情感的关键词，选择主色<br />7.根据关键词选择色调，避开主色谈配色<br />8.色彩素材的实践运用：提取色彩——分析色彩——实践运用<br />9.突破对立色彩感受：从一端到另一端</p>
<p><strong>chapter1</strong><br /><strong>色彩基础，让你拥有一个清晰的色彩概念</strong>：使用H（色相）S（饱和度）B（明度）的色相环调色</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910143008-8ee65635-8de9-4886-8555-0df3ba3bb97c.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u104fbf77&amp;name=image.png&amp;originHeight=850&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=878157&amp;status=done&amp;style=none&amp;taskId=u71c2dbb3-c6da-496a-8cee-bc70d5490ba&amp;title=" alt="image.png" /><br />根据颜色三原色红黄蓝，可调出六大常用色，红、橙、黄、绿、蓝、紫（如上图）<br /><strong>互补色：相距180°；</strong><br /><strong>对比色：相距120°；（红色与绿色）<strong>把两种颜色的纯度都设置高一些，两种颜色的特征就会都被对方完美的衬托出来。但是，由于对比色的视觉冲击还是比较大的，需要注意的是，两种颜色在面积上需要有区分。这其中紫色搭配黄色是比较容易让人接受的。此外，对比色的搭配需要用无彩色来进行调和，隔离，降低对视觉的刺激。<br /><strong>类似色：相距90°；</strong><br /><strong>类比色：相距60°；</strong><br /><strong>邻近色：相距45°；</strong><br /><strong>同类色：相距30°</strong><br />某种颜色的补色的两侧颜色是这种颜色的</strong>分裂互补色</strong><br />相隔一个颜色的两个颜色为<strong>间隔色：（红色配黄色）</strong><br />紧挨着的颜色为**相邻色（比如6色换中的红色与橙色）：简单而有效，一种颜色纯度较高时，另外一种颜色选择纯度低或明度低的。<strong>颜色之间想过作用的力量发生变化，色彩就有了主次的关系，和谐度增加。此外，选择同一色相不同明度或者饱和度的颜色搭配也能够得到很好的效果。<br /></strong></p>
<p>**</p>
<p><strong>从两色搭配中认识色彩（色彩搭配，就是色彩之间的相互衬托和相互作用。所以不会从单色开始学习色彩搭配）</strong><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910142765-c2994ea2-1353-42ff-a89a-f55dd8eaa0c9.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ucfc08071&amp;name=image.png&amp;originHeight=740&amp;originWidth=682&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=382628&amp;status=done&amp;style=none&amp;taskId=uc3623408-532e-496b-910d-d06365fb474&amp;title=" alt="image.png" /></p>
<p>红色使得白色很干净，白色使得红色更加注目。**</p>
<p>**</p>
<p>**</p>
<p>**</p>
<p>加入了黑色，白色的存在感降低。</p>
<p>黑色衬托出红色很热情，红色衬托出黑色很庄重，在这里红色与黑色的对比更加明显，使得眼睛在这两种颜色间游离，从而削弱了白色的存在感。<br />（黑白虽然为无彩色，但是在单色系的作品中，无彩色也在发挥非常重要的作用，否则，是无法体现单色的美好出来。）</p>
<p>从无彩色-有单色-两色-三色的搭配过程<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910142855-67c03bcf-19b3-4e33-bdac-afc69ddcb904.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ud7e10651&amp;name=image.png&amp;originHeight=1474&amp;originWidth=500&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=626974&amp;status=done&amp;style=none&amp;taskId=u399a750b-4a3b-4b50-9408-0ca38ffa0ad&amp;title=" alt="image.png" /><br />第一幅：无彩色做主色调，且没有有彩色来点缀，给人消极的感受<br />第二幅单色，从观赏者角度看，只有一种颜色，单色搭配，显得比较单调。但是如果，绿色饱和度增加，与白色对比度增加，<br />观感上就会出现绿色与白色搭配的双色效果。<br />第三幅：双色，虽然黄色面积较大，但是首先映入眼帘的是红色，然后配以黄色为主。<br />第四幅：同样是双色搭配，但是首先映入眼帘的却是背景的深色，品红色为辅。<br />第五幅：三色搭配，画面更加丰富，饱满。</p>
<p><strong>三色搭配的规律，使得你的作品配色更趋向与成熟的方向</strong>：有彩色的色相控制在三种以内。</p>
<p>1统一外观的相邻色搭配：保持色彩基调相同，搭配起来更加简单。比如在同一个纯度上，<br />或者同一个明度上搭配；<br />2高饱高亮的三色搭配：在色相环上等距取三种颜色，会形成让人愉悦的颜色组合<br />3互补取色组合：即使用分割互补色来搭配</p>
<p>颜色不复杂，处理起来才会比较容易，所以在优秀的作品中，往往颜色越少越好。可以去掉的颜色都要尽量避免存在。（比如下图的蓝色边框）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910142739-11f04a69-c8a0-4109-b1d9-05e643775db8.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u57d87da3&amp;name=image.png&amp;originHeight=232&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=232229&amp;status=done&amp;style=none&amp;taskId=u1014bd15-f2c2-4a16-a567-c2927b58d8c&amp;title=" alt="image.png" /><br />在标志中，多用两色三色搭配，这样比较容易识别，记忆。而在插画中则可以承载更多复杂的色彩变化。<br />但是，除了纯绘画与摄影等，就色相而言，也很少有超过三种搭配的作品。<br /><strong>chapter2 主色、辅色、点缀色</strong><br /><strong>主色</strong>：色相决定整个作品的风格，确保正确的传达信息，比如蓝色传达冷静、效率；红色传达热情、刺激等<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910144081-c7b7726a-30d8-4acf-aae9-1cfb0ad2df4c.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u85102793&amp;name=image.png&amp;originHeight=768&amp;originWidth=326&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=335436&amp;status=done&amp;style=none&amp;taskId=uecdf7324-9fd2-418f-9906-9f230cf2832&amp;title=" alt="image.png" /><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910144263-4f3a8093-e46c-41d5-bfda-0285d41c3479.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ud357c663&amp;name=image.png&amp;originHeight=770&amp;originWidth=322&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=321390&amp;status=done&amp;style=none&amp;taskId=udad93831-bfa9-474d-861f-96dd85a5944&amp;title=" alt="image.png" /><br />在色调相同的情况下，面积越大越显眼，也就更倾向于主色位置。而当两种颜色面积色调都区分不大时，我们称这两种颜色为<strong>双主色</strong>。<br />但是当色彩面积相同时，饱和度高一些的颜色力量更大，更接近于主色地位。即使面积地位较小，饱和度高的颜色也会呈现一定的力量感。<br />饱和度（纯度）高的颜色作为主色会比较稳定，所以通常设定饱和度高的颜色为主色。<br />此外，在画面中心位置的颜色更能吸引人的注意，更容易成为主色。<br />所以，十分“抢镜”的颜色有可能是主色，但是也有可能是点缀色，区别在于谁第一时间进入你的视野，影响你对整个作品的感官和印象。点缀色通常是面积小的部分，为了方面阅读提醒人们的注意而出现。<br />当不能明确主色是，可以根据色彩的基调判断，通过一个颜色的模糊概念，是柔和的，还是明快的，是冷静的，还是激烈的来区分主色的色彩基调。<br /><strong>辅色：帮助主色建立起更完整的形象，如果主色已经完成很好，辅色不是必要存在的。</strong><br /><strong>所以判断辅色应用好的方法是：去掉它，画面不完整，有了它，主色更显优势。</strong><br />辅色与双主色的区别：辅助色是可以被替代的，也可以是多种颜色；在双主色设计中，任何一个颜色都不可被替代。**</p>
<p>背景色是特殊的辅色：白色背景通常是阅读的需要而存在，带有颜色的背景往往可以一下子抓住人们的视线，使得画面更加丰富，而背景本身并不见得是主角。<br />辅助色可以辅助一种颜色，也可以辅助作品中的主体（形象，主图像等）存在<br />选择辅色的方法：1选择同类色，达成画面统一和谐；2选择对比色，使得画面刺激、活泼，也同样很稳定。</p>
<p><strong>点缀色：</strong><br />通常在细节上，多数情况是分散的，面积较小。在杂志中，常常作为牵引阅读，和提醒的作用。</p>
<p>特点1出现次数较多；2颜色非常跳跃；3引导阅读性4与其他颜色反差较大</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910144665-e38cee79-debd-4f1a-84a8-1d8e88c88f03.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=uf8371bf8&amp;name=image.png&amp;originHeight=926&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=835203&amp;status=done&amp;style=none&amp;taskId=u60660eb8-6736-4185-8c7a-84172d889b3&amp;title=" alt="image.png" /></p>
<p>左图中，红色是主色，确定画面颜色基调，<br />紫色是辅助色，辅助红色使得画面完整（由于画面中紫色体现较少，也可以看为点缀色），<br />黄色是点缀色，引导观者阅读从这里开始。<br /><strong>chapter3 色彩集合：图像、图案、文字和图表</strong><br /><strong>图像色彩集合</strong><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910145754-8da73d0e-abd0-4656-bad2-1314b71dee9f.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ub07d9408&amp;name=image.png&amp;originHeight=854&amp;originWidth=626&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=940437&amp;status=done&amp;style=none&amp;taskId=u12532ba2-bd40-494c-87f5-04e10cae259&amp;title=" alt="image.png" /></p>
<p>左图中每种蔬菜分别看成一种颜色，并通过概括的颜色，来对于编辑文字。<br />一般而言，图片中的色彩信息是比较复杂的，这时候需要眯起眼睛，虚化形象，留下简单的色彩印象，什么颜色是大面积的，这种颜色就是这个图像中的主色。</p>
<p>色彩集合的搭配：<br />1从图像中选择的颜色搭配是最简单的搭配方法<br />2也可以采用大胆的对比色搭配</p>
<p>3如果一个色彩集合中，色彩分布比较零散，则需要一一做分析。从整体观察色彩布局、面积、呼应是否合理统一。或者用无彩色将它们整理连接起来，或在图像与图像之间填上色块，将图像与画面融合一体</p>
<p>图案色彩集合：<br />图案是一种有规律的色彩集合，可以看成一种颜色来进行搭配<br />也是一种有传播内涵的色彩，使用时要注意起表达的文化特征<br />图案的花色与色彩之间也有很紧密的联系，色冷的几何图案，适合成熟冷静；暖色可爱图案，则适合活泼、女性</p>
<p>文字色彩集合：<br />正文文字多用黑白灰无彩色，阅读感受上，会忽略文字有带有的无彩色，而改为有彩色时，则无法忽略文字色彩的存在。文字所展示的图像与带有的色彩会比文字本身的含义更加“抢镜”<br />而作为图形的文字，则具有更大的设计空间。</p>
<p>图标色彩集合：<br />设计好的图标，给人精湛专业的感觉</p>
<p><strong>chapter4 黑、白、灰，天生的调和色</strong><br /><strong>色彩调和的含义：</strong><br />**1色彩调和是色彩配色的一种形态，使人感到愉悦，舒适好看的配色通常是色彩调和后的结果</p>
<p><strong>2色彩调和是色彩搭配的一种手段，如果想要将看起来不和谐的颜色组合在一起，就需要进行色彩调和</strong></p>
<p>任何两种颜色放在一起，其中一个颜色都会被当做其他颜色的参照物。它们之间的色彩对比关系是绝对的，色相、纯度、明度上的差异，必然会导致不同程度的对比。过分的对比需要加强共性来进行调和，过分暧昧的颜色配比需要加强对比来进行调和。</p>
<p>色彩调和的方法：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910145340-96635989-f44d-411a-b63e-19ec78b1a8a3.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=uebc57749&amp;name=image.png&amp;originHeight=580&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=431037&amp;status=done&amp;style=none&amp;taskId=uc4672c9c-6f9b-4d3a-b386-490e9b203d3&amp;title=" alt="image.png" /><br />1面积调和（如右图）尽量避免1：1的对立面积出现，<br />一般使用5：3~3：1会比较好，<br />如果三种颜色则可以使用5：3：2</p>
<p>2点缀调和（颜色空间混合）。在对比强烈的色彩双方，互相点缀对方的色彩。这是一种视觉的空间混合</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910145355-ffa197ec-2fcb-498f-b9f7-f77ba8786b8a.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ua7b831c0&amp;name=image.png&amp;originHeight=113&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=120750&amp;status=done&amp;style=none&amp;taskId=udb15963b-60a9-44d4-8fb6-cf2b458e445&amp;title=" alt="image.png" /></p>
<p>3互混调和：把两种颜色混合到一起，达到你中有我，我中有你的状态。从而得到第三种颜色。这第三种颜色，自然可以与前两种颜色都统一在一起。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910146300-07c700ed-bd4d-4122-a742-67ace08edc22.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u1dcf4b0d&amp;name=image.png&amp;originHeight=573&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=547678&amp;status=done&amp;style=none&amp;taskId=u96221cb1-22c4-4236-b209-12a7a9829a5&amp;title=" alt="image.png" /><br />4<strong>隔绝调和：画面中的色彩过分强烈或者色彩含混不清（图片较多），可运用黑、白、灰、金、银</strong><br />等同一色线，把颜色进行勾边隔离。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910147768-9a863ea7-53ce-4d67-8fd6-63c39861396d.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u9bef7e7b&amp;name=image.png&amp;originHeight=533&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=557303&amp;status=done&amp;style=none&amp;taskId=u69e7d87a-7250-438c-8b35-69d38626060&amp;title=" alt="image.png" /></p>
<p>5秩序调和：也就是按照颜色渐变的顺序进行排序调和（比如彩虹）<br />6最简单的方法：同一调和。包括同色相、同明度、同饱和度的调和。<br />同色相即指色相环中60°之内的色彩。<br />同明度是指被选定的色彩各色度明度相同<br />同饱和度是指颜色饱和度相同，基调一致，达成统一外观</p>
<p><strong>黑、白、灰作为调和色更可以让作品稳定。综合运用可以使作品更受关注</strong><br /><strong>白色作为背景常被忽略，白色可以使有彩色更轻盈、更透气</strong><br /><strong>灰色作为辅助色，让画面有质感、有氛围，作用关键。与灰色差异大的色彩，更适合强烈的突出主题；与灰色差异小的色彩，更容易体现出高雅的氛围</strong><br /><strong>黑色则可以使得任何复杂的颜色都稳定下来，使得画面有重心、有秩序。</strong><br />**</p>
<p><strong>chapter5相近色调或对比色调调和</strong><br />在色彩搭配中，不要盲目进行，而是确定一个大的方向后，朝着这个方向寻找、调整、改良。在细节上花时间打磨。</p>
<p>色彩搭配有三个极端：<br />1单一色：本身单一色无法形成颜色搭配，单一色搭配是指相近色搭配。同类色基调是温和的，可以在同一颜色周围选色，或仅仅改变明度饱和度。这样的画面通常是柔和的基调；</p>
<p>2强烈的对比色：效果强烈，戏剧性，冲突非常明显。为了营造和突出某一个元素时比较适合<br />3五颜六色：这种情况可以使用无彩色辅助，不常用。</p>
<p>配色思路：没有思路的时候，从色彩基调入手</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910149456-3ca79717-cfef-4b51-adef-d8bc13e6a488.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=udee5201c&amp;name=image.png&amp;originHeight=522&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=827503&amp;status=done&amp;style=none&amp;taskId=u111205c1-7bfb-4afd-945f-3749b7fcc0c&amp;title=" alt="image.png" /></p>
<p>1寻找共性、统一的相近色调配色<br />基调统一，找到色彩之间共性的地方，达到同类色调外观统一（如右图第一张是同类色统一色调，第二张为图片取色统一基调）</p>
<p>2寻找强烈感受、戏剧冲突的对比色调配色思路<br />相似色调虽然画面统一，和谐，但它是一种比较温和的手段，如果需要创作更有戏剧性，更具对立色彩倾向的作品，就需要使用对比色调搭配。</p>
<p>面积上：可以使用小范围的对比，也可以使用大范围的对比，或者在面积对比上进行强化对比的关系。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910149799-967a76bf-e307-40e4-b493-fa0f8140ee0e.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ub4ea8505&amp;name=image.png&amp;originHeight=543&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=787358&amp;status=done&amp;style=none&amp;taskId=ub705810e-f6cd-476c-ba7c-113682d0fe5&amp;title=" alt="image.png" /><br />3同时用两种思路进行色彩设计<br />同类色寻找色彩之间的共性，对比色强调戏剧性。同时运用，会使画面在和谐与冲突之间达到平衡。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910149832-f4131f53-fc4c-4c92-a46a-65d818ef73e8.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ud9a607c9&amp;name=image.png&amp;originHeight=537&amp;originWidth=800&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=622383&amp;status=done&amp;style=none&amp;taskId=u14c08150-6b62-43a5-a016-b61aa9b95e3&amp;title=" alt="image.png" /></p>
<p><strong>chapter6色彩情感的运用</strong><br /><strong>色彩的情感实际上是我们对于外界事物的一种审美感情</strong><br />抽象色彩与具象色彩的区别在于，抽象色彩上附着了人的情感**</p>
<p>在人类漫长的历史中，人们看待色彩不是单纯的从色相上判断的，而是从色彩依附的载体、色彩的来源、使用色彩的族群和不同的文化中寻找更多的信息加以理解。</p>
<p><strong>红色</strong>：成熟的苹果是红色，红色的苹果是具象的色彩，同时红色也代表了成熟。<br />红色代表食物中重要的颜色，同时也代表健康，积极，时尚，文化。淡雅的红色常用作女性色彩，娇艳的红色往往表示积极向上的精髓，偶尔也会表示恐怖，神秘感。<br /><strong>橙色</strong>：多数家庭的感觉，温暖，阳光，欢快。同时也是醒目的，没有太多负面情感的颜色。<br /><strong>黄色</strong>：最醒目、最明亮的颜色。适合儿童，有活泼，开放的心情。<br /><strong>绿色</strong>：春天的颜色，和平，生命，环保，常用语医疗和农业等。<br />**蓝色：**中国有很长的海岸线，沿海地方都比较喜欢使用蓝色<br /><strong>紫色</strong>：幻想色，不切实际的主题中。既优雅也温柔，庄重又华丽，成熟女人的象征。同时也是冷色，有阴暗、冷漠的一面。<br /><strong>粉色</strong>：少女的颜色<br /><strong>白色</strong>：是如空气一般的存在，设计中绝对少不了<br /><strong>灰色</strong>：与有彩色搭配，呈现出高雅，成熟一面，不同深浅的灰色搭配额，给人感受又十分消极<br />**黑色：**比较常用与男士，重要场合，不可侵犯的感觉。</p>
<p><strong>每种颜色都有冷暖</strong>：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910149688-69c48518-4304-4ea6-85f4-0a90a88e8d36.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u8e04116a&amp;name=image.png&amp;originHeight=458&amp;originWidth=734&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=228756&amp;status=done&amp;style=none&amp;taskId=u439b7833-ca3d-4ff5-8c94-a7b1f2298a7&amp;title=" alt="image.png" /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910149740-10b33081-878a-45c6-975b-d5dce15d9b3d.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=uf457725e&amp;name=image.png&amp;originHeight=388&amp;originWidth=388&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=116374&amp;status=done&amp;style=none&amp;taskId=u1e8ccc7c-98a2-47f1-b6f4-21751a4b188&amp;title=" alt="image.png" /></p>
<p>原色中红色为暖色，蓝色为冷色。<br />同时在原色中加黄色颜色发暖，加蓝色发冷。<br />当画面处于基调是暖调时，<br />在冷色中加黄色达到偏暖的颜色也可以使用。</p>
<p>比如右图，湖蓝是一种暖色的蓝<br />深蓝、蓝灰就是冷色的蓝</p>
<p><strong>阴影也有冷暖：</strong><br />太阳与灯泡是光通常是暖光，日光灯通常是冷光。冷光产生的阴影发蓝，发冷；暖光产生的阴影发红、发暖。</p>
<p>每种颜色的冷暖色可产生两级情感：暖色的蓝给人干净、整洁、智慧 和柔和等，冷色的蓝虽然也有智慧的情况信息，但是更多的带有冷酷的、冷眼旁观的，公正的和商务的效果。</p>
<p><strong>chapter7基调关键词，避开主色谈配色</strong><br />关于配色的选择，除了根据主色，还可以根据色彩基调原则来确定</p>
<p>1纯色色调：积极健康的色调。使用纯色为主色，搭配饱和度低的颜色作为辅助色，此时需要扩大纯色面积，否则无法展现出纯色特征。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910151685-3ab4a127-5794-4e24-8a79-c3c1fef03f90.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u68642b5d&amp;name=image.png&amp;originHeight=364&amp;originWidth=758&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=354628&amp;status=done&amp;style=none&amp;taskId=u9e5dc56c-4681-4f97-9483-9fe002aa16f&amp;title=" alt="image.png" /><br />2明色色调：清爽明快的色调。在纯色的基础上加入白色得到色彩。</p>
<p>明色作为主色时，并不十分稳定，但是只要两种明色作为主色，配合小面积的其他颜色，也可以很出彩。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910152550-ecd7e0bd-22ba-4155-9789-d1a38dc06b0c.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u0262d60d&amp;name=image.png&amp;originHeight=380&amp;originWidth=778&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=434130&amp;status=done&amp;style=none&amp;taskId=ud594871c-6659-416b-941b-af9636ecf81&amp;title=" alt="image.png" /><br />3淡色色调： 柔软天真的色调。明色加白色得到淡色色调。非常的轻柔，温柔</p>
<p>不建议作为主色，非常的不稳定。但如果一组单色的组合，也可以表达出轻柔的质感效果<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910152055-8d3069e3-58e6-4dc1-9d86-a89bfce984e3.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=ue0f84f92&amp;name=image.png&amp;originHeight=384&amp;originWidth=790&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=347996&amp;status=done&amp;style=none&amp;taskId=u0451f2c9-ecda-435c-a16e-54ab72e351b&amp;title=" alt="image.png" /><br />4浊色色调：成熟优雅的色调。纯色中加灰色。在绘画中比较忌讳，加灰色会使得画面变脏。但是在计算机调色中，颜色展示的效果更纯，则可以一试。使用与成年人，形成稳重，素雅感。但是要注意加入灰色的量，注意色彩倾向的变化。浊色的开放度不够，可以配合补色达到稍许开放亲和的效果。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910152786-cd426637-1039-41f0-baf2-a1710b57affd.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u0238ed83&amp;name=image.png&amp;originHeight=364&amp;originWidth=744&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=406515&amp;status=done&amp;style=none&amp;taskId=u9ee20763-37b3-4a52-b292-0450b353703&amp;title=" alt="image.png" /><br />5淡浊色色调：优雅的色调。淡色加黑得到淡浊色。与浊色的情感相似。更加优雅，更偏重女性化</p>
<p>6暗色色调：强调商务的色调。纯色加黑。在那行相关产品中常出现。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910152567-712dbc0c-dd4a-4b41-abf0-3a9f02cc4f8c.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u695523a3&amp;name=image.png&amp;originHeight=366&amp;originWidth=754&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=253093&amp;status=done&amp;style=none&amp;taskId=udc0c00d1-490f-41eb-b5ad-4c2d6c9a4c0&amp;title=" alt="image.png" /></p>
<p>确定颜色之前，先确定颜色明暗的基调。然后可以使用多种色调的组合，在健康的纯色中加入优雅的单色，可以消除纯色抵挡的感觉，转为质朴，同时增加了色彩的多层次感。<br />色调组合的原则：注意主色调与对抗色调的面积配比，面积较大的为主色调，也是重点表现的色调，而对抗色调要选择可以为主色补色的色调。</p>
<p><strong>chapter8突破素材的形式，提取色彩-分析色彩-实践运用色彩</strong><br />**经验是提高配色能力的重要指标。在时间不够的情况下，先要学习优秀的作品。分析和练习是非常必要的，吧看到的优秀配色从原本形式中提取出来，应用到新的形式中去。</p>
<p><strong>我们可以从任何设计作品中获取配色的借鉴，包括网页，平面，服装，插画等等。</strong><br />**</p>
<p>**</p>
<p><strong>chapter9突破对立色彩的感受：从一端到另一端的选择</strong><br /><strong>搭配出一种情感效果，很可能就无法得到另一种情感效果，在这种情况下就要合适的取舍，明确具体的配色目的。</strong><br /><strong>同样是浊色➕明色，不同的颜色搭配，可以得出不同情感的颜色搭配效果。可以是活泼的，可以是平静的，也可以平时，华丽的。</strong><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1637910153027-db451be0-0970-40ea-8f59-3245d0972894.png#clientId=ue8ec18fd-e97e-4&amp;from=paste&amp;id=u1eb6f1ef&amp;name=image.png&amp;originHeight=466&amp;originWidth=770&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=307472&amp;status=done&amp;style=none&amp;taskId=u35601eab-b6d3-4d7d-92fd-bf99d489b42&amp;title=" alt="image.png" /></p>
<p>最后：<br />色彩有冷暖之分，有性别之分，也有不同的感情基调。所以把色彩也当成有灵魂的“人”，在搭配的过程中，时时刻刻考虑到不同的色彩搭配在一起要“和谐相处”，才能构建出和谐的画面。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/18" rel="alternate"/><category term="Web"/><category term="产品"/><published>2023-03-02T09:28:33+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/17</id><title>关于B端产品的一些思考以及体会</title><updated>2023-03-02T09:44:05.342834+00:00</updated><content type="html"><![CDATA[<p>这半年来，由于某些原因，我在开发之余，也承担了平台前端产品需求的挖掘，设计和梳理的工作，也做成了诸如公开数据集模块，模型自动化等需求的前端交互设计或者是总体的业务流程设计，有些还挺不错，受到了一些好评。做着做着就由感而发，也对B端的产品设计有了一些自己的思考，因此总结一下这半年来，在这方面的体会以及心路历程。</p>
<h2>一、AI 产品的不确定性</h2>
<p>相较于传统的B端产品，AI平台最大的特点就是不确定，这个不确定表现在很多方面。譬如：</p>
<ul>
<li>业界没有明显的标杆性的产品可做参考，且就算部分友商也有类似的项目，也大多是内部使用，并没有开源。因此很多东西需要自己去探索，去踩坑。只有坑踩多了，才会有更明确的方向感，才会逐步去靠近所要解决的核心问题</li>
<li>另外，在做 AI 平台的时候，可以很明显的感受得到，有时候需求方对于自己想要的东西也是不确定的，有时候嘴上说着我们就需要简单的功能，这样会比较方便。但随着沟通的不断深入，需求就会不断的被挖出来（这点我体会很深，毕竟我可是疯狂给自己加需求小王子，手动狗头）</li>
<li>等等</li>
</ul>
<p>这些不确定性，都让我们在产品的探索过程中，不得不去不断试错，从错误和失败中吸取教训，并逐步完善自己对于产品设计的方法论。比如：</p>
<ul>
<li>做事情要聚焦，做平台也是，开发不是去堆砌功能，而是要发现问题，解决问题；在完成功能的开发后，要跟进这个功能的使用情况，及时收集种子用户的使用意见，并快速作出相应的改进。</li>
<li>做一个功能不能拍脑袋决定，不能觉得有用就去开发。这样成了还好，不成的话即浪费了自己的开发成本，又徒增平台的复杂性，得不偿失。合理的做法是，要想明白自己做的功能是给谁做的，解决了他什么问题。然后将这功能的原型准备好，找对应的同学好好聊聊，看他们是否真的觉得这个问题是他们的痛点，然后再决定是不是要做。</li>
</ul>
<p>因此，总的来讲，对于像AI平台，这种不能充分吸取其他产品的设计经验、充满着不确定性的产品，首先要做的就是保持理性，保持克制，尽量减少试错成本，不断试错，快速迭代。（个人经验是如果方便的话，如果一个需求有对应的提出人，可以在完成一个简单的原型后就找到对应的需求提出人，确定基础功能的实现是符合他的预期的）</p>
<h2>二、易用性</h2>
<p>B端产品的一大特点就是普遍业务复杂度高，而AI平台在此基础上同时还有较高的学习成本。按照俞军老师的用户价值公式：</p>
<blockquote>
<p>用户价值=新体验-旧体验-切换成本</p>
</blockquote>
<p>因此如何增强用户价值，在做好新体验的同时，切换成本的缩小至关重要，这也是对于B端产品来说，易用性很重要的原因，因为它不仅可以作用于新体验，更可以在切换成本的缩小上提供巨大助力。</p>
<p>这里的成本，对于AI平台，我个人理解可以分为几个方面：</p>
<ul>
<li>学习成本：名词较多，业务场景复杂，上手成本较高，需要耗费不少精力以及时间去学习。</li>
<li>资源迁移成本：AI平台做的很多事情，有时候算法工程师都有着自己的一些实现方式，只不过这些方式不利于统一管理或者是记录。譬如数据管理模块，模型管理模块这些模块，在进行迁移的时候，需要算法工程师将一些在开发集的资源迁移到平台这边来，而这些工作量也主要集中的数据的迁移，以及格式的对齐上。</li>
<li>心智耗费成本：这个成本也是由于平台本身业务以及功能的复杂所导致的。譬如说：AI平台，在多个模块相互关联的情况下，往往有时候发起一个任务，需要多个模块的资源进行协调，而这个时候用户有时候就不得不去记忆不同模块资源的对应ID，这其实是很让人心累（尤其是在命令行使用时）。</li>
</ul>
<p>而减少这些成本，我们则可以从这几个方面入手（主要参考的是尼尔森十大可用性原则）：</p>
<ul>
<li>人性化帮助</li>
<li>容错处理</li>
<li>防错原则</li>
<li>撤销重做原则</li>
<li>状态可见</li>
</ul>
<p>（具体后面再写个介绍一下这一块）</p>
<h2>三、情感化</h2>
<p>在B端，很多时候都会忽略情感化的事情，但据我这几个月的实践来看，情感化其实在B端也是非常重要的一环。<br />对于B端我们可以从马斯洛五层出发，将实现的层次分为三个：</p>
<ul>
<li>可用性</li>
<li>稳定性</li>
<li>情感化</li>
</ul>
<p>一个好的情感化设计可以极大的提升用户体验，拉近平台与用户的距离。</p>
<p>对于情感化设计，我个人有以下一些心得：</p>
<ul>
<li>设计合理，保持克制：相关的情感化设计，要和全平台的相关设计逻辑保持一致，且由于B端产品的主要目的其实是为了提升效率，因此我们的情感化设计也不能有损于我们的主要目标，这也需要我们对于这些情感化的添加要保持克制</li>
<li>明确用户，投其所好：对于自己要服务的用户，我们也需要明确，并对设计符合他们审美，以及使用习惯</li>
</ul>
<p>如何去做：</p>
<ul>
<li>产品引导</li>
<li>文字 or 邮件关怀</li>
<li>图形</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/17" rel="alternate"/><category term="产品"/><published>2023-03-02T09:27:47+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/16</id><title>关于 BPM 的一些记录与思考</title><updated>2023-03-02T09:44:05.565906+00:00</updated><content type="html"><![CDATA[<h1>BPMN2 及相关概念</h1>
<p>去年刚入职的时候，学习了 AWS 的关于 BPMN2 的一些文档，输出一下自己对于文档的理解：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1622973941077-4798449f-2c53-465d-8e83-17e0dd2e48a7.png#clientId=ud374fb22-d32f-4&amp;from=paste&amp;height=500&amp;id=uec962f42&amp;name=image.png&amp;originHeight=744&amp;originWidth=2356&amp;originalType=binary&amp;ratio=1&amp;size=298008&amp;status=done&amp;style=none&amp;taskId=ue26f5275-bf9c-4914-a7f9-16be68b24f6&amp;width=1583" alt="image.png" /></p>
<h1>流程</h1>
<h2>流程是什么？</h2>
<p>引用《流程性组织》的说法：流程是一套<strong>完整的端到端</strong>，<strong>为客户创造价值的活动连接集合</strong>。</p>
<ul>
<li>端到端： 从客户需求中来，到客户需求中去</li>
<li>为客户创造价值： 利他精神。流程的设计要全景的、本质的思考客户的任务、客户的痛点、客户的需求、要全力以赴的去满足客户的要求。而不是因为公司内部的专业化分工、科层制体系，最后搞得只能满足内部的要求</li>
</ul>
<p>那流程如何满足客户的要求呢：</p>
<ul>
<li>快速：流程的一个重要属性就是时间、在设计结构的会后，可以吧串行变成并行、删除一些非必须的活动、删除一些非必要的签字</li>
<li>质量：第一是保证正确性，即用户的操作需要正确的响应，不出错，或者出现用户预期之外的事件发生。其次对于流程本身，重要的流程有必要的风控节点，会有评审的合理控制点，通过专业化的评审，有效的决策，系统的测试、检查、质量管理来保证质量是为消费者和客户保驾护航的</li>
<li>成本：流程一次跑通，结束。这里需要给予一些用户提示</li>
<li>容易：对流程本身的要求就是需要高效、简单，心智负担小等</li>
</ul>
<blockquote>
<p>其实总的来说，流程的这些需求，对于广泛的 B端产品 都是适用的。上述的这些要素，对于几乎所有的 B 端产品想要满足客户的需要，让用户用的舒服，都值得参考 </p>
</blockquote>
<p>那么流程本身，又有哪些必要构成呢：</p>
<ol>
<li>输入：任何流程、不管流程整体还是某个活动都有一定的输入</li>
<li>活动：代表一中动作和行为，这样才能产生价值和落地</li>
<li>输出：经过一系列的动作，将输入转化为输出</li>
<li>职位：强调在流程中呈现的不是部门而是职位，只有通过职位才能连接个体，才能让跨部门的员工实现端到端的协作。要注意部门和部门之间的协同问题，强调部门和部门之间通过人与人的协同才会高效。</li>
<li>相互作用：流程有两种关系，一种是串行一种是并行，在很多场景下，并行要比串行好，一方面节省时间，一方面实现了人与人之间的协同</li>
<li>时间：一定要在流程中标注出时间、每一个动作的执行时间、我们要保证每个动作的执行人要有自律和非常重要的时间观念</li>
<li>信息接口：流程数据的对外同步</li>
<li>客户：在新的流程体系里，一切流程都是面向客户的，反思流程是否走完了全过程，实现了客户的价值与要求（需要回答两个问题：1. 对客户要有清晰的认知，客户是谁？客户端的需求是什么？2.用什么去实现客户价值）</li>
</ol>
<p>从上述必要构成出发，从领域驱动设计的角度来讲，我们对于一个流程的模型，或许可以如此抽象：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/296173/1624416125530-6d61e184-1a47-43e3-98d6-5e2308d0ad92.png#clientId=uc9de569a-6de0-4&amp;from=paste&amp;height=954&amp;id=ufd557560&amp;name=image.png&amp;originHeight=954&amp;originWidth=2090&amp;originalType=binary&amp;ratio=1&amp;size=126280&amp;status=done&amp;style=none&amp;taskId=udd88226e-99f5-48c5-b212-be8e0852401&amp;width=2090" alt="image.png" /></p>
]]></content><link href="https://github.com/srtian/Blog/issues/16" rel="alternate"/><category term="产品"/><published>2023-03-02T09:27:22+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/15</id><title>浅谈 Rust 前端应用开发</title><updated>2023-03-02T09:44:05.677620+00:00</updated><content type="html"><![CDATA[<p>随着技术的不断演进，近年来愈来越多的非前端开发语言诸如：Rust、Go 等也开始进入前端/跨端应用开发领域，并收获了不小的开源社区的关注。因此本次在此尝试对基于 Rust 的一些 前端/跨端 应用开发进行一些分析，来分析一下这种开发模式的技术基础、基本方案等情况，由于篇幅原因将分为两部分：第一部分，主要讨论 Rust 前端应用开发的基本现状、原理以及收益等，而第二部分则会讨论号称 Electron 终结者的 Tauri 的基本情况、最大卖点、基本架构组成等。
<a name="rwzVM"></a></p>
<h1>一、兴起的基础</h1>
<p>对于前端应用开发有一定了解的同学应该知道，可以在浏览器端运行的编程语言主要有两种：</p>
<ul>
<li>JavaScript</li>
<li>WebAssembly</li>
</ul>
<p>而诸如 Rust、Golang 等这样的编程语言并不具备直接运行在浏览器端的能力，当今的 Rust 前端应用开发框架之所以能得到落地，最主要还是得益于 WebAssembly 近年来的快速发展。其主要的流程就是将 Rust 编译成 WebAssembly ，然后在浏览器端运行，大致如下：<br />
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56f7c090de8b499894d7d51381118c75~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<p>因此讨论 Rust 来进行前端开发，WebAssembly 是无法绕开的一环，它的诸多<a href="https://webassembly.org/">特性</a>也成为了 Rust/Go 等前端应用框架的卖点：</p>
<ul>
<li>Efficient and fast</li>
<li>Part of the open web platform</li>
<li>Safe</li>
</ul>
<p>这几点特性也让使用 WebAssembly 开发前端应用在技术上已经成为了可能。而另一方面，Rust 由于其优秀的语言设计以及强劲的性能，已经多年稳坐最受欢迎语言的排名榜首，这让越来越多的开发者加入到了 Rust 学习以及开发的中去，让 Rust 技术社区不断壮大，也让诸多 Rust 开发者不断思考着其能够发光发热的领域。<br />而此时前端领域也遇到了自己的瓶颈，随着前端开发领域的不断扩展，前端所要实现的业务复杂度也在不断增长，这也对前端应用在性能以及安全性上提出了更高的要求。虽然经过多年来的不断改进，JavaScript 在性能上都得到了长足的进步，但相较于系统级语言还是存在较大的差距。而 Rust 作为一门系统级语言，在具有强大的性能的同时，还提供强大的所有权系统以及类型体系，对安全性提供了强力的保障，这无疑是对 JavaScript 极好的补充。于是一方是快速壮大的技术社区在寻求充分的发挥场景，一方是要求不断提升的前端领域，这二者的结合也就顺理成章了。
<a name="futn1"></a></p>
<h1>二、基本介绍</h1>
<p><a name="JhEli"></a></p>
<h3>2.1、基本情况</h3>
<p>在介绍 Rust 开发前端应用之前，需要先补充一个小点，现在使用 Rust 开发前端应用有两种开发方式，我将其称称为激进派以及改良派。其中激进派的做法是整个应用全部使用 Rust 进行开发，然后将其编译为 WASM 运行在 WebView 或者浏览器中，这也是我们今天所讨论的开发方式。而改良派则倾向于将应用的一部分用 Rust 进行开发，然后将其作为一个 Module 和前端应用进行组合，这也是一种较为常见的开发方式，由于篇幅问题在此就不做过多介绍。<br />总的来说现今的开源社区的 Rust 前端框架基本呈现一超多强的局面，大体上有以下几个较为出名的开源项目： </p>
<ul>
<li><a href="https://github.com/yewstack/yew">Yew</a> : 当今最火的 Rust 前端框架，也是开发时间最早的一批框架了，其核心在于基于组件进行开发，Github 上已有 20k+ star。</li>
<li><a href="https://seed-rs.org/">Seed</a>：语法类似于 Elm。</li>
<li><a href="https://github.com/dioxuslabs/dioxus">dioxus</a>：类 React 的 Rust 前端框架，支持跨端开发（Web、Desktop、Mobile）。</li>
<li><a href="https://github.com/sycamore-rs/sycamore">sycamore</a>：类似于 Svelte，提供响应式开发。（有意思的是，这个框架自称的一大卖点是：<strong>No JavaScript</strong>: Had enough of JavaScript? So have we.）</li>
</ul>
<p>总的来看，这些框架在设计上，大体上具有几个比较共同的特性：</p>
<ol>
<li>基于组件开发，虽然在具体写法上存在一些区别，但总的来说都是如此。</li>
<li>或多或少的都有些现代前端框架的影子，譬如：Yew 和 dioxus 之于 React，sycamore 之于 Svelte。</li>
<li>基本使用 virtual dom 的方式来对 dom 的操作进行的一定的抽象（毕竟 Wasm 不能直接操作 DOM）。 </li>
</ol>
<p>光说不练假把式，本着实践是检验真理的唯一标准，我周末花了些时间使用 <a href="https://github.com/DioxusLabs/dioxus">dixous</a> 实现了一个 TodoMVC 应用，感兴趣的同学可以直接点看下面的链接，试着运行项目看看：</p>
<blockquote>
<p><a href="https://github.com/srtian/todomvc-dioxus">https://github.com/srtian/todomvc-dioxus</a></p>
</blockquote>
<p>从个人的开发体验上来看，由于 Rust 本身的语言设计和 JavaScript 有较大的区别，因此对于熟悉使用 JS/TS 的开发者来说，会有一定的 Gap，比如说状态管理时的区别；至于其他的诸如 JSX 等，由于这些框架都在借鉴 React 等前端框架的设计理念，所以总的来说差异并不大。
<a name="s0ygc"></a></p>
<h3>2.2、基本架构</h3>
<p>至于这些 Rust 前端框架的大体架构，由于大体上都是借鉴了现代前端框架的开发模式，差距并不大，总的来讲都会有一个 html 的宏来负责对 virtual_dom 的处理以及映射，此外还会提供前端路由、状态管理、异步处理等能力，来提升框架的易用性以及能力。这里将以 dioxus 为例其主要构成大体如下：<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73768d770324146ab23dcba181a2a4a~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />正如之前所介绍的，dioxus 是基于 react 的风格所开发的前端框架，因此其中很多东西都和 react 生态系统保持了高度的一致：</p>
<ul>
<li>其中 Router 借鉴了 react-router，主要提供了 hooks 和 components 这两个部分的能力: <a href="https://github.com/DioxusLabs/dioxus/blob/master/packages/router/src/lib.rs">router</a>：</li>
</ul>
<pre><code class="language-rust">mod hooks {
    mod use_route;
    mod use_router;
    pub use use_route::*;
    pub use use_router::*;
}
pub use hooks::*;

mod components {
    mod link;
    mod redirect;
    mod route;
    mod router;

    pub use link::*;
    pub use redirect::*;
    pub use route::*;
    pub use router::*;
}
pub use components::*;
</code></pre>
<ul>
<li>state 则主要是通过 hooks 来进行管理，按照其<a href="https://github.com/DioxusLabs/dioxus/tree/master/packages/hooks">官方描述</a>，主要有四个基础的 hooks：use_state、use_ref、use_future、use_coroutine。其中 use_state 和 use_ref 除了在使用以及能力上和 react 的 hooks 有些许区别外，其他的并无太大区别，而 use_future、use_coroutine 则主要用于处理异步的状态，具体使用场景可以移步官方文档对应的<a href="https://dioxuslabs.com/guide/async/index.html">章节</a>，写得很详细，在此就不做过多的赘述。</li>
<li>然后就是 Virtual DOM 了，这也是几乎所有 Rust 前端框架的重中之重。一方面由于 WebAssembly 操作 DOM 比 JavaScript 具有更高的成本，因此需要使用 Virtual DOM 来减少 DOM 的操作频率，以提升性能；其次在跨端/服务端渲染部分， Virtual DOM 也有着非常重要的作用。因此dioxius 的 Virtual DOM 在借鉴了 react 的相关优秀理念的同时，还借鉴了 <a href="https://github.com/fitzgen/dodrio">Dodrio</a> 诸如：Bump Allocation、Change List as Stack Machine 等等设计思想以提升其 Virtual DOM 的性能以及内存使用效率；最后还充分利用的 Rust 所有权的特性对内存进行优化。从而做到：通常情况下一旦加载了应用，就不再需要执行分配操作，只有当新组件被添加至 dom 中时，才会进行再分配；且对于给定的组件，添加新节点时，会动态的回收旧的虚拟DOM的空间；最后还会记录之前的组件的平均内存占用情况，从而预估未来组件需要分配多少内存。</li>
<li>最后 dioxus 提供了 rsx! 和 html! 这两个宏来为开发者提供类似于 JSX 的开发功能，本质上主要的能力就是将我们所写的 html/rsx 转化成 Virtual DOM ，没个元素则有下列属性组成：</li>
</ul>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
pub struct Element {
    pub name: Ident,
    pub key: Option&lt;LitStr&gt;,
    pub attributes: Vec&lt;ElementAttrNamed&gt;,
    pub children: Vec&lt;BodyNode&gt;,
    pub _is_static: bool,
}
</code></pre>
<p>至于在跨端部分，dioxus使用的实际还是 Tauri 所提供的 wry 来进行 WebView 的侨接。这块儿在下一部分来讲，再次就不做过多赘述了。
<a name="mgKX4"></a></p>
<h3>2.3、基本分析</h3>
<p><a name="kI2PZ"></a></p>
<h4>1、性能</h4>
<p>Rust 作为系统级的编程语言，在性能上的优势是毋庸置疑的，swc、postcss-rs 等工具的兴起最大的原因就在于此。譬如<a href="https://github.com/postcss-rs/postcss-rs">postcss-rs</a> 就给出的性能对比：<br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7265e2bd88245b59cbc1aaa4a0190b4~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />从上图的直观表现来看，rust 在性能上较之 JS 具有非常大的优势。但这里的性能差距并不能作为讨论的前端应用开发场景下的依据。前面也提到过 Rust 并不能直接运行在浏览器端，需要编译成 WebAssembly 才能运行在浏览器端，所以对比的对象应该是 WebAssembly 和 JavaScript。<br />  而在Wasm方面，我们前面曾提到，虽然 WebAssembly 在性能上相较于 Javascript 有一定优势，但由于无法直接操作DOM，所以并不一定会在前端应用上有很好的表现，这也是很多早期 Wasm 用户所吐槽的点。但这个问题也只是暂时的，<a href="https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md">Interface Types</a> 计划完全解决这个问题，且随着 WebAssembly 的不断发展，这一情况也会得到改善，我们可以直接使用框架之间的 <a href="https://github.com/krausest/js-framework-benchmark">benchmark</a> 来进行对比（这里现在还不支持 dixous 进行对比，因此选用了 yew、sycamore 以及 wasm-bindgen ）：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/296173/1662101171226-d5dd9f4a-78cf-4211-a29e-1b639c635095.png#clientId=u892e03c0-70e3-4&amp;from=paste&amp;id=u3a2bb538&amp;originHeight=1594&amp;originWidth=1286&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ufa5f0fd6-4418-481b-9705-fb03cf62782&amp;title=" alt="" /><br />可以看到，Rust 系的前端框架在常见的DOM操作方面的性能上大多和传统的前端框架没有明显的区别，甚至在一些场景下要优于 Angular 和 React。而在其他方面也表现很不错： <br /><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e8c0fe924d54dff8ae0b48b80bc35c6~tplv-k3u1fbpfcp-zoom-1.image" alt="" /><br />因此在性能上来讲，Rust 系的前端框架还是保持着一个较为不错的表现的，并没有出现所谓的 wasm 在 dom 操作上性能非常差的现象。而对于计算密集的场景，WASM 则要优于 JS，具体讨论可以看下述文章，在此就不再做过多的讨论了：<br /><a href="https://www.adservio.fr/post/how-fast-and-efficient-is-wasm">how-fast-and-efficient-is-wasm</a>。<br />总的来说，虽然WASM在操作DOM的性能上仍然存在较大的进步空间，但距传统前端框架的性能差距并不大；而在计算密集的场景下，则会有一定的优势。
<a name="d9gl2"></a></p>
<h4>2、安全</h4>
<p>基于 Rust 开发的应用在安全方面无疑也是具有竞争力的。首先 Rust 本身由于所有权系统以及生命周期来实现内存管理，没有运行时的GC，加之强大的编译器的代码检查，都为构建构建内存安全的应用提供了坚实的保障。<br />而对于 WebAssembly 来说，正如它自身的<a href="https://webassembly.org/docs/security/">文档</a>所说的，WebAssembly 的安全模型主要有两个目标：</p>
<ol>
<li>不让用户遭受 Bug 以及恶意模块的影响</li>
<li>为开发者提供足够的能力开发安全的应用</li>
</ol>
<p>首先在内存方面 WebAssembly 只提供一个沙盒化的线性内存（linear memory），致使其对内存的访问十分有限，只能对这个线性内存进行读写以及扩缩容，无法对其他内存进行操作。这虽然损失了一定的便利性，但在内存安全方面也提供了一些保障，对于 WASM 内存安全的详细介绍，可以参考下列文章：<br /><a href="https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/">https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/</a><br />而在控制访问方面。WASM 也做的非常的好：WebAssembly 代码本身是在一个由虚拟机管理的沙盒中封闭运行的，这让它与主机是相互隔离的，无法与主机直接进行交互。在这种情况下，如果想实现对系统资源的访问就只能通过虚拟机所提供的 WebAssembly 系统接口（<a href="https://github.com/WebAssembly/WASI">WASI</a>）来进行。而WASI 提供了基于能力的安全模型（Capability-based security），遵循最小权限原则，譬如在进行指定文件等资源的访问时，需要显示的在外部传入加有权限的文件描述符的引用，对于其他未授权的资源是无法访问的，这种依赖注入的方式可以避免很多传统安全模型的潜在风险。<br />总的来说，在安全方面 Rust + WebAssembly 的组合能帮助我们写出更加安全的应用，为用户的安全保驾护航。
<a name="vbirE"></a></p>
<h1>三、总结 &amp;&amp; 展望</h1>
<p>综上所述，Rust 开发前端应用开发主要是通过将代码编译为 WebAssembly 从而实现在浏览器端运行甚至是跨端的目的。但需要注意的是，站在2022年的来看，这种开发模式仍然还是稚嫩的，存在不少的问题：</p>
<ol>
<li>开发团队的搭建成本，虽然上文提到 Rust 已多年连续蝉联最受欢迎编程语言的榜首。但它学习曲线的陡峭性仍然会让很多开发者望而却步，因此当一个应用选择使用这种方式进行开发时，会需要搭建一个 Rust 开发团队，但显然搭建一个前端工程师团队还是会比搭建一个 Rust 开发团队要迅速、简单不少。</li>
<li>开发速度，前端场景下，大部分的业务强调的还是快准狠，现代前端框架也是向着这个方向发展的，而 Rust 在开发业务的速度上明显是很难与 React/Vue 相抗衡。 </li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcbec89e6e6a48beb019effb2a2fc2e3~tplv-k3u1fbpfcp-zoom-1.image" alt="" /></p>
<ol start="3">
<li>生态系统的问题，虽然 Cargo 生态经过近几年的快速发展，已经到达了一个较为不错的水平，但要和广大的前端工程师的生态系统比，仍然存在一定差距，还需要一定的时间来进行追赶。</li>
</ol>
<p>也正是由于以上原因，以 Rust 为主力语言进行前端应用开发的方式并没有取得很多的落地。取得落地的反而是一些混合应用，比较典型的就是 Figma：将部分计算密集或者是业务逻辑复杂的模块使用 Rust/Cpp 进行开发，在这些模块内实现计算逻辑，对外暴露出计算结果/指令，然后通过 canvas 去对页面进行绘制，这样可以有效的缓解 WebAssembly 操作 DOM 所带来的性能损耗从而保障性能。至于整体都使用 Rust 进行开发，我想还需要 WebAssembly 得到足够的普及以及得到更好的发展，才能实现。<br />好了，本文对 Rust 进行前端应用开发进行了一个简单的介绍，下文将开始介绍号称 Electron 杀手的 Tauri，看它是如果利用我们在本文做介绍的这些基础能力，成为当今炙手可热的客户端应用开发方案的。</p>
<p>参考资料</p>
<ul>
<li><a href="https://training.linuxfoundation.org/blog/webassembly-security-now-and-in-the-future/">https://training.linuxfoundation.org/blog/webassembly-security-now-and-in-the-future/</a></li>
<li><a href="https://webassembly.org/">https://webassembly.org/</a></li>
<li><a href="https://github.com/WebAssembly/WASI">https://github.com/WebAssembly/WASI</a></li>
<li><a href="https://hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/">Memory in WebAssembly (and why it’s safer than you think)</a></li>
<li><a href="https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md">https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md</a></li>
<li><a href="https://rustwasm.github.io/docs/book/introduction.html">https://rustwasm.github.io/docs/book/introduction.html</a></li>
<li><a href="https://webassembly.org/docs/security/">https://webassembly.org/docs/security/</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/15" rel="alternate"/><category term="Top"/><category term="Rust"/><published>2023-03-02T09:25:44+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/14</id><title>浅谈 Rust 所有权机制</title><updated>2023-03-02T09:44:05.790135+00:00</updated><content type="html"><![CDATA[<h1>一、什么是 stack 和 heap</h1>
<p>stack 和 heap 都用于变量的内存存储。对于大多数的编程人员来讲，都无需去关心内存是如何分配到 heap 和 stack 中的（实际上，对于 stack   和 heap 的区别，也很多人并不是很清楚）。譬如在JavaScript中，大多数人知道一个结论：基本数据类型放在 stack 中，而引用数据类型放在 heap 里面。但一旦问到，为何需要这样进行划分的时候，少有人可以说上一二。</p>
<p>那它们到底有什么区别呢？ 首先它们虽然都是可供代码使用的内存，但结构是不同的。 stack是一个线性的数据结构，以放入值得顺序存储值并以相反的顺序取出值，也就是我们常说的：后进先出。其数据的输入和取出，则通常被称为 进栈、出栈。由于 <code>stack</code>是线性的数据结构，所以 stack 中的所有数据都是必须占用<strong>已知且固定</strong>的大小。</p>
<p>而 heap 则是一个非线性的数据结构，是缺乏组织的。因此对于一些在初始时，大小未知或大小可能发生变化的数据，则可以放在堆中。当我们想要在堆中存储一些数据时，我们通常其实是请求一块大小合适的空间，然后操作系统在堆中搜索一个足够大的空间以匹配我们所请求的内存量，并将其标记为已用，并返回一个表示该位置地址的 **指针， **而这个指针也通常被存在 stack 中。这个过程也就是 <strong>堆内存分配</strong>，也常被称为 <strong>内存分配。</strong></p>
<blockquote>
<p>需要注意的是，将变量推入 stack 中，其实并不能被认为是内存分配，因为它本质上，只是按顺序压入 stack中，比不需要去进行显性的分配</p>
</blockquote>
<p>由于它们数据结构不同、存储方式不同。也决定了，将值压入 stack 要比在 heap 上进行内存分配要来的快。因为入 stack 时，操作系统无需为新数据搜索内存空间，位置固定于 stack 顶部，只需压入即可。而堆内存分配则需要先找到一块足够存放数据的内存空间，然后才能将变量放入，生成指针（很多时候，还需要将指针压入 stack 中保存）。同理，访问 stack 的变量也比访问 heap 得数据要快。</p>
<h1>二、什么是所有权</h1>
<p>搞清楚栈和堆得区别后，我们大致就可以清楚我们通常说的 GC 其实主要关注的就是 heap 上的内存的回收。而我们今天要说的的所有权，其实也是主要管理堆数据，例如：哪部分代码正在使用 heap上的哪些数据，最大限度的减少堆上的重复数据，清理堆上不再使用的数据确保不会耗尽空间。</p>
<p>所有的编程语言，都有着属于自己的管理计算机内存的方式。大体上可分为两个大的流派：</p>
<ol>
<li>语言自带垃圾回收机制，可以在程序运行时不断的去寻找不再使用的内存。比如JavaScript、Go等语言，就自带垃圾回收机制</li>
<li>语言没有自带垃圾回收，需要开发者亲自进行内存的分配和释放，比较典型的就是如 C、 C++。</li>
</ol>
<p>而Rust则没有走上面两条道路，而是通过所有权系统来管理内存，编译器在编译时会根据一系列的规则去对代码进行进行检查，确定变量的回收时机，因此，当程序运行时，所有权系统不会减慢程序。</p>
<p>而所有权系统具体有以下三点最重要的规则：</p>
<ul>
<li>Rust 中的每一个值都有一个被称为其 owner 的变量</li>
</ul>
<pre><code class="language-rust">let a = 5   // a 是 5 的 owner
</code></pre>
<ul>
<li>每个值在任何一刻都只能有一个 owner</li>
<li>当 owner 离开作用域时，这个值的内存将被回收</li>
</ul>
<h1>三、变量的作用域</h1>
<p>Rust 根据作用域管理指针，在作用域中申请内存，离开作用域则会释放作用域。Rust 中的作用域也非常简单, Rust 是词法作用域，以大括号为边界，一个大括号对应着一个作用域：</p>
<pre><code class="language-rust">fn main() {
    let content = String::from(&quot;Srtian&quot;);
    println!(&quot;{}&quot;,content);
}
</code></pre>
<p>比如如上的代码，在 <code>String::from</code> 处为 <code>content</code> 申请了内存，而在离开大括号后，content也就离开了作用域后被释放掉。</p>
<h1>四、所有权的具体表现</h1>
<p>上面几部分以及差不多将Rust的所有权系统简单的减少了一遍，接下来就让我们来看看，所有权系统到底是如何作用域 Rust 的内存管理的。</p>
<h2>4.1、所有权的移动</h2>
<p>在Rust中，对于已知大小的值，将其进行复制到另一个值会很容易：</p>
<pre><code class="language-rust">fn main() {
    let a =  &quot;5&quot; ; 
    let b = a ; //将值a复制到b 
    println!（&quot;{}&quot;, a)  // 5 
    println!(&quot;{}&quot;, b)  // 5 
} 
</code></pre>
<p>因此 a 存储在  <code>stack</code> 中，所以我们可以对其直接进行复制。但对于放在 <code>heap</code> 中的数据，我们就不能这么简单的进行复制了（放在 <code>heap</code> 中的数据，也就是被所有权系统所管理的数据）：</p>
<pre><code class="language-rust">fn main() { 
	let s1 = String::from(&quot;hello&quot;);
	let s2 = s1; // 将s1复制到s2
    println!(&quot;{}&quot;, s1)  // 这里会报错，因为s1在这里已经被释放了
    println!(&quot;{}&quot;, s2)  // hello
}
</code></pre>
<p>当我们运行上面代码时，会出现报错。这是因为，当我们复制存储在 <code>heap</code> 中的值时，Rust 为了防止诸如：二次释放这样的错误，它在处理这种场景时，会直接认为 s1 不再有效。这样 Rust 就无需再在 s1 离开作用域时再需要清理它。</p>
<p>熟悉诸如JavaScript等语言的朋友，应该对浅拷贝和深拷贝很熟悉，其实上述的这个操作有点浅拷贝的意思，它只会拷贝指针、长度和容量，而不会直接拷贝数据。但 Rust 同时也会让第一个变量直接无效，因此也不能粗暴的将其理解为浅拷贝。</p>
<blockquote>
<p>还有个需要注意的： Rust 永远不会自动创建数据的&quot;深拷贝&quot;。因此，所有自动的复制，都可以认为对于运行时的性能影响较小</p>
</blockquote>
<p>而当我们确实需要深拷贝去拷贝 heap 上的数据时，我们可以使用 <code>clone</code> 方法来对值进行深拷贝：</p>
<pre><code class="language-rust">
#![allow(unused)]
fn main() {
	let s1 = String::from(&quot;hello&quot;);
	let s2 = s1.clone();
	println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
}
</code></pre>
<h2>4.2、所有权的借用</h2>
<p>所有权的移动或者变量的深拷贝并不能满足工程师们日常的开发需求，比如：</p>
<pre><code class="language-rust">fn main(){
    let contents = String::from(&quot;hello srtian&quot;);
    some_process(contents);
    println!(&quot;{}&quot;,contents); // error
}
fn some_process(word:String) {
    println!(&quot;some_process {}&quot;,word);
}
</code></pre>
<p>在上面的代码中， some_process(contents) contents变量会『移动』给some_process的参数word，contents变量就不能再次使用了。而且对于每次内存的重新分配，许多资源在时间和空间的开销都太昂贵了，但在日常开发中，类似的需求还是很多的。因此在这种情况下， Rust 提供了借用的选项。</p>
<p>所有权的借用也非常简单，我们只需在借用的变量前，加&amp;字符即可：</p>
<pre><code class="language-rust">struct Person {
    age: u8
}

fn main() {
    let jake = Person { age: 18 };
    let srtian = &amp;jake;

    println!(&quot;jake: {:?}\nsrtian: {:?}&quot;, jake, srtian);
}
</code></pre>
<p>在上述代码中，尽管没有 clone。但上面的代码仍然会编译并输出。同样，如果是不可复制的值被借用，可以将其作为参数传递给函数，也就是解决我们上面所说的那个问题：</p>
<pre><code class="language-rust">fn sum(vector: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    let mut sum = 0;
    for item in vector {
        sum = sum + item
    }
    sum
}

fn main() {
    let v = vec![1,2,3];
    let v_ref = &amp;v;
    let s = sum(v_ref);
    println!(&quot;sum of {:?}: {}&quot;, v_ref, s); // 不会报错
}
</code></pre>
<p>不过，需要注意的是，对于借用来的变量，我们是不能对其进行更改的。这其实也符合我们日常生活的基本常识，借来的东西，我们都需要原样进行返回。不过，Rust 也提供了方法来对借用来的变量进行更改：</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}

</code></pre>
<p>我们需要将 s 修改为 mut。然后传入的参数以及接受的参数，都需要显式的表明是 mut 的。不过需要注意的是，在特定的作用域中，特定的数据只能有一个可变引用。这个限制允许可变性的存在，不过是以一种受限的方式允许的。这样做的好处在于 Rust 可以在编译时就避免 数据竞争。数据竞争类似于竞态条件，它可由三种行为造成：</p>
<ol>
<li>两个或更多指针同时访问统一数据</li>
<li>至少有一个指针被用来写入数据</li>
<li>没有同步数据访问的机制</li>
</ol>
<p>有时候，我们会希望返回借来的值。比如我们想要返回字符串中较长的一个，我们可以写出如下的代码：</p>
<pre><code class="language-rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.bytes().len() &gt; y.bytes().len() {
        x
    } else {
        y
    }
}

fn main() {
    let jake = &quot;jake&quot;;
    let srtian = &quot;srtian&quot;;

    println!(&quot;{}&quot;, longest(jake, srtian));
}
</code></pre>
<p>以上的代码不能成功编译，会报错：</p>
<pre><code class="language-rust">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
                                ^ expected lifetime parameter
 
 = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>这就有关乎变量的生命周期了，生命周期是借用变量的有效范围。Rust 强大的编译器让我们在大多数情况下，无需显式的编写它们，而是通过推断去实现。但在一些需要生命周期参与的场景下，还是需要我们手动的去添加申明周期函数。譬如，我们想要解决上面的错误，就需要进行生命周期的手动声明：</p>
<pre><code class="language-rust">fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str {
    if x.bytes().len() &gt; y.bytes().len() {
        x
    } else {
        y
    }

fn main() {
    let jake = &quot;jake&quot;;
    let srtian = &quot;srtian&quot;;

    println!(&quot;{}&quot;, longest(jake, srtian));
}
</code></pre>
<p>如此我们就能将借用的变量进行返回来。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/14" rel="alternate"/><category term="Rust"/><published>2023-03-02T08:09:43+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/13</id><title>产品可用性之容错处理设计及实践</title><updated>2023-03-02T09:44:05.903449+00:00</updated><content type="html"><![CDATA[<h2>一、为什么说容错处理很重要</h2>
<p>B端产品由于其自身就具有一定的业务复杂度以及上手成本，因此在可用性方面，做好容错处理至关重要。一个好的容错处理既可以有效的提升用户使用产品的顺畅程度以及使用效率，也可以避免一些产品设计不够完善的问题的暴露。<br />
<br />下图是我在学习尼尔森十大可用性原则时所做的学习思维导图：<br /></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/svg/296173/1591757022787-9e968925-89d4-4a08-ad73-1f24b61a8298.svg" alt="" />从上述的思维导图我们不难发现，尼尔森所强调的可用性原则里面，绝大部分其实都和容错处理息息相关。我个人理解，容错处理我们可以在一下几个方面进行设计：</p>
<ol>
<li>在用户进行相关操作前，提供合理的引导，提示等有效的使用帮助。【2、环境贴切原则 10、人性化帮助原则】</li>
<li>用户在进行操作时，及时给予操作反馈以及实时错误提示（实时错误提示主要应用于表单）。【1、状态可见， 5、防错原则】</li>
<li>发生阶段性错误发生后，错误易定位，且错误易恢复，操作易重启。【3、撤销重做原则 9、容错原则】</li>
</ol>
<p>接下来，我将从以上三个方面，来阐述如果进行合理的容错处理。</p>
<h2>二、操作前的容错处理</h2>
<h3>2.1、环境贴切原则</h3>
<p>可能有些朋友会有疑惑：为何环境贴切原则会列到操作前的容错处理当中。但从我个人的经验以及理解来看：用户在进行一个操作时，所处的大环境会有效的有助于用户进行合理的自我下意识判断。首先我们要清楚的是，用户在进行操作的时候，大多数情况下，是下意思的行为，并不会在每个操作上都会去花费一定的心力成本去思考，这个操作进行后，会造成什么影响。因此一个熟悉的大环境或者是说熟悉的上下文环境，可以有利于用户不花费多余的心力成本就去完成一些操作。<br />
<br />这一点在AI平台就得到了很好的印证，早期AI平台由于产品规划的原因，只有英文版的。但实际上，我们的主要用户是公司内部的算法工程师，虽然这个群体普遍英文水平较高，但得到的反馈还是某些专业名词不够直观，不好理解。因此当时我就尝试去推动平台进行本地化，在原有的英文基础上，支持中文。在中文得到支持后，也得到了不少好的反馈，且从数据上来看，在支持中文以后，百分之90%以上的用户都使用中文版，且对于一些复杂表单的填写的错误率也下降了近三分之一。</p>
<h3>2.2、人性化帮助原则</h3>
<p>除了上述的环境贴切原则，另一方面就是给予用户足够的人性化的帮助，主要是以下几个方面：</p>
<h4>1. 新手引导</h4>
<p>新手引导算是现在互联网中最常见的帮助方式了，非常有利于用户快速上手。而对于B端产品，主要的实现方式主要包括：</p>
<ul>
<li>引导视频</li>
<li>引导文档</li>
<li>引导动画</li>
</ul>
<p>比如AI平台就给予了一个全面的帮助文档来让用户可以快速了解平台的基础功能，以及一些相关的专业名词的含义：<br />                                                       <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591340878952-3daed16d-c0ca-4ee6-8a1b-e75d13dd6cdf.png#align=left&amp;display=inline&amp;height=396&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1188&amp;originWidth=480&amp;size=76949&amp;status=done&amp;style=none&amp;width=160" alt="image.png" /></p>
<h4>2. 表单设计合理并给予有效引导</h4>
<p>从数据录入的操作便捷程度来讲：单选 &gt; 选择型下拉框(select) &gt; 输入框。此外对于一些具有相应填写规则的表单，也需要给予一些提示，具体方式主要有以下几种：</p>
<ul>
<li>使用 <code>placeholder</code> 对输入内容进行提示</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591351917689-b08a9eb0-dadc-46e7-846e-ed20fd27290a.png#align=left&amp;display=inline&amp;height=42&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=126&amp;originWidth=1100&amp;size=12160&amp;status=done&amp;style=none&amp;width=366.6666666666667" alt="image.png" /></p>
<ul>
<li>使用提示icon，将填写规则说明：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352213692-fca28354-cc08-4990-be53-188849d5bacf.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=258&amp;originWidth=1742&amp;size=42359&amp;status=done&amp;style=none&amp;width=580.6666666666666" alt="image.png" /></p>
<h4>3. 操作提醒的设置</h4>
<p>对于一些比如删除等不可逆的操作时，我们也需要在用户进行操作前，给予有效的提醒，这样可以有效的减少用户的误点误删的事情发生：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352474964-982eafd9-58a8-4beb-b7e1-366f75136d4d.png#align=left&amp;display=inline&amp;height=93&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=278&amp;originWidth=1256&amp;size=35655&amp;status=done&amp;style=none&amp;width=418.6666666666667" alt="image.png" /><br />此外，在表单填写时，也应该给予实时的提醒，让用户可以在填写时就知道自己的填写内容是错误的，从而及时的更正，而不是要等要点击提交按钮时才会抛出异常或者错误，这一块Ant Design的表单就做的很好：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352663302-fb84f114-f2b0-40a9-8eab-cf270e863c9e.png#align=left&amp;display=inline&amp;height=45&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=134&amp;originWidth=1224&amp;size=24954&amp;status=done&amp;style=none&amp;width=408" alt="image.png" /></p>
<h2>三、操作时的容错处理</h2>
<p><a name="uXxlF"></a></p>
<h3>3.1、状态可见原则</h3>
<p>这里的状态可见，从大的方面来讲，可以理解为一个任务的状态，在这个方面，大家都做的不错；但从小的方面来讲，状态可以是一次搜索，一次表单的填写等这样小的操作。比如搜索，如果没有搜索到对应的内容，在一些场景下就需要提醒：<br />                                    <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591354809203-06f00d65-84fa-4643-978b-bcf0fb3994a6.png#align=left&amp;display=inline&amp;height=51&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=152&amp;originWidth=1058&amp;size=30922&amp;status=done&amp;style=none&amp;width=352.6666666666667" alt="image.png" /><br />以及我上面，在人性化帮助原则中第3点所提到的，表单的填写需要实时的提醒，其实也是状态可见原则的表现。<br /></p>
<h3>3.2、防错限制的设置</h3>
<p>对于一些比较常发生的错误，我们也可以通过一些权限设置，或者是直接给予默认值等设置，来避免类似错误的发生。比如给表单设置默认项，不可操作的按钮进行置灰并给予相应的置灰解释：<br />                                                          <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591352946704-bb920a17-a5f4-4550-8e26-542bf7ef7077.png#align=left&amp;display=inline&amp;height=66&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=544&amp;size=21088&amp;status=done&amp;style=none&amp;width=181.33333333333334" alt="image.png" /></p>
<h2>四、错误发生后的容错处理</h2>
<h3>4.1、错误发生后，及时提供错误信息</h3>
<p>这一项在AI 平台或者类似的一些平台所需要的，比如在AI平台发起一个编译任务，如果此项任务发生错误，就应该在展示错误状态外，还停供相关的错误信息，以方便用户快速进行定位，修复相关错误：<br />                           <img src="https://cdn.nlark.com/yuque/0/2020/png/296173/1591690266586-6b2fd6ca-750d-4533-8d08-59447ed3f998.png#align=left&amp;display=inline&amp;height=26&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=45&amp;originWidth=836&amp;size=6891&amp;status=done&amp;style=none&amp;width=491" alt="image.png" /><br /></p>
<h3>4.2、错误操作发生后，提供完善的保障机制</h3>
<p>对于B端产品来说，用户经常也会出现误删资源的操作。因此如果在这些操作进行时，在进行提醒之外，应该还具有一定的回溯机制。比如在AI平台现在在Web端对一个资源进行删除，但其实只是暂时删除了一个映射关系，其底层的资源暂时是没有被删除的，仍然存储在数据库中，只有到了一定的时间，才会去清理相应的资源。这样做的好处就在于，虽然耗费了一定的空间，但大大的降低了数据损失的风险（这块除了这一处理方式，其实对于数据集这样的资源，本身就会对不太常用的数据集放入磁带，因此删除也只是解除映射关系之余将这个资源打入冷资源中）</p>
<p>除此之外，对于一些链路比较长的任务，我们也应该提供完善的回退机制，保证用户在当前阶段发生错误时，可以回退到上一步，而不至于整个任务全部失败，需要从头再来，比如以一个算法模型的半自动化的生产链路来讲：<br />
<br /></p>
<p>这是一个很长的生产链路，所耗费的时也很长，因此在进行模型半自动化生产的过程中，如果因为其中一个任务出现了问题，而导致整个链路都需要重新开始，实在是太不友好了。因此需要将上述步骤提供完善的错误回退机制，比如预测任务发起失败，只需要提示用户预测任务发起失败，然后给予用户完善的错误信息提示，待用户解决问题后，直接重新发起预测任务即可。<br />
<br />类似的例子还有很多，比如PS，LR等操作软件，也提供了历史记录的功能，可以轻松回退的相应的地方<br /></p>
<h2>结语</h2>
<p>上述只是我个人在实践过程中的一些体会以及方法论，因为大家的产品特征不同，所要解决的问题，目标用户群体也不同。因此在具体的设计时，要根据自身的特点，去因地制宜的设计合理的容错处理机制。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/13" rel="alternate"/><category term="Web"/><category term="产品"/><category term="Top"/><published>2020-06-10T07:07:06+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/12</id><title>简述JavaScript模块化编程</title><updated>2023-03-02T09:44:06.079872+00:00</updated><content type="html"><![CDATA[<h1>简述JavaScript模块化编程</h1>
<p>在早期编写JavaScript时，我们只需在 script 标签内写入JavaScript的代码就可以满足我们对页面交互的需要了。但随着时间的推移，时代的发展，原本的那种简单粗暴的编写方式所带来的诸如逻辑混乱，页面复杂，可维护性差，全局变量暴露等问题接踵而至，前辈们为了解决这些问题提出了很种的解决方案，其中之一就是JavaScript模块化编程。总的来说，它有以下四种优点：<br /></p>
<ol>
<li>解决项目中的全局变量污染的问题。</li>
<li>开发效率高，有利于多人协同开发。</li>
<li>职责单一，方便代码复用和维护 。</li>
<li>解决文件依赖问题，无需关注引用文件的顺序。</li>
</ol>
<p><a name="GU4V3"></a></p>
<h3>一、先行者CommonJs</h3>
<p><br />2009年Node.js横空出世，将JavaScript带到了服务器端领域。而对于服务器端来说，没有模块化那可是不行的。因此CommonJs社区的大牛们开始发力了，制定了一个与社区同名的关于模块化的规范——CommonJs。它的规范主要如下：<br /></p>
<ol>
<li>模块的标识应遵循的规则（书写规范）。</li>
<li>定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴露出来的API。</li>
<li>如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖。</li>
<li>如果引入模块失败，那么require函数应该报一个异常。</li>
<li>模块通过变量exports来向外暴露API，exports只能是一个对象，暴露的API须作为此对象的属性。</li>
</ol>
<p><br />根据CommonJS规范的规定，每个文件就是一个模块，有自己的作用域，也就是在一个文件里面定义的变量、函数、类，都是私有的，对其他文件是不可见的。通俗来讲，就是说在模块内定义的变量和函数是无法被其他的模块所读取的，除非定义为全局对象的属性。<br /></p>
<pre><code>// addA.js
const a = 1;
const addA = function(value) {
  return value + a;
}
</code></pre>
<p><br />上面代码中，变量a和函数addA，是当前文件addA.js私有的，其他文件不可见。如果想在多个文件中分享变量a，必须定义为global对象的属性：<br /></p>
<pre><code>global.a = 1;
</code></pre>
<p><br />这样我们就能在其他的文件中访问变量a了，但这种写法不可取，输出模块对象最好的方式是module.exports：<br /></p>
<pre><code>// addA.js
var a = 1;
var addA = function(value) {
  return value + x;
}
module.exports.addA = addA;
</code></pre>
<p><br />上面代码通过module.exports对象输出了一个函数，该函数就是模块外部与内部通信的桥梁。加载模块需要使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。<br /></p>
<pre><code>var example = require(&#x27;./addA.js&#x27;);
console.log(example.addA(1));  //2
</code></pre>
<p><br />CommonJs看起来是一个很不错的选择，拥有模块化所需要的严格的入口和出口，看起来一切都很美好，但它的一个特性却决定了它只能在服务器端大规模使用，而在浏览器端发挥不了太大的作用，那就是同步！这在服务器端不是什么问题，但放在浏览器端就出现问题了，因为文件都放在服务器上，如果网速不够快的话，前面的文件如果没有加载完成，浏览器就会失去响应！因此为了在浏览器上也实现模块化得来个异步的模块化才行！根据这个需求，我们的下一位主角——AMD就产生了！<br /></p>
<p><a name="8mpSo"></a></p>
<h3>二、AMD 异步模块定义</h3>
<p><br />AMD的全名叫做：Asynchronous Module Definition即异步模块定义。它采用了异步的方式来加载模块，然后在回调函数中执行主逻辑，因此模块的加载不影响它后面的模块的运行。它的规范如下：<br /></p>
<pre><code>define(id?, dependencies?, factory);
</code></pre>
<ol>
<li>用全局函数define来定义模块;</li>
<li>id为模块标识，遵从CommonJS Module Identifiers规范</li>
<li>dependencies为依赖的模块数组，在factory中需传入形参与之一一对应</li>
<li>如果dependencies的值中有&quot;require&quot;、&quot;exports&quot;或&quot;module&quot;，则与commonjs中的实现保持一致</li>
<li>如果dependencies省略不写，则默认为[&quot;require&quot;, &quot;exports&quot;, &quot;module&quot;]，factory中也会默认传入require,exports,module</li>
<li>如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx</li>
<li>如果factory为对象，则该对象即为模块的返回值</li>
</ol>
<p><br />具体分析AMD我们通过require.js来进行。require.js是一个非常小巧的JavaScript模块载入框架，是AMD规范最好的实现者之一，require.js的出现主要是来解决两个问题：<br /></p>
<ol>
<li>实现JavaScript文件的异步加载，避免网页失去响应。</li>
<li>管理模块的依赖性，管理模块的相互独立性，也就是我们常说的低耦合，这有利于代码的编写与维护。</li>
</ol>
<p><br />使用require.js我们首先要加载它，为了避免浏览器未响应，我们在后面可以加上async,告诉浏览器这个文件需要异步加载（IE不支持该属性，所以需要把defer也加上）：<br /></p>
<pre><code>&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;
</code></pre>
<p><br />定义模块时，在require.js中我们可以使用define，但define对于需要定义的模块是否是独立的模块的写法是不同;所谓的独立模块就是指不依赖于其他模块的模块，而非独立模块就是指不依赖于其他模块的模块。<br />
<br />define在定义独立模块时有两种写法，一种是直接定义对象；另一种是定义一个函数，在函数内的返回值就是输出的模块了：<br /></p>
<pre><code>define({
    method1: function() {},
    method2: function() {},
});
//等价于
define(function () {
	return {
	    method1: function() {},
		method2: function() {},
    }
});
</code></pre>
<p><br />如果define定义非独立模块，那么它的语法就规定一定是这样的：<br /></p>
<pre><code>define([&#x27;module1&#x27;, &#x27;module2&#x27;], function(m1, m2) {

    return {
        method: function() {
            m1.methodA();
			m2.methodB();
        }
    }

});
</code></pre>
<p><br />define在这个时候接受两个参数，第一个参数是module是一个数组，它的成员是我们当前定义的模块所依赖的模块，只有顺利加载了这些模块，我们新定义的模块才能成功运行。第二个参数是一个函数，当前面数组内的成员全部加载完之后它才运行，它的参数m与前面的module是一一对应的。这个函数必须返回一个对象，以供其他模块调用，需要注意的是，回调函数必须返回一个对象，这个对象就是你定义的模块。<br />
<br />在加载模块方面，AMD和CommonJs都是使用require。require.js也同样如此，它要求两个参数：module，callback：<br /></p>
<pre><code>require([module], callback);
</code></pre>
<p><br />第一个参数[module]，是一个数组，里面的成员就是需要加载的模块；第二个参数callback，则是加载成功之后的回调函数。<br />require方法本身也是一个对象，它带有一个config方法，用来配置require.js运行参数。config方法接受一个对象作为参数。<br /></p>
<pre><code>//别名配置
requirejs.config({
    paths: {
        jquery: [   //如果第一个路径不能完成加载，就调到第二个路径继续进行加载
            &#x27;//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.0/jquery.min.js&#x27;,
            &#x27;lib/jquery&#x27;   //本地文件中不需要写.js
        ]
    }
});

//引入模块，用变量$表示jquery模块
requirejs([&#x27;jquery&#x27;], function ($) {
    $(&#x27;body&#x27;).css(&#x27;background-color&#x27;,&#x27;black&#x27;);
});
</code></pre>
<p><br />虽然require.js实现了异步的模块化，但它仍然有一些不足的地方，在使用require.js的时候，我们必须要提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载，使得初次加载其他模块的速度较慢，提高了开发成本。<br /></p>
<p><a name="TZgDs"></a></p>
<h3>三、CMD 通用模块定义</h3>
<p><br />CMD的全称是Common Module Definition，即通用模块定义。它是由蚂蚁金服的前端大佬——玉伯提出来的，实现的JavaScript库为sea.js。它和AMD的require.js很像，但加载方式不同，它是按需就近加载的，而不是在模块的开始全部加载完成。它有以下两大核心特点：<br /></p>
<ol>
<li>简单友好的模块定义规范：Sea.js 遵循 CMD 规范，可以像 Node.js 一般书写模块代码。</li>
<li>自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。</li>
</ol>
<p><br />在CMD规范中，一个文件就是一个模块，代码书写的格式是这样的：<br /></p>
<pre><code>define(factory);
</code></pre>
<p><br />当factory为函数时，表示模块的构造方法，执行该方法，可以得到该模块对外提供的factory接口，factory 方法在执行时，默认会传入三个参数：require、exports 和 module：<br /></p>
<pre><code>// 所有模块都通过 define 来定义
define(function(require, exports, module) {

  // 通过 require 引入依赖
  var $ = require(&#x27;jquery&#x27;);
  var Spinning = require(&#x27;./spinning&#x27;);

  // 通过 exports 对外提供接口
  exports.doSomething = ...

  // 或者通过 module.exports 提供整个接口
  module.exports = ...

});
</code></pre>
<p><br />它与AMD的具体区别其实我们也可以通过代码来表现出来，AMD需要在模块开始前就将依赖的模块加载出来，即依赖前置；而CMD则对模块按需加载，即依赖就近，只有在需要依赖该模块的时候再require就行了：<br /></p>
<pre><code>// AMD规范
define([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) {  // 依赖必须一开始就写好  
   a.doSomething()    
   // 此处略去 100 行    
   b.doSomething()    
   ...
});
// CMD规范
define(function(require, exports, module) {
   var a = require(&#x27;./a&#x27;)   
   a.doSomething()   
   // 此处略去 100 行   
   var b = require(&#x27;./b&#x27;) 
   // 依赖可以就近书写   
   b.doSomething()
   // ... 
});
</code></pre>
<p><br />需要注意的是Sea.js的执行模块顺序也是严格按照模块在代码中出现(require)的顺序。<br />
<br />从运行速度的角度来讲，AMD虽然在第一次使用时较慢，但在后面再访问时速度会很快；而CMD第一次加载会相对快点，但后面的加载都是重新加载新的模块，所以速度会慢点。总的来说,<br />require.js的做法是并行加载所有依赖的模块, 等完成解析后, 再开始执行其他代码, 因此执行结果只会&quot;停顿&quot;1次, 而Sea.js在完成整个过程时则是每次需要相应模块都需要进行加载，这期间会停顿是多次的，因此require.js从整体而言相对会比Sea.js要快一些。
<a name="hZM1K"></a></p>
<h3>四、ES6模块特性</h3>
<p><br />在ES6中将模块认为是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。在一个模块中定义的变量不会自动被添加到全局共享的作用域之中，这个变量只能作用在这个作用域中。此外模块还必须导出一些外部文件可以访问的元素，以供其他模块或代码使用。<br />
<br />除了这个基本特性，ES6模块还有两大特性也十分重要，需要额外注意：<br /></p>
<ul>
<li>首先是在模块的顶部this值是undefined，这是由于在ES6中的模块的代码是在严格模式下执行的。（如果对this不是很熟悉的可以去看我的这篇文章<a href="https://www.jianshu.com/p/8d6cc7ad9c58/">：深入浅出this关键字</a>）</li>
<li>其次，模块不支持HTML风格的代码注释，这是早期浏览器所遗留下的JavaScript特性，在ES6的语法里不予支持。
<a name="b3340053"></a></li>
</ul>
<h4>4.1、基本用法-模块加载</h4>
<p><br />首先我们来看浏览器是如何加载模块的。其实在ES6规范出来之前，web浏览器就规定了三种方式来引入JavaScript文件：<br /></p>
<ul>
<li>在没有src属性的 script 元素中直接内嵌JavaScript代码</li>
<li>在 script 元素中通过src属性指定一个地址来加载JavaScript代码文件</li>
<li>通过Web Worker或Service Worker的方法加载并执行JavaScript代码<br />
而在浏览器中，默认的行为就是将JavaScript作为脚本来进行加载，而非模块。所以我们要告诉浏览器我们加载的是模块，方法就是在 script 元素中，将type属性指定为&quot;module&quot;。具体看下面的示例：</li>
</ul>
<pre><code>// 第一种方式
&lt;script type=&quot;&quot;module&gt;
   import { add } from &quot;./example&quot;;
   let num = add(1, 1);
&lt;/script&gt;
//  第二种方式
&lt;script type=&quot;module&quot; src=&quot;example.js&quot;&gt;
// 第三种方式，以脚本的方式加载example.js
let worker = new Worker(&quot;example.js&quot;);
</code></pre>
<p><br />当HTML解析器遇到 script 元素的type=&quot;module&quot;的时候，模块文件就开始下载，直到文件被完全解析完成才会去执行模块内的代码。模块文件是按照他们出现在HTML文件中顺序执行的，也就是说无论用何种方式引入模块，第一个 script type=&quot;module&quot; 总是在第二个 script type=&quot;module&quot; 之前执行。<br /></p>
<p><a name="0384f32d"></a></p>
<h4>4.2、基本用法-导出</h4>
<p><br />在ES6中我们可以使用export关键字将一部分代码暴露给其他模块，以供其他模块或代码使用。先让我们来看看export关键字在MDN的定义吧：<br /></p>
<blockquote>
<p>export语句用于在创建JavaScript模块时，从模块中导出函数、对象或原始值，以便其他程序可以通过 import 语句使用它们。（
此特性目前仅在 Safari 和 Chrome 原生实现。它在许多转换器中实现，如Traceur Compiler，Babel或Rollup。）
通过MDN的定义我们可以知道：export关键字可以将其放在任何函数、对象或原始值前面，从而将它们从模块中导出。示例如下：</p>
</blockquote>
<pre><code>//   ./example.js
// 导出变量
export var a = 1;
// 导出函数
export function addA(value) {
   return value + a;
}
//导出类
export class add1 {
   constructor(value) {
       this.value = value + a;
   }
}
//这个函数就是这个模块所私有的，在外部不能访问它
function say1() {
   console.log(&#x27;我是不是很帅&#x27;);
}
//这又是个函数
function say2() {
   console.log(&#x27;没错我就是很帅&#x27;);
}
//在后面对函数进行导出,它就不是私有的了
export say2;
</code></pre>
<p><br />需要注意的是：使用export导出的函数和类都需要一个名称，除非使用default关键字，否则就不能用这个方法导出匿名函数或类。所以当我们需要导出匿名的函数或者类时，我们可以这么做：<br /></p>
<pre><code>//   ./example.js
//导出匿名函数
export default function(a, b) {
   return a + b；
}
//或者导出匿名的类
export default class {
consturctor(value) {
   this.value = value + 1;
   }
}
</code></pre>
<p><br />具体关于default关键字的用法我会在后面做具体介绍，现在只需记住：当我们需要导出匿名的函数或者类时要使用export default语法。<br /></p>
<p><a name="ac2d4199"></a></p>
<h4>4.3、基本语法-导入</h4>
<p><br />在ES6中，从模块中导入的功能可以通过import关键字。import语句由两部分组成：要导入元素的标识符和元素应当从哪个模块导入。<br /></p>
<pre><code>//  ./say.js
import { say2 } from &quot;./example.js&quot;;
console.log(say2()); // &#x27;没错我就是很帅&#x27;
</code></pre>
<p><br />import 后面的大括号中的say2表示从规定模块导入的元素的名称。关键字from后面的字符串则表示要导入的模块的路径，这通常是包含模块的.js文件的相对或绝对路径名，需要注意的是只允许使用单引号和双引号的字符串来包裹路径，浏览器使用的路径格式与传给 script 元素的相同，所以必须把文件的扩展名也加上。<br /></p>
<blockquote>
<p>（注：由于Node.js遵循基于文件系统前缀以区分本地文件个包的惯例，即example是一个包，而./exampple.js是一个本地文件。为了更好的兼容多个浏览器Node.js环境，我们一定要在路径前包含./或../来表示要导入的文件。）
除此之外，我们还可以导入多个元素或者直接导入整个模块：</p>
</blockquote>
<pre><code>// 导入多个元素
improt { a, addA, say2 } from &quot;./example.js&quot;;
console.log(a); // 1
sonsole.log(addA(1); // 2
// 导入整个模块
import * as example from &quot;./example.js&quot;
console.log(example.a); // 1
sonsole.log(example.addA(1); // 2
console.log(example.say2()); // &#x27;没错我就是很帅&#x27;
</code></pre>
<p><br />上面的导入整个模块就是把example.js中导出的所有元素全部加载到一个叫做example的对象中，而所导出的元素就会作为example的属性被访问。因为example对象是作为example.js中所导出成员的命名空间对象而被创建的，所以这种导入方式被称为命名空间导入（name space import)。<br />还有一点要注意的是，不管import语句把一个模块写了多少次，该模块只执行一次。意思就是，在首次执行导入模块后，实例化的模块就会被保存在内存中，只要使用import语句引用它就可以重复使用它：<br /></p>
<pre><code>// 首次导入需要加载模块example.js
import { a } from &quot;./example.js&quot;
// 下面的两个import将无需加载example.js了
import { addA } from &quot;./example.js&quot;
import { say2 } from &quot;./example.js&quot;
</code></pre>
<p><br />当从模块中导入一个元素时，它与const是一样无法定义另一个同名变量和导入一个同名元素，也无法在import语句前使用元素或者改变导出的元素的值：<br /></p>
<pre><code>//接上面的代码
say2 = 1 ;  //会抛出一个错误
</code></pre>
<p><br />这是由于ES6的import语句为导入的元素创建的是只读绑定的标识符，而不是原始绑定。因此元素只有在被导出的模块中才可以被修改，即使是将该模块的全部导入也无法修改其中的元素。<br /></p>
<pre><code>//   ./example.js
// 这是一个函数
export function setA(newA) {
   a = newA;
}
//  ./say.js
import { a, setA } from &quot;./example&quot;;
console.log(a);  // 1
a = 2;   //抛出错误
// 所以我们得这么做
setA(2);
console.log(a);  // 2
</code></pre>
<p><br />调用setA(2)时会返回到example.js中去执行，将a设置为2。由于say.js导入的只是a的只读绑定的标识符而已，因此会自动进行更改。<br /></p>
<p><a name="28d578f4"></a></p>
<h4>4.4、其他基本语法</h4>
<p><a name="493e9ebb"></a></p>
<h5>1.语法限制</h5>
<p><br />export和import在语法上还有一个重要的限制，那就是他们必须在条件语句和函数之外使用，例如：<br /></p>
<pre><code>if (ture) {
   export var a = 1;      //语法错误
}
function imp() {
   import a from &quot;./example.js&quot;; //语法错误
}
</code></pre>
<p><br />由于模块语法存在的其中一个原因是让JavaScript引擎可以静态地确定哪些代码是可以导出的，因此export和import语句被设计成静态的，不能进行任何形式的动态导出或导入。<br /></p>
<p><a name="19702694"></a></p>
<h5>2.重命名解决</h5>
<p><br />有时在开发中，我们在导入一些元素后不想使用它们的原始名称了，我们就可以在导出过程或者导入过程中去改变导出元素的名称：<br /></p>
<pre><code>// 导出过程
function add(a, b) {
   return a + b;
}
export { add as add1 };  //在导入过程中必须使用add1作为名称
// 导入过程
import {add as add1 } from &quot;./example&quot;
console.log(add1(1,1));  // 2
console.log(typeof add); //undefined
</code></pre>
<p><a name="bd49c3cc"></a></p>
<h5>3.模块的默认值</h5>
<p><br />在CommonJS等其他的模块化规范中，从模块中导出或导入默认值是一个常见的用法，因此在ES6中也延用了这种用法并进行了优化。在ES6中我们可以使用default关键字来指定默认值，并且一个模块只能默认一个导出值：<br /></p>
<pre><code>// ./example.js
// 第一种默认导出语法
export default function(a, b) {
   return a + b;
}
// 第二种默认导出语法
function add(a, b) {
   return a + b;
}
export default add;
// 第三种默认导出语法
function add(a, b) {
   return a + b;
}
export { add as default };
</code></pre>
<p><br />需要注意的是第三种语法，default关键字虽然不能作为元素的名称，但可以作为元素的属性名称，因此可以使用as语法将add函数的属性设置为default。<br />导入默认值的语法则是这样的：<br /></p>
<pre><code>//  第一种语法
import add from &quot;./example&quot;;
//  第二种语法
import { default as add } from &quot;./example&quot;;
</code></pre>
<p><br />看到这里有些朋友可能会发现，我们的第一种语法中import关键字后面并没有加大括号，认为这是错误的。其实这是导入默认值的独特语法，在这的本地名称add用于表示模块导出的任何默认函数，这种语法是最纯净的，ES6标准创建团队的大佬们也希望这种语法能成为web主流的模块导入形式。<br />我们前面说的导入匿名函数也同样使用这种语法：<br /></p>
<pre><code>//   ./example.js
//导出匿名函数
export default function(a, b) {
   return a + b；
}
// ./say.js
import add from &quot;./example&quot;;
console.log(add(1,1));  // 2
</code></pre>
<p><br />在这里本地名称add就是用于表示上面的匿名函数的。<br /></p>
<p><a name="8dd7f54c"></a></p>
<h5>4.导出已导入的元素</h5>
<p><br />我们同样可以在本模块内导出我们在本模块内导入的元素，有以下几种语法：<br /></p>
<pre><code class="language-javascirpt">//  第一种语法
import { add } from ./example.js;
export { add };
//  第二种语法
export { add } from ./example.js;
//换一个名称导出
export { add as add1 } from ./example.js; //以add这个名称导入，再以add1的名称导出
// 导出整个模块
export *  from ./example.js;
</code></pre>
<p><br />// 最后求一波暑期前端实习的坑位-_-||</p>
]]></content><link href="https://github.com/srtian/Blog/issues/12" rel="alternate"/><category term="JavaScript"/><published>2020-04-07T07:51:09+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/11</id><title>聊一聊常见的浏览器端数据存储方案</title><updated>2023-03-02T09:44:06.224313+00:00</updated><content type="html"><![CDATA[<h3>前言：</h3>
<p>五一假期在撸代码的时候用到cookie，感觉对浏览器的数据存储方案不是很了解，因此又去翻了两本大头书中间的关于浏览器端数据存储的章节，同时去MDN逛了逛，又看了几篇文章，算是对浏览器的数据存储方案有了一个了解，在此总结一下！</p>
<h2>浏览器存储</h2>
<p>在浏览器端存储数据对我们是很有用，这相当于赋予浏览器记忆的功能，可以纪录用户的所有状态信息，增强用户体验。比如当纪录用户的登陆状态时，可以让用户能够更快的进行访问，而不是每次登陆时都需要去进行繁琐的操作。</p>
<p>总的来说,现在市面上最常见的数据存储方案是以下三种：</p>
<ul>
<li>Cookie</li>
<li>web存储 (locaStorage和seesionStorage)</li>
<li>IndexedDB</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16325ce01e799f9f?w=749&amp;h=356&amp;f=png&amp;s=111928" alt="图片.png" /></p>
<h2>Cookie</h2>
<p>Cookie的又称是HTTP Cookie，最初是在客户端用于存储会话信息，从底层来看，它作为HTTP协议的一种扩展实现，Cookie数据会自动在web浏览器和web服务器之间传输，因此在服务器端脚本就可以读写存储的cookie的值，因此Cookie通常用于存储一些通用的数据，比如用户的登陆状态，首选项等。虽然随着时代的进步，HTML5所提供的web存储机制已经逐步替代了Cookie，但有些较为老的浏览器还是不兼容web存储机制，因此正处于这个老旧更替阶段的我们对于它还是要了解了解的。(比如我这个瓜皮还在用它，2333)</p>
<h3>Cookie的优点</h3>
<p>首先由于操作Cookie的API很早就已经定义和实现了，因此相比于其他的数据存储方式，Cookie的兼容性非常的好，兼容现在市面上所有的主流浏览器，我们在使用它的时候完全不用担心兼容问题。</p>
<h3>Cookie的缺点</h3>
<p>说到Cookie的缺点，那就有点多了，不然也不会在Cookie后面出现web存储等新的数据存储的方案了。
总结起来Cookie的缺点主要是以下几点：</p>
<ol>
<li>存储量小。虽不同浏览器的存储量不同，但基本上都是在4kb左右。</li>
<li>影响性能。由于Cookie会由浏览器作为请求头发送，因此当Cookie存储信息过多时，会影响特定域的资源获取的效率，增加文档传输的负载。</li>
<li>只能储存字符串。</li>
<li>安全问题。存储在Cookie的任何数据可以被他人访问，因此不能在Cookie中储存重要的信息。</li>
<li>由于第三方Cookie的滥用，所以很多老司机在浏览网页时会禁用Cookie，所以我们不得不测试用户是否支持Cookie，这也是很麻烦的一件事。</li>
</ol>
<h3>Cookie的操作</h3>
<p>基本的Cookie操作主要有三个：读取，写入和删除。但在JavaScript中去处理cookie是一件很繁琐的事情，因为cookie中的所有的名字和值都是经过URI编码的，所以当我们必须使用decodeURICompoent来进行解码才能得到cookie的值。我们来看看CookieUtil对象是如何操纵cookie的：</p>
<pre><code class="language-JavaScript">var CookieUtil = {
	// get可根据cookie的名字获取相应的值
	get: function() {
		const cookieName = encodeURIcOMPONET(name) + &quot;=&quot;,
			   cookieStart = document.cookie.indexOf(cookieName),
			   cookieValue = null
		if(cookieStart &gt; -1) {
			const cookieEnd = document.cookie.indexOf(&quot;;&quot;, cookieStart)
			if(cookieEnd == -1) {
				cookieEnd = document.cookie.length
			}
			cookieValue = decodeURICompoent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))	
		}
		return cookieValue
	}
	// set设置一个cookie
	set: function(name, value, expires, path, domain, secure) {
		var cookieText = encodeURIComponet(name)+&quot;=&quot;+encodeURIComponet(value)
		if(expires instanceof Date) {
			cookieText += &quot;; expires=&quot; + expires.toGMTString()
		}
		if(path) {
			cookieText += &quot;;path=&quot; + path
		}
		if(domain) {
			cookieText += &quot;; domain&quot; + domain
		}
		if(secure) {
			cookieText += &quot;; secure&quot;
		}
		document.cookie = cookieText
	}
	// 删除已有的cookie
	unset: function(name, path, domain, secure) {
		this.set(name, &quot;&quot;, new Date(0), path, domain, secure)
	}
}
</code></pre>
<p>是不是很麻烦，无论是获取一个cookie的值或是设置一个cookie都是很麻烦的事情，这也成为了后续的浏览器数据存储方案出现的一大原因。</p>
<h2>web存储</h2>
<p>web存储机制最初作为HTML5的一部分被定义成API的形式，但又由于其本身的独特性与其他的一些原因而剥离了出来，成为独立的一个标准。web存储标准的API包括locaStorage对象和seesionStorage对象。它所产生的主要原因主要出于以下两个原因：</p>
<ul>
<li>人们希望有一种在cookie之外存储回话数据的途径。</li>
<li>人们希望有一种存储大量可以跨会话存在的数据的机制。</li>
</ul>
<p>（注：其实在最初的web存储规范中包含了两种对象的定义：seesionStorage和globalStorage,这两个对象在支持这两个对象的浏览器中都是以windows对象属性的形式存在的）</p>
<h3>locaStorage</h3>
<p>locaStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了我们上面所提到的globalStorage。从功能上来讲，我们可以通过locaStorage在浏览器端存储键值对数据，它相比于cookie而言，提供了更为直观的API，且在安全上相对好一点
，而且虽然locaStorage只能存储字符串，但它也可以存储字符串化的JSON数据，因此相比于cookie，locaStorage能存储更复杂的数据。总的来说相较于cookie，locaStorage有以下优势：</p>
<ul>
<li>提供了简单明了的API来进行操作</li>
<li>更加安全</li>
<li>可储存的数据量更大</li>
</ul>
<p>也正是出于以上这些原因，locaStorage被视为替代cookie的解决方案，但还是要注意不要在locaStorage中存储敏感信息。</p>
<h4>locaStorage的基本语法</h4>
<p>locaStorage的基本操作很简单，示例如下：</p>
<pre><code class="language-JavaScript">// 使用方法存储数据
locaStorage.setItem(&quot;name&quot;, &quot;Srtian&quot;)
// 使用属性存储数据
locaStorage.say = &quot;Hello world&quot;
// 使用方法读取数据
const name = locaStorage.getItem(&quot;name&quot;)
// 使用属性读取数据
const say = locaStorage.say
// 删除数据
locaStorage.removeItem(&quot;name&quot;)
</code></pre>
<p>但需要注意的是，我们上面的示例全是存储字符串格式的数据，当我们需要传输其他格式的数据时，我们就需要将这些数据全部转换为字符串格式，然后再进行存储：</p>
<pre><code class="language-JavaScript">const user = {name:&quot;Srtian&quot;, age: 22}
localStorage.setItem(&quot;user&quot;, JSON.stringify(user))
</code></pre>
<p>当然，我们在获取值的时候也别忘了将其转化回来：</p>
<pre><code class="language-JavaScript">const age = JSON.parse(locaStorage.user)
</code></pre>
<h4>locaStorage储存数据的有效期与作用域</h4>
<p>通过locaStorage存储的数据时永久性的，除非我们使用removeItem来删除或者用户通过设置浏览器配置来删除，负责数据会一直保留在用户的电脑上，永不过期。</p>
<p>locaStorage的作用域限定在文档源级别的（意思就是同源的才能共享），同源的文档间会共享locaStorage的数据，他们可以互相读取对方的数据，甚至有时会覆盖对方的数据。当然，locaStorage的作用域同样也受浏览器的限制。</p>
<h4>locaStorage的兼容</h4>
<p>locaStorage的兼容如下表所示：</p>
<pre><code>    Feature 	Chrome 	Edge 	Firefox (Gecko) Internet Explorer 	Opera 	Safari (WebKit)
localStorage 	4 	(Yes) 	   3.5 	            8 	             10.50     4
sessionStorage 	5 	(Yes) 	   2 	            8 	             10.50 	   4
</code></pre>
<h3>sessionStorage</h3>
<p>sessionStorage是web存储机制的另一大对象，sessionStorage 属性允许我们去访问一个 session Storage 对象。它与 localStorage 相似，不同之处在于 localStorage里面存储的数据没有过期时间设置，而Session Storage只存储当前会话页的数据，且只有当用户关闭当前会话页或浏览器时，数据才会被清除。</p>
<h4>sessionStorage的基本语法</h4>
<p>我们可以通过下面的语法，来保存，获取，删除数据，大体语法与：</p>
<pre><code class="language-JavaScript">// 保存数据到sessionStorage
sessionStorage.setItem(&#x27;name&#x27;, &#x27;Srtian&#x27;);

// 从sessionStorage获取数据
var data = sessionStorage.getItem(&#x27;name&#x27;);

// 从sessionStorage删除保存的数据
sessionStorage.removeItem(&#x27;name&#x27;);

// 从sessionStorage删除所有保存的数据
sessionStorage.clear();
</code></pre>
<p>下面的示例会自动保存一个文本输入框的内容，如果浏览器因偶然因素被刷新了，文本输入框里面的内容会被恢复，写入的内容不会丢失：</p>
<pre><code class="language-JavaScript">// 获取文本输入框
var field = document.getElementById(&quot;field&quot;)

// 检测是否存在 autosave 键值
// (这个会在页面偶然被刷新的情况下存在)
if (sessionStorage.getItem(&quot;autosave&quot;)) {
  // 恢复文本输入框的内容
  field.value = sessionStorage.getItem(&quot;autosave&quot;)
}
// 监听文本输入框的 change 事件
field.addEventListener(&quot;change&quot;, function() {
  // 保存结果到 sessionStorage 对象中
  sessionStorage.setItem(&quot;autosave&quot;, field.value)
})
</code></pre>
<p>在兼容性和优点方面，sessionStorage和locaStorage是差不多的，因此在此也就不多说了，下面我们来聊一聊IndexedDB。</p>
<h2>IndexedDB</h2>
<p>虽然web存储机制对于存储较少量的数据非常便捷好用，但对于存储更大量的结构化数据来说，这种方法就不太满足开发者们的需求了。IndexedDB就是为了应对这个需求而产生的，它是由HTML5所提供的一种本地存储，用于在浏览器中储存较大数据结构的 Web API，并提供索引功能以实现高性能查找。它一般用于保存大量用户数据并要求数据之间有搜索需要的场景，当网络断开时，用户就可以做一些离线的操作。它较之SQL更为方便，不需要写一些特定的语法对数据进行操作，数据格式是JSON。</p>
<h3>IndexedDB的基本语法</h3>
<p>使用IndexedDB在浏览器端存储数据会比上述的其他方法更为复杂。首先，我们需要创建数据库，并指定这个数据库的版本号：</p>
<pre><code class="language-JavaScript">// 注意数据库的版本号只能是整数
const request = IndexedDB.open(databasename, version)
</code></pre>
<p>然后我们需要生成处理函数，需要注意的是onupgradeneeded 是我们唯一可以修改数据库结构的地方。在这里面，我们可以创建和删除对象存储空间以及构建和删除索引。
：</p>
<pre><code class="language-JavaScript">request.onerror = function() {
	// 创建数据库失败时的回调函数
}
request.onsuccess = function() {
	// 创建数据库成功时的回调函数
}
request.onupgradeneededd = function(e) {
	 // 当数据库改变时的回调函数
}

</code></pre>
<p>然后我们就可以建立对象存储空间了，对象存储空间仅调用createObjectStore()就可以创建。这个方法使用存储空间的名称，和一个对象参数。即便这个参数对象是可选的，它还是非常重要的，因为它可以让我们定义重要的可选属性和完善你希望创建的对象存储空间的类型。</p>
<pre><code class="language-JavaScript">request.onupgradeneeded = function(event) {
	const db = event.target.result
	const objectStore = db.createObjectStore(&#x27;name&#x27;, { keyPath:&#x27;id&#x27; })
}
</code></pre>
<p>对象的存储空间我们已经建立好了，接下来我们就可以进行一系列的骚操作了，比如来个蛇皮走位！不不不，口误口误，比如添加数据：</p>
<pre><code class="language-JavaScript">addData: function(db, storename, data) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	for(let i = 0; i &lt; data.length; i++) {
		const request = store.add(data[i])
		request.onerror = function() {
			console.error(&#x27;添加数据失败&#x27;)
		}
		request.onsuccess = function() {
			console.log(&#x27;添加数据成功&#x27;)
		}
	}
}
</code></pre>
<p>如果我们想要修改数据，语法与添加数据差不多，因为重复添加已存在的数据会更新原本的数据，但还是有细小的差别：</p>
<pre><code class="language-JavaScript">putData: function(db, storename, data) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	for(let i = 0; i &lt; data.length; i++) {
		const request = store.put(data[i])
		request.onerror = function() {
			console.error(&#x27;修改数据失败&#x27;)
		}
		request.onsuccess = function() {
			console.log(&#x27;修改数据成功&#x27;)
		}
	}
}
</code></pre>
<p>获取数据：</p>
<pre><code class="language-JavaScript">getDataByKey: function(db, storename, key) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	const request = store.get(key)
	request.onerror = function() {
		console.error(&#x27;获取数据失败&#x27;)
	}
	request.onsuccess = function(e) {
		const result = e.target.result
		console.log(result)
	}
}
</code></pre>
<p>删除数据：</p>
<pre><code class="language-JavaScript">deleteDate: function(db, storename, key) {
	const store = store = db.transaction(storename, &#x27;readwrite&#x27;).objectStore(storename)
	store.delete(key)
	console.log(&#x27;已删除存储空间&#x27; + storename + &#x27;中的&#x27; + key + &#x27;纪录&#x27;)
}
</code></pre>
<p>关闭数据库：</p>
<pre><code>db.close
</code></pre>
<h3>IndexedDB的优点（相较于前面的存储方案）</h3>
<ul>
<li>拥有更大的储存空间</li>
<li>能够处理更为复杂和结构化的数据</li>
<li>拥有更多的交互控制</li>
<li>每个'database'中可以拥有多个'database'和'table'</li>
</ul>
<h3>IndexedDB的局限性</h3>
<p>了解了IndexedDB的优点，我们当然也要来聊一聊IndexedDB的局限性与适用的场景：</p>
<h4>1. 存储空间限制</h4>
<p>一个单独的数据库项目的大小没有限制。然而可能会限制每个 IndexedDB 数据库的大小。这个限制（以及用户界面对它进行断言的方式）在各个浏览器上也可能有所不同：</p>
<ul>
<li>Firefox: 对 IndexedDB 数据库的大小没有限制。在用户界面上只会针对存储超过 50 MB 大小的 BLOB（二进制大对象）请求权限。这个大小的限额可以通过 dom.indexedDB.warningQuota 首选项进行自定义。(定义在 <a href="http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js)%E3%80%82">http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/init/all.js)。</a></li>
<li>Google Chrome：<a href="https://developers.google.com/chrome...rage#temporary">https://developers.google.com/chrome...rage#temporary</a></li>
</ul>
<h4>2. 兼容性问题</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/3/16325ce02ccb3e88?w=1240&amp;h=189&amp;f=png&amp;s=58377" alt="图片.png" />
从上面的图我们可以看出对于IndexedDB的兼容来讲比前面所提及的存储方案要差不少，因此在使用IndexedDB时，我们也要好好的考虑兼容性的问题</p>
<h4>3. indexedDB受同源策略的限制</h4>
<p>indexedDB使用同源原则，这意味着它把存储空间绑定到了创建它的站点的源（典型情况下，就是站点的域或是子域），所以它不能被任何其他源访问。要着重指出的一点是 IndexedDB 不适用于从另一个站点加载进框架的内容 (不管是 <frame> 还是 &lt;iframe>。这是一项安全措施。详情请看这个：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=595307">https://bugzilla.mozilla.org/show_bug.cgi?id=595307</a></p>
<p>除此之外，IndexedDB还存在诸如：不适合存储敏感数据，相较于web存储机制的操作更加复杂等问题，这都是我们在使用IndexedDB时需要考虑的。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/11" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T10:04:17+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/10</id><title>React高阶组件的那些事，了解一下？</title><updated>2023-03-02T09:44:06.386535+00:00</updated><content type="html"><![CDATA[<h4>前言</h4>
<p>学习react已经有一段时间了，期间在阅读官方文档的基础上也看了不少文章，但感觉对很多东西的理解还是不够深刻，因此这段时间又在撸一个基于react全家桶的聊天App（现在还在瞎78写的阶段，在往这个聊天App这个方向写），通过实践倒是对react相关技术栈有了更为深刻的理解，而在使用react-redux的过程中，发现connect好像还挺有意思的，也真实感受到了高阶组件所带来的便利，出于自己写项目本身就是为了学习的目的，因此对高阶组件又进行了一番学习。写下这篇文章主要是对高阶组件的知识进行一个梳理与总结，如有错误疏漏之处，敬请指出，不胜感激。</p>
<h2>初识高阶组件</h2>
<p><em>要学习高阶组件首先我们要知道的就是高阶组件是什么，解决了什么样的问题。</em></p>
<p>React官方文档的对高阶组件的说明是这样的:</p>
<blockquote>
<p>A higher-order component (HOC) is an advanced technique in React for reusing component logic. HOCs are not part of the React API, perse. They are a pattern that emerges from React’s compositional nature.</p>
</blockquote>
<p>从上面的说明我们可以看出，react的高阶组件并不是react API的一部分。它源自于react的生态。</p>
<p>简单来说，一个高阶组件就是一个函数，它接受一个组件作为输入，然后会返回一个新的组件作为结果，且所返回的新组件会进行相对增强。值得注意的是，我们在这说的组件并不是组件实例，而是一个组件类或者一个无状态组件的函数。就像这样：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

function removeUserProp(WrappedComponent) {
//WrappingComponent这个组件名字并不重要，它至少一个局部变量，继承自React.Component
    return class WrappingComponent extends React.Component {
        render() {
// ES6的语法，可以将一个对象的特定字段过滤掉
            const {user, ...otherProps} = this.props
            return &lt;WrappedComponent {...otherProps} /&gt;
        }
      }
}

</code></pre>
<p>了解设计模式的大佬们应该发现了，它其实就是的设计模式中的装饰者模式在react中的应用，它通过组合的方式从而达到很高的灵活程度和复用。
就像上面的代码，我们定义了一个叫做 removeUserProp 的高阶组件，传入一个叫做 WrappedComponent 的参数（代表一个组件类），然后返回一个新的组件 ，新的组件与原组件并没有太大的区别，只是将原组件中的 prop 值 user 给剔除了出来。</p>
<p>有了上面这个高阶组件的，当我们不希望某个组件接收到 user 时，我们就可以将这个组件作为参数传入 removeUserProp() 函数中，然后使用这个返回的组件就行了：</p>
<pre><code class="language-JavaScript">const NewComponent = removeUserProp(OldComponent)
</code></pre>
<p>这样 NewComponent 组件与 OldComponent 组件拥有完全一样的行为，唯一的区别就在于传入的name属性对这个组件没有任何作用，它会自动屏蔽这个属性。也就是说，我们这个高阶组件成功的为传入的组件增加了一个屏蔽某个prop的功能。</p>
<p>那么明白了什么是高阶组件后，我们接下来要做的是，弄清楚高阶组件主要解决的问题，或者说我们为什么需要高阶组件？总结起来主要是以下两个方面：</p>
<ol>
<li>代码重用</li>
</ol>
<blockquote>
<p>在很多情况下，react组件都需要共用同一个逻辑，我们在这个时候就可以把这部分共用的逻辑提取出来，然后利用高阶组件的形式将其组合，从而减少很多重复的组件代码。</p>
</blockquote>
<p>2.修改React组件的行为</p>
<blockquote>
<p>很多时候有些现成的react组件并不是我们自己撸出来的，而是来自于GitHub上的大佬们的开源贡献，而当我们要对这些组件进行复用的时候，我们往往都不想去触碰这些组件的内部逻辑，这时我们就能通过高阶组件产生新的组件满足自身需求，同时也对原组件没有任何损害。</p>
</blockquote>
<p>现在我们对高阶组件有了一个较为直观的认识，知道了什么是高阶组件以及高阶组件的主要用途。接下来我们就要具体了解高阶组件的实现方式以及它的具体用途了。</p>
<h3>高阶组件的实现分类</h3>
<p>对于高阶组件的实现方式我们可以根据作为参数传入的组件与返回的新组件的关系将高阶组件的实现方式分为以下两大类：</p>
<ul>
<li>代理方式的高阶组件</li>
<li>继承方式的高阶组件</li>
</ul>
<h2>代理方式的高阶组件</h2>
<p>从高阶组件的使用频率来讲，我们使用的绝大多数的高阶组件都是代理方式的高阶组件，如react-redux中的connect，还有我们在上面所实现的那个removeUserProp。这类高阶组件的特点是返回的新组件类直接继承于 React.Component 类。新组建在其中扮演的角色是一个传入参数组件的代理，在新组建的render函数中，把被包裹的组件渲染出来。在此过程中，除了高阶组件自己需要做的工作，其他的工作都会交给被包裹的组件去完成。</p>
<p>代理方式的高阶组件具体而言，应用场景可以分为以下几个：</p>
<ul>
<li>操作prop</li>
<li>通过ref获取组件实例</li>
<li>抽取状态</li>
<li>包装组件</li>
</ul>
<h3>控制prop</h3>
<p>代理类型的高阶组件返回的新组件时，渲染过程也会被新组建的render函数所控制，而在此过程中，render函数相对于一个代理，完全决定该如何使用被包裹在其中的组件。在render函数中，this.props包含了新组件接受到的所有prop。因此最直观的用法就是接受到props，然后进行任何读取，增减，修改等控制props的自定义操作。
就比如我们上面的那个示例，就做到了删除prop的功能，当然我们也能实现一个添加prop的高阶组件：</p>
<pre><code class="language-JavaScript">function addNewProp(WrappedComponent, newProps) {
    return class WrappingComponent extends React.Component {
        render() {
          return &lt;WrappedComponent {...thisProps} {...newProps} /&gt;
        }
      }
}
</code></pre>
<p>这个addNewProp高阶组件与我们最开始举例的removeUserProp高阶组件在实现上并无太大的区别。唯一区别较大的就是我们传入的参数除了WrappedComponent组件类外，还新增了newProps参数。这样的高阶组件在复用性方面会跟友好，我们可以利用这样一个高阶组件给不同的组件添加不同的新属性，比如这样：</p>
<pre><code class="language-JavaScript">const FirstComponent = addNewProp(OldComponent,{num: First})
const LastComponent = addNewProp(NewComponent,{num: Last})
</code></pre>
<p>在上面的代码中，我们实现了让两个完全不同的组件分别通过高阶组件生成了两个完成不同的新的组件，而这其中唯一相同的是都添加了一个属性值，且这个属性还不相同。从上面的代码我们也不难发现，高阶组件可以重用在不同组件上，减少了重复的代码。当需要注意的是，在修改和删除 Props的时候，除非由特殊的要求，否则最好不要影响到原本传递给普通组件的 Props。</p>
<h3>通过ref获取组件实例</h3>
<p>我们可以通过ref获取组件实例，但值得注意的是，React官方不提倡访问ref，我们只是讨论一下这个技术的可行性。在此我们写一个refsHOC的高阶组件，可以获得被包裹组件的ref，从而根据ref直接操纵被包裹组件的实例：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

function refsHOC(WrappedComponent) =&gt; {
  return class HOCComponent extends React.Component {
    constructor() {
      super(...arguments)
      this.linkRef = this.linkRef.bind(this)
    }
    linkRef(wrappedInstance) {
      this._root = wrappedInstance
    }
    render() {
      const props = {...this.props, ref: this.linkRef}
      return &lt;WrappedComponent {...props}/&gt;
    }
  }
}

export default refsHOC
</code></pre>
<p>这个refs高阶组件的工作原理其实也是增加传递给被包裹组件的props，不同的是利用了ref这个特殊的prop而已。我们通过linkRef来给被包裹组件传递ref值，linkRef被调用时，我们就可以得到被包裹组件的DOM实例。</p>
<p>这种高阶组件在用途上来讲可以说是无所不能的，因为只要能够获得对被包裹组件的引用，就能通过这个引用任意操纵一个组件的DOM元素，贼酸爽。但它从某个角度来讲也是啥也干不了的，因为react团队表示：<strong>不要过度使用 Refs</strong>。且我们也有更好的替代品——控制组件（Controlled Component)来解决相关问题，因此这个坑建议大家还是尽量少踩为好。</p>
<h3>抽取状态</h3>
<p>对于抽取状态，我想大家应该都不会很陌生。react-redux中的connect函数就实现了这种功能，它异常的强大，也成功吸引了我对高阶组件的注意力。但在这有一点需要明确的是：connect函数本身并不是高阶组件，connect函数执行的结果才是一个高阶组件。让我们来看看connect的源码的主要逻辑：</p>
<pre><code class="language-JavaScript">export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {
    return function wrapWithConnect(WrappedComponent) {
        class Connect extends Component {
            constructor(props, context) {
                //参数获取
                super(props, context)
                this.store = props.store || context.store
                const storeState = this.store.getState()
                this.state = { storeState }
            }
            // 进行判断，当数据发生改变时，Component重新渲染
            shouldComponentUpdate(nextProps, nextState) {
                if (propsChanged || mapStateProducedChange || dispatchPropsChanged) {
                 this.updateState(nextProps)
                  return true
                 }
                }
            // 改变Component中的state
            componentDidMount() {
                 this.store.subscribe(() = {
                  this.setState({
                   storeState: this.store.getState()
                  })
                 })
                }
            render(){
                this.renderedElement = createElement(WrappedComponent,
                    this.mergedProps
                )
                return this.renderedElement
            }
        }
        return hoistStatics(Connect, WrappedComponent)
    }
}
</code></pre>
<p>从上面的代码我们不难看出connect模块的返回值wrapWithConnect是一个函数，而这个函数才是我们所认知的高阶组件。wrapWithConnect函数会返回一个ReactComponent对象Connect，Connect会重新render外部传入的原组件WrappedComponent，并把connect中所传入的mapStateToProps, mapDispatchToProps和this.props合并后结合成一个对象，通过属性的方式传给WrappedComponent，这才是最终的渲染结果。</p>
<h3>包装组件</h3>
<p>在日常开发中我们所接触到的大多数的高阶组件都是通过修改props部分来对输入的组件进行相对增强的。但其实高阶组件还有其他的方式来增强组件，比如我们可以通过在render函数中的JSX引入其他元素，甚至将多个react组件合并起来，来获得更骚气的样式或方法，例如我们可以给组件增加style来改变组件样式：</p>
<pre><code class="language-JavaScript">const styleHOC = (WrappedComponent, style) =&gt; {
    return class HOCComponent extends React.Component {
        render() {
            return (
            &lt;div style={style}&gt;
                &lt;WrappedComponent {...this.props} /&gt;
            &lt;/div&gt;
            )
        }
    }
}
</code></pre>
<p>当我们想改变组件的样式的时候，我们就可以直接调用这个函数，比如这样：</p>
<pre><code class="language-JavaScript">const style = {
			background-color: #f1fafa;
			font-family: &quot;微软雅黑&quot;;
			font-size: 20px;
		}
const BeautifulComponent = styleHOC(uglyComponent, style)
</code></pre>
<h2>继承方式的高阶组件</h2>
<p>前面我们讨论了代理方式实现的高阶组件以及它们的主要使用方式，现在我们继续来讨论一下以继承方式实现的高阶组件。</p>
<p>。继承方式的高阶组件通过继承来关联作为参数传入的组件和返回的组件，比如传入的组件参数是OldComponent,那函数所返回的组件就直接继承于OldComponemt。</p>
<p>码界有句老话说的好：组合优于继承。在高阶组件里也不例外。
继承方式的高阶组件相对于代理方式的高阶组件有很多不足之处，比如输入的组件与输出的组件共有一个生命周期等，因此通常我们接触到的高阶组件大多是代理方式实现的高阶组件，也推荐大家首先考虑以代理方式来实现高阶组件。但我们还是需要去了解并学习它，毕竟它也是有可取之处的，比如在操作生命周期函数上它还是具有其优越性的。</p>
<h3>操作生命周期函数</h3>
<p>说继承方式的高阶组件在操纵生命周期函数上有其优越性其实不够说明它在这个领域的地位，更准确地表达是：操作生命周期函数是继承方式的高阶组件所特有的功能。这是由于继承方式的高阶组件返回的新组件继承于作为参数传入的组件，两个组件的生命周期是共用的，因此可以重新定义组件的生命周期函数并作用于新组件。而代理方式的高阶组件作为参数输入的组件与输出的组件完全是两个生命周期，因此改变生命周期函数也就无从说起了。</p>
<p>例如我们可以定义一个让参数组件只有在用户登录时才显示的高阶组件：</p>
<pre><code class="language-JavaScript">const shouldLoggedInHOC = (WrappedComponent) =&gt; {
    return class MyComponent extends WrappedComponent {
        render() {
            if (this.props.loggedIn) {
                return super.render()
            }
            else {
                return null
            }
        }
    }
}
</code></pre>
<h3>操纵Prop</h3>
<p>除了操作生命周期函数外，继承方式的高阶函数也能对Prop进行操作，但总的难说贼麻烦，当然也有简单的方式，比如这样：</p>
<pre><code class="language-JavaScript">function removeProps(WrappedComponent) {
    return class NewComponent extends WrappedComponent {
        render() {
        const{ user, ...otherProps } = this.props
        this.props = otherProps
        return super.render()
        }
    }
}
</code></pre>
<p>虽然这样看起来很简单，但我们直接修改了this.props，这不是一个好的实践，可能会产生不可预料的后果，更好的操作办法是这样的：</p>
<pre><code class="language-JavaScript">function removeProps(WrappedComponent) {
    return class NewComponent extends WrappedComponent {
        render() {
        const element =super.render()
        const{ user, ...otherProps } = this.props
        this.props = otherProps
        return React.cloneElement(element, this.props, element.props.children)
        }
    }
}
</code></pre>
<p>我们可以通过React.cloneElement来传入新的props，让这些产生的组件重新渲染一次。但虽然这种方式可以解决直接修改this.props所带来的问题，但实现起来贼麻烦，唯一用得上的就是高阶组件需要根据参数组件WrappedComponent渲染结果来决定如何修改props时用得上，其他的时候显然使用代理模式更便捷清晰。</p>
<h2>高阶组件命名</h2>
<p>用 HOC 包裹了一个组件会使它失去原本 WrappedComponent 的名字，可能会影响开发和debug。</p>
<p>因此我们通常会用 WrappedComponent 的名字加上一些 前缀作为 HOC 的名字。我们来看看React-Redux是怎么做的：</p>
<pre><code class="language-JavaScript">function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName ||
         WrappedComponent.name ||
         ‘Component’
}

HOC.displayName = `HOC(${getDisplayName(WrappedComponent)})`
//或
class HOC extends ... {
  static displayName = `HOC(${getDisplayName(WrappedComponent)})`
  ...
}
</code></pre>
<p>实际上我们不用自己来写getDisplayName这个函数，recompose 提供了这个函数，我们只要使用即可。</p>
<h4>结尾语</h4>
<p>我们其他要注意的就是<a href="https://react.bootcss.com/react/docs/higher-order-components.html">官方文档</a>所说的几个约定与相关规范，在此我就不一一赘述了，感兴趣的可以自己去看看。最后很感谢能看到这里的朋友，因为水平有限，如果有错误敬请指正，十分感激！</p>
]]></content><link href="https://github.com/srtian/Blog/issues/10" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T10:00:39+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/9</id><title> 从 HTML5 WebSocket 到 Socket.io</title><updated>2023-03-02T09:44:06.507454+00:00</updated><content type="html"><![CDATA[<h2>HTML5 WebSocket概述</h2>
<p>作为新一代的web标准，HTML5为我们提供了很多有用的东西，比如canvas，本地存储（已经分离出去了），多媒体编程接口，当然还有我们的WebSocket。WebSocket是HTML5开始提供的一种浏览器与服务器间进行全双工通讯（full-duplex）的网络技术，可以传输基于信息的文本和二进制的数据。它于2011年被IETF定为标准 RFC 6455，同时WebSocket API也被W3C定为标准。</p>
<h2>一、WebSocket产生的背景</h2>
<h3>1.黎明前的黑暗——实时web应用的需求</h3>
<p>web应用的信息交互过程我想大家或多或少都知道一些，通常是客户端通过浏览器发出一个请求，然后服务器端在接受和审核请求后,进行处理并将结果返回给客户端，最后由客户端的浏览器将信息呈现出来。这种通信机制在信息交互不是特别频繁的情况下并没有太大的问题，但对于那些实时性要求高、海量数据并发的应用来说，就显得捉襟见肘了，比如现在常见的网页游戏，证券网站，RSS订阅推送，网页实时对话，打车软件等。通常当客户端准备呈现一些信息时，这些信息在服务器端很有可能就已经过时了。为了满足以上那些场景，大佬们研究出来了一些折衷方案，其中最常用的就是普通轮询和Comet技术，而Comet技术实际上就是轮询的改进，细分起来Comet有两种实现方式：</p>
<ul>
<li>长轮询机制</li>
<li>流技术机制</li>
</ul>
<h4>1.1 长轮询机制</h4>
<p>长轮序是对普通轮询的改进和提高。普通轮询简单来说，就是客户端每隔一定的时间就向服务器端发送请求，从而以频繁请求的方式来保持客户端和服务器端的同步。这种同步方案的最大问题是，客户端已固定的频率发送请求时，很可能服务端的数据没有更新，产生很多无用的网络传输，非常低效。</p>
<p>为了减少无效的网络传输，长轮询对普通轮询进行了改进和提高，当服务器端没有数据更新时，链接会保持一段时间的周期，直到数据或状态发生改变或连接时间过期，通过这种机制我们就可以减少很多无效的客户端和服务器间的交互。当然，如果服务器端的数据变更非常频繁的话，这种机制并没有有效的提高性能，和普通轮询没有太大的区别，且长轮询也会耗费更多的资源，比如CPU,内存,带宽等。</p>
<h4>1.2 流技术机制</h4>
<p>流技术机制简单来说就是客户端的页面使用一个隐藏的窗口向服务端发出一个长连接的请求。服务器接到请求后作出回应，并不断更新状态，以保证客户端和服务器端的连接不过期。通过这种机制就可以将服务器端的信息不断传向客户端，从而保证信息的时效性。但这种机制对于用户体验并不友好，需要针对不同的浏览器升级不同的方案来改进用户体验，同时这种机制如果在并发情况下发生时，会对服务器的资源造成很大压力。</p>
<h3>2.黎明的到来——WebSocket</h3>
<p>正是出于以上几种解决方案都有着各自的局限性,HTML5 WebSocket也就应运而生了，浏览器可以通过JavaScript借助现有的HTTP协议来向服务器发出WebSocket连接的请求，当连接建立后，客户端和服务器端就可以直接通过TCP连接来直接进行数据交换。这是由于websocket协议本质上就是一个TCP连接，所以在数据传输的稳定性和传输量上有所保证，且相对于以往的轮询和Comet技术在性能方面也有了长足的进步：
<img src="https://user-gold-cdn.xitu.io/2018/5/11/1634ea2e300a0c6f?w=504&amp;h=360&amp;f=jpeg&amp;s=17994" alt="image" /></p>
<p>有一点需要注意的是虽然websocket在通信时需要借助HTTP，但它本质上和HTTP有着很大的区别：</p>
<ul>
<li>WebSocket是一种双向通信协议，在建立连接之后，WebSocket服务端和客户端都能主动向对方发送或者接受数据。</li>
<li>WebSocket需要先连接，只有再连接后才能进行相互通信。</li>
</ul>
<p>他们的关系其实就和这张图表现的一样，虽然有相交的部分，但依然有着很大的区别：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634ea2e0ed4878d?w=374&amp;h=133&amp;f=jpeg&amp;s=9144" alt="image" /></p>
<h2>二、WebSocket API的用法</h2>
<p>由于每个服务器端的语言都有着自己的API，因此首先我们来讨论客户端的API：</p>
<pre><code class="language-JavaScript">// 创建一个socket实例：
const socket = new WebSocket(ws://localhost:9093&#x27;)
// 打开socket
socket.onopen = (event) =&gt; {
    // 发送一个初始化消息
  	socket.send(&#x27;Hello Server!&#x27;)
  	 // 服务器有响应数据触发
    socket.onmessage = (event) =&gt; { 
        console.log(&#x27;Client received a message&#x27;,event)
    }
    // 出错时触发，并且会关闭连接。这时可以根据错误信息进行按需处理
    socket.onerror = (event) =&gt; {
  	    console.log(&#x27;error&#x27;)
    }
    // 监听Socket的关闭
    socket.onclose = (event) =&gt; { 
        console.log(&#x27;Client notified socket has closed&#x27;,event)
    }
    // 关闭Socket
    socket.close(1000, &#x27;closing normally&#x27;) 
 }
</code></pre>
<p>是不是感觉HTML5 websocket所提供的API贼鸡儿简单，没错，就是这么简单。但有几点我们需要注意：</p>
<ul>
<li>在创建socket实例的时候，new WebSocket()接受两个参数，第一个参数是ws或wss,第二个参数可以选填自定义协议，如果是多协议，可以是数组的方式。</li>
<li>WebSocket中的send方法不是任何数据都能发送的，现在只能发送三类数据，包括UTF-8的string类型（会默认转化为USVString），ArrayBuffer和Blob，且只有在建立连接后才能使用。（感谢大佬指出错误，已修改）</li>
<li>在使用socket.close(code,[reason])关闭连接时，code和reason都是选填的。code是一个数字值表示关闭连接的状态号，表示连接被关闭的原因。如果这个参数没有被指定，默认的取值是1000 （表示正常连接关闭）,而reason是一个可读的字符串，表示连接被关闭的原因。这个字符串必须是不长于123字节的UTF-8 文本。</li>
</ul>
<h3>1.ws和wss</h3>
<p>我们在上面提到过，创建一个socket实例时可以选填ws和wss来进行通信协议的确定。他们两个其实很像HTTP和HTTPS之间的关系。其中ws表示纯文本通信，而wss表示使用加密信道通信（TCP+TLS）。那为啥不直接使用HTTP而要自定义通信协议呢？这就要从WebSocket的目的说起来，WebSocket的主要功能就是为了给浏览器中的应用与服务器端提供优化的，双向的通信机制，但这不代表WebScoket只能局限于此，它当然还能够用于其他的场景，这就需要他可以通过非HTTP协议来进行数据交换，因此WebSocket也就采用了自定义URI模式，以确保就算没有HTTP，也能进行数据交换。</p>
<p>ws和wss：</p>
<ul>
<li><strong>ws协议</strong>：普通请求，占用与HTTP相同的80端口</li>
<li><strong>wss协议</strong>：基于SSL的安全传输，占用与TLS相同的443端口。</li>
</ul>
<p>注：有些HTTP中间设备有时候可能会不理解WebSocket，而导致各种诸如：盲目连接升级，乱修改内容等问题。而WSS就很好的解决了这个问题，它建立了一台哦端到端的安全通道，这个通道对中间设备模糊了数据，因此中间设备就不能感知到数据，也就无法对请求做一些特殊处理了。</p>
<h2>三、WebSocket协议的规范</h2>
<p>以下是一个典型的WebSocket发起请求到响应请求的示例：</p>
<pre><code>客户端到服务端：
GET / HTTP/1.1
Connection:Upgrade
Host:127.0.0.1:8088
Origin:null
Sec-WebSocket-Extensions:x-webkit-deflate-frame
Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==
Sec-WebSocket-Version:13
Upgrade:websocket

服务端到客户端：
HTTP/1.1 101 Switching Protocols
Connection:Upgrade
Server:beetle websocket server
Upgrade:WebSocket
date: Thu, 10 May 2018 07:32:25 GMT
Access-Control-Allow-Credentials:true
Access-Control-Allow-Headers:content-type
Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=
</code></pre>
<p>我们可以看到，WebSocket协议和HTTP协议乍看并没有太大的区别，但细看下来，区别还是有些的，这其实是一个握手的http请求，首先请求和响应的，”Upgrade:WebSocket”表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket协议。从客户端到服务器端请求的信息里包含有”Sec-WebSocket-Extensions”、“Sec-WebSocket-Key”这样的头信息。这是客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息，并在握手的过程中依据这些信息生成一个28位的安全密钥并返回给客户端，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。</p>
<p>当握手成功后，这个时候TCP连接就已经建立了，客户端与服务端就能够直接通过WebSocket直接进行数据传递。不过服务端还需要判断一次数据请求是什么时候开始的和什么时候是请求的结束的。在WebSocket中，由于浏览端和服务端已经打好招呼，如我发送的内容为utf-8 编码，如果我发送0x00,表示包的开始，如果发送了0xFF，就表示包的结束了。这就解决了黏包的问题。</p>
<h2>四、兼容性情况</h2>
<pre><code>浏览器	                 支持情况
Chrome	            Supported in version 4+
Firefox	            Supported in version 4+
Internet Explorer	Supported in version 10+
Opera	            Supported in version 10+
Safari	            Supported in version 5+
</code></pre>
<h2>五、Socket.IO</h2>
<p>简单来说Socket.IO就是对WebSocket的封装，并且实现了WebSocket的服务端代码。Socket.IO将WebSocket和轮询（Polling）机制以及其它的实时通信方式封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。也就是说，WebSocket仅仅是Socket.IO实现实时通信的一个子集。Socket.IO简化了WebSocket API，统一了返回传输的API。传输种类包括：</p>
<ul>
<li>WebSocket</li>
<li>Flash Socket</li>
<li>AJAX long-polling</li>
<li>AJAX multipart streaming</li>
<li>IFrame</li>
<li>JSONP polling。</li>
</ul>
<p>我们来看一下服务端的Socket.IO基本API：</p>
<pre><code class="language-JavaScript">// 引入socke.io
const io = require(&#x27;socket.io&#x27;)(80)
// 监听客户端连接,回调函数会传递本次连接的socket
io.on(&#x27;connection&#x27;,function(socket))
// 给所有客户端广播消息
io.sockets.emit(&#x27;String&#x27;,data)
// 给指定的客户端发送消息
io.sockets.socket(socketid).emit(&#x27;String&#x27;, data)
// 监听客户端发送的信息
socket.on(&#x27;String&#x27;,function(data))
// 给该socket的客户端发送消息
socket.emit(&#x27;String&#x27;, data)
</code></pre>
<p>另外，Socket.IO还提供了一个Node.JS API，它看起来很像客户端API。所以我们来看看它的实际应用吧：</p>
<pre><code class="language-JavaScript">// socket-server.js

// 需要使用HTTP模块来启动服务器和Socket.IO
const http= require(&#x27;http&#x27;), 
const io= require(&#x27;socket.io&#x27;)

const server= http.createServer(function(req, res){ 
    // 发送HTML的headers和message
    res.writeHead(200,{ &#x27;Content-Type&#x27;: &#x27;text/html&#x27; })
    res.end(&#x27;&lt;p&gt;Hello Socket.IO!&lt;p&gt;&#x27;)
}); 
// 在8080端口启动服务器
server.listen(8080)

// 创建一个Socket.IO实例，并把它传递给服务器
const socket= io.listen(server)

// 添加一个连接监听器
socket.on(&#x27;connection&#x27;, function(client) { 

// 连接成功，开始监听
client.on(&#x27;message&#x27;,function(event){ 
    console.log(&#x27;Received message from client!&#x27;,event)
})
// 连接失败
client.on(&#x27;disconnect&#x27;,function(){ 
    clearInterval(interval)
    console.log(&#x27;Server has disconnected&#x27;)
  })
})
</code></pre>
<p>然后我们就可以启动这个文件了：</p>
<pre><code>node socket-server.js
</code></pre>
<p>然后我们就可以创建一个每秒钟发送消息到客户端的发送器了；</p>
<pre><code class="language-JavaScript">var interval= setInterval(function() { 
  client.send(&#x27;This is a message from the server,hello world&#x27; + new Date().getTime()); 
},1000);
</code></pre>
<hr />
<p>注：需要注意的是，如果我们想在前端使用socket.IO,我们需要下载这个：</p>
<pre><code>npm install socket.io-client --save
</code></pre>
<p>然后再连接网络：</p>
<pre><code class="language-JavaScript">import io from &#x27;socket.io-client&#x27;
const socket = io(&#x27;ws://localhost:8080&#x27;)
</code></pre>
]]></content><link href="https://github.com/srtian/Blog/issues/9" rel="alternate"/><category term="FE"/><category term="Web"/><category term="JavaScript"/><published>2019-09-28T09:59:23+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/8</id><title>Redux 源码解读</title><updated>2023-03-02T09:44:06.616997+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>作为React全家桶的一份子，Redux为react提供了严谨周密的状态管理。但Redux本身是有点难度的，虽然学习了React也有一段时间了，自我感觉算是入了门，也知道redux的大概流程。但其背后诸如creatstore,applymiddleware等API背后到底发生了什么事情，我其实还是不怎么了解的，因此最近花了几天时间阅读了Redux的源码，写下文章纪录一下自己看源码的一些理解。（redux4.0版本）</p>
<h3>一、源码结构</h3>
<p>Redux是出了名的短小精悍（恩，这个形容很贴切），只有2kb大小，且没有任何依赖。它将所有的脏活累活都交给了中间件去处理，自己保持着很好的纯洁性。再加上redux作者在redux的源码上，也附加了大量的注释，因此redux的源码读起来还是不算难的。</p>
<p>先来看看redux的源码结构，也就是src目录下的代码：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/3/163c618640a812c8?w=309&amp;h=366&amp;f=png&amp;s=17704" alt="源码结构" title="Redux源码结构图.PNG" /></p>
<p>其中utils是工具函数，主要是作为辅助几个核心API，因此不作讨论。
（注：由于篇幅的问题，下面代码很多都删除了官方注释，和较长的warn）</p>
<h3>二、具体组成</h3>
<p>index.js是redux的入口函数具体代码如下：</p>
<h4>2.1 index.js</h4>
<pre><code class="language-JavaScript">import createStore from &#x27;./createStore&#x27;
import combineReducers from &#x27;./combineReducers&#x27;
import bindActionCreators from &#x27;./bindActionCreators&#x27;
import applyMiddleware from &#x27;./applyMiddleware&#x27;
import compose from &#x27;./compose&#x27;
import warning from &#x27;./utils/warning&#x27;
import __DO_NOT_USE__ActionTypes from &#x27;./utils/actionTypes&#x27;

function isCrushed() {}
if (
  process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp;
  typeof isCrushed.name === &#x27;string&#x27; &amp;&amp;
  isCrushed.name !== &#x27;isCrushed&#x27;
) {
  warning(
  )
}

export {
  createStore,
  combineReducers,
  bindActionCreators,
  applyMiddleware,
  compose,
  __DO_NOT_USE__ActionTypes
}
</code></pre>
<p>其中isCrushed函数是用于验证在非生产环境下 Redux 是否被压缩，如果被压缩就会给开发者一个 warn 的提示。</p>
<p>在最后index.js 会暴露 createStore, combineReducers, bindActionCreators, applyMiddleware, compose 这几个redux最主要的API以供大家使用。</p>
<h4>2.2 creatStore</h4>
<p>createStore函数接受三个参数：</p>
<ul>
<li>reducer：是一个函数，返回下一个状态，接受两个参数：当前状态 和 触发的 action；</li>
<li>preloadedState：初始状态对象，可以很随意指定，比如服务端渲染的初始状态，但是如果使用 combineReducers 来生成 reducer，那必须保持状态对象的 key 和 combineReducers 中的 key 相对应；</li>
<li>enhancer：是store 的增强器函数，可以指定为中间件，持久化 等，但是这个函数只能用 Redux 提供的 applyMiddleware 函数来进行生成</li>
</ul>
<p>下面就是creactStore的源码，由于整体源码过长，且 subscribe 和 dispatch 函数也挺长的，所以就将 subscribe 和 dispatch 单独提出来细讲。</p>
<pre><code class="language-JavaScript"> import $$observable from &#x27;symbol-observable&#x27;

import ActionTypes from &#x27;./utils/actionTypes&#x27;
import isPlainObject from &#x27;./utils/isPlainObject&#x27;

export default function createStore(reducer, preloadedState, enhancer) {
  if (typeof preloadedState === &#x27;function&#x27; &amp;&amp; typeof enhancer === &#x27;undefined&#x27;) {
    enhancer = preloadedState
    preloadedState = undefined
  }
  // enhancer应该为一个函数
  if (typeof enhancer !== &#x27;undefined&#x27;) {
    if (typeof enhancer !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the enhancer to be a function.&#x27;)
    }
    //enhancer 接受 createStore 作为参数，对  createStore 的能力进行增强，并返回增强后的  createStore 。
    //  然后再将  reducer 和  preloadedState 作为参数传给增强后的  createStore ，最终得到生成的 store
    return enhancer(createStore)(reducer, preloadedState)
  }
  // reducer必须是函数
  if (typeof reducer !== &#x27;function&#x27;) {
    throw new Error(&#x27;Expected the reducer to be a function.&#x27;)
  }

 // 初始化参数
  let currentReducer = reducer   // 当前整个reducer
  let currentState = preloadedState   // 当前的state,也就是getState返回的值
  let currentListeners = []  // 当前的订阅store的监听器
  let nextListeners = currentListeners // 下一次的订阅
  let isDispatching = false // 是否处于 dispatch action 状态中, 默认为false

  // 这个函数用于确保currentListeners 和 nextListeners 是不同的引用
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }

  // 返回state
  function getState() {
    if (isDispatching) {
      throw new Error(
        ......
      )
    }
    return currentState
  }

  // 添加订阅
  function subscribe(listener) {
  ......
    }
  }
// 分发action
  function dispatch(action) {
    ......
  }

  //这个函数主要用于 reducer 的热替换，用的少
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the nextReducer to be a function.&#x27;)
    }
    // 替换reducer
    currentReducer = nextReducer
    // 重新进行初始化
    dispatch({ type: ActionTypes.REPLACE })
  }

  // 没有研究，暂且放着，它是不直接暴露给开发者的，提供了给其他一些像观察者模式库的交互操作。
  function observable() {
    ......
  }

  // 创建一个store时的默认state
  // 用于填充初始的状态树
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}

</code></pre>
<h5>subscribe</h5>
<pre><code class="language-JavaScript">function subscribe(listener) {
    if (typeof listener !== &#x27;function&#x27;) {
      throw new Error(&#x27;Expected the listener to be a function.&#x27;)
    }

    if (isDispatching) {
      throw new Error(
        ......
      )
    }

    let isSubscribed = true
    // 如果 nextListeners 和 currentListeners 是一个引用，重新复制一个新的
    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      if (isDispatching) {
        throw new Error(
          .......
        )
      }
      
      isSubscribed = false
      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      // 从nextListeners里面删除，会在下次dispatch生效
      nextListeners.splice(index, 1)
    }
  }
</code></pre>
<p>有时候有些人会觉得store.subscribe用的很少,其实不然，是react-redux隐式的为我们帮我们完成了这方面的工作。subscribe函数可以给 store 的状态添加订阅监听，一旦我们调用了 dispatch来分发action ，所有的监听函数就会执行。而 nextListeners 就是储存当前监听函数的列表，当调用 subscribe，传入一个函数作为参数时，就会给 nextListeners 列表 push 这个函数。同时调用 subscribe 函数会返回一个 unsubscribe 函数，用来解绑当前传入的函数，同时在 subscribe 函数定义了一个 isSubscribed 标志变量来判断当前的订阅是否已经被解绑，解绑的操作就是从 nextListeners 列表中删除当前的监听函数。</p>
<h5>dispatch</h5>
<p>dispatch是redux中一个非常核心的方法，也是我们在日常开发中最常用的方法之一。dispatch函数是用来触发状态改变的，他接受一个 action 对象作为参数，然后 reducer 就可以根据 action 的属性以及当前 store 的状态，来生成一个新的状态，从而改变 store 的状态；</p>
<pre><code class="language-JavaScript">function dispatch(action) {
    // action 必须是一个对象
    if (!isPlainObject(action)) {
      throw new Error(
        ......
      )
    }
    // type必须要有属性，不能是undefined
    if (typeof action.type === &#x27;undefined&#x27;) {
      throw new Error(
        ......
      )
    }
    // 禁止在reducers中进行dispatch，因为这样做可能导致分发死循环，同时也增加了数据流动的复杂度
    if (isDispatching) {
      throw new Error(&#x27;Reducers may not dispatch actions.&#x27;)
    }

    try {
      isDispatching = true
//       当前的状态和 action 传给当前的reducer，用于生成最新的 state
      currentState = currentReducer(currentState, action)
    } finally {  
      // 派发完毕
      isDispatching = false
    }
    // 将nextListeners交给listeners
    const listeners = (currentListeners = nextListeners)
    // 在得到新的状态后，依次调用所有的监听器，通知状态的变更
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }
    return action
  }
</code></pre>
<p>其中 currentState = currentReducer(currentState, action);这里的 currentReducer 是一个函数，他接受两个参数：</p>
<ul>
<li>当前状态</li>
<li>action</li>
</ul>
<p>然后返回计算出来的新的状态。</p>
<h4>2.3 compose.js</h4>
<p>compose 可以接受一组函数参数，从右到左来组合多个函数，然后返回一个组合函数。它的源码并不长，但设计的十分巧妙：</p>
<pre><code class="language-javascript">
export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre>
<p>compose函数的作用其实其源码的注释里讲的很清楚了，比如下面这样：</p>
<pre><code class="language-JavaScript">compose(funcA, funcB, funcC)
</code></pre>
<p>其实它与这样是等价的：</p>
<pre><code class="language-JavaScript">compose(funcA(funcB(funcC())))
</code></pre>
<p>ompose 做的只是让我们在写深度嵌套的函数时，避免了代码的向右偏移。</p>
<h4>2.4 applyMiddleware</h4>
<p>applyMiddleware也是redux中非常重要的一个函数，设计的也非常巧妙，让人叹为观止。</p>
<pre><code class="language-JavaScript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    // 利用传入的createStore和reducer和创建一个store
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        `Dispatching while constructing your middleware is not allowed. ` +
          `Other middleware would not be applied to this dispatch.`
      )
    }
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>通过上面的代码，我们可以看出 applyMiddleware 是个三级<strong>柯里化</strong>的函数。它将陆续的获得三个参数：第一个是 middlewares 数组，第二个是 Redux 原生的 createStore，最后一个是 reducer，也就是上面的...args；</p>
<p>applyMiddleware 利用 createStore 和 reducer 创建了一个 store，然后 store 的 getState 方法和 dispatch 方法又分别被直接和间接地赋值给 middlewareAPI 变量。</p>
<p>其中这一句我感觉是最核心的：</p>
<pre><code>dispatch = compose(...chain)(store.dispatch)
</code></pre>
<p>我特意将compose与applyMiddleware放在一块，就是为了解释这段代码。因此上面那段核心代码中，本质上就是这样的(假设...chain有三个函数)：</p>
<pre><code>dispatch = f1(f2(f3(store.dispatch))))
</code></pre>
<h4>2.5 combineReducers</h4>
<p>combineReducers 这个辅助函数的作用就是，将一个由多个不同 reducer 函数作为 value 的 object合并成一个最终的 reducer 函数，然后我们就可以对这个 reducer 调用 createStore 方法了。这在createStore的源码的注释中也有提到过。</p>
<p>并且合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。 由 combineReducers() 返回的 state 对象，会将传入的每个 reducer 返回的 state 按其传递给 combineReducers() 时对应的 key 进行命名。</p>
<p>下面我们来看源码，下面的源码删除了一些的检查判断，只保留最主要的源码：</p>
<pre><code class="language-JavaScript">export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  // 有效的 reducer 列表
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]
  const finalReducerKeys = Object.keys(finalReducers)

// 返回最终生成的 reducer
  return function combination(state = {}, action) {
    let hasChanged = false
    //定义新的nextState
    const nextState = {}
    // 1，遍历reducers对象中的有效key，
    // 2，执行该key对应的value函数，即子reducer函数，并得到对应的state对象
    // 3，将新的子state挂到新的nextState对象上，而key不变
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
     // 遍历一遍看是否发生改变，发生改变了返回新的state，否则返回原先的state
    return hasChanged ? nextState : state
  }
}
</code></pre>
<h4>2.6 bindActionCreators</h4>
<p>bindActionCreators可以把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。
bindActionCreators函数并不常用（反正我还没有怎么用过），惟一会使用到 bindActionCreators 的场景就是我们需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，并且不希望把 dispatch 或 Redux store 传给它。</p>
<pre><code class="language-JavaScript">// 核心代码，并通过apply将this绑定起来
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments))
  }
} 
// 这个函数只是把actionCreators这个对象里面包含的每一个actionCreator按照原来的key的方式全部都封装了一遍，核心代码还是上面的
export default function bindActionCreators(actionCreators, dispatch) {
  // 如果actionCreators是一个函数，则说明只有一个actionCreator，就直接调用bindActionCreator
  if (typeof actionCreators === &#x27;function&#x27;) {
    return bindActionCreator(actionCreators, dispatch)
  }
  // 如果是actionCreator是对象或者null的话，就会报错
  if (typeof actionCreators !== &#x27;object&#x27; || actionCreators === null) {
    throw new Error(
    ... ... 
  }
 // 遍历对象，然后对每个遍历项的 actionCreator 生成函数，将函数按照原来的 key 值放到一个对象中，最后返回这个对象
  const keys = Object.keys(actionCreators)
  const boundActionCreators = {}
  for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &#x27;function&#x27;) {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}
</code></pre>
<h3>小节</h3>
<p>看一遍redux，感觉设计十分巧秒，不愧是大佬的作品。这次看代码只是初看，往后随着自己学习的不断深入，还需多加研究，绝对还能得到更多的体会。</p>
]]></content><link href="https://github.com/srtian/Blog/issues/8" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:58:06+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/7</id><title>深入理解 Redux 中间件——走马观花</title><updated>2023-03-02T09:44:06.746224+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>最近几天对 redux 的中间件进行了一番梳理，又看了 redux-saga 的文档，和 redux-thunk 和 redux-promise 的源码，结合前段时间看的redux的源码的一些思考，感觉对 redux 中间件的有了更加深刻的认识，因此总结一下。</p>
<h3>一、Redux中间件机制</h3>
<p>Redux本身就提供了非常强大的数据流管理功能，但这并不是它唯一的强大之处，它还提供了利用中间件来扩展自身功能，以满足用户的开发需求。首先我们来看中间件的定义：</p>
<blockquote>
<p>It provides a third-party extension point between dispatching an action, and the moment it reaches
the reducer.</p>
</blockquote>
<p>这是Dan Abramov 对 middleware 的描述。简单来讲，Redux middleware 提供了一个分类处理 action 的机会。在 middleware 中，我们可以检阅每一个流过的 action,并挑选出特定类型的 action 进行相应操作，以此来改变 action。这样说起来可能会有点抽象，我们直接来看图，这是在没有中间件情况下的 redux 的数据流：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f39b787c?w=1269&amp;h=157&amp;f=png&amp;s=16392" alt="输入图片说明" title="redux.png" /></p>
<p>上面是很典型的一次 redux 的数据流的过程，但在增加了 middleware 后，我们就可以在这途中对 action 进行截获，并进行改变。且由于业务场景的多样性，单纯的修改 dispatch 和 reduce 显然不能满足大家的需要，因此对 redux middleware 的设计理念是可以自由组合，自由插拔的插件机制。也正是由于这个机制，我们在使用 middleware 时，我们可以通过串联不同的 middleware 来满足日常的开发需求，每一个 middleware 都可以处理一个相对独立的业务需求且相互串联：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f54070ae?w=1279&amp;h=239&amp;f=png&amp;s=27633" alt="image" /></p>
<p>如上图所示，派发给 redux Store 的 action 对象，会被 Store 上的多个中间件依次处理，如果把 action 和当前的 state 交给 reducer 处理的过程看做默认存在的中间件，那么其实所有的对 action 的处理都可以有中间件组成的。值得注意的是这些中间件会按照指定的顺序依次处理传入的 action，只有排在前面的中间件完成任务后，后面的中间件才有机会继续处理 action，同样的，每个中间件都有自己的“熔断”处理,当它认为这个 action 不需要后面的中间件进行处理时，后面的中间件就不能再对这个 action 进行处理了。</p>
<p>而不同的中间件之所以可以组合使用，是因为 Redux 要求所有的中间件必须提供统一的接口，每个中间件的尉氏县逻辑虽然不一样，但只要遵循统一的接口就能和redux以及其他的中间件对话了。</p>
<h3>二、理解中间价的机制</h3>
<p>由于redux 提供了 applyMiddleware 方法来加载 middleware，因此我们首先可以看一下 redux 中关于 applyMiddleware 的源码：</p>
<pre><code class="language-JavaScript">export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    // 利用传入的createStore和reducer和创建一个store
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
      )
    }
    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }
    // 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    // 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch
    dispatch = compose(...chain)(store.dispatch)
    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>我们可以看到applyMiddleware的源码非常简单，但却非常精彩，具体的解读可以看我的这篇文章：
<a href="http://srtian96.gitee.io/blog/2018/06/02/%E8%A7%A3%E8%AF%BBRedux%E6%BA%90%E7%A0%81/">redux源码解读</a></p>
<p>从上面的代码我们不难看出，applyMiddleware 这个函数的核心就在于在于组合 compose，通过将不同的 middlewares 一层一层包裹到原生的 dispatch 之上，然后对 middleware 的设计采用柯里化的方式，以便于compose ，从而可以动态产生 next 方法以及保持 store 的一致性。</p>
<p>说起来可能有点绕，直接来看一个啥都不干的中间件是如何实现的：</p>
<pre><code class="language-JavaScript">const doNothingMidddleware = (dispatch, getState) =&gt; next =&gt; action =&gt; next(action)
</code></pre>
<p>上面这个函数接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数，但需要注意的是并不是所有的中间件都会用到这两个函数。然后 doNothingMidddleware 返回的函数接受一个 next 类型的参数，这个 next 是一个函数，如果调用了它，就代表着这个中间件完成了自己的职能，并将对 action 控制权交予下一个中间件。但需要注意的是，这个函数还不是处理 action 对象的函数，它所返回的那个以 action 为参数的函数才是。最后以 action 为参数的函数对传入的 action 对象进行处理，在这个地方可以进行操作，比如：</p>
<ul>
<li>调动dispatch派发一个新 action 对象</li>
<li>调用 getState 获得当前 Redux Store 上的状态</li>
<li>调用 next 告诉 Redux 当前中间件工作完毕，让 Redux 调用下一个中间件</li>
<li>访问 action 对象 action 上的所有数据</li>
</ul>
<p>在具有上面这些功能后，一个中间件就足够获取 Store 上的所有信息，也具有足够能力可用之数据的流转。看完上面这个最简单的中间件，下面我们来看一下 redux 中间件内，最出名的中间件 redux-thunk 的实现：</p>
<pre><code class="language-JavaScript">function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
    if (typeof action === &#x27;function&#x27;) {
      return action(dispatch, getState, extraArgument);
    }
    return next(action);
  };
}
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
export default thunk;
</code></pre>
<p>redux-thunk的代码很简单，它通过函数是变成的思想来设计的，它让每个函数的功能都尽可能的小，然后通过函数的嵌套组合来实现复杂的功能，我上面写的那个最简单的中间件也是如此（当然，那是个瓜皮中间件）。redux-thunk 中间件的功能也很简单。首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action 。</p>
<p>需要注意的是，每个中间件最里层处理 action 参数的函数返回值都会影响 Store 上的 dispatch 函数的返回值，但每个中间件中这个函数返回值可能都不一样。就比如上面这个 react-thunk 中间件，返回的可能是一个 action 函数，也有可能返回的是下一个中间件返回的结果。因此，dispatch 函数调用的返回结果通常是不可控的，我们最好不要依赖于 dispatch 函数的返回值。</p>
<h3>三、redux的异步流</h3>
<p>在多种中间件中，处理 redux 异步事件的中间件，绝对占有举足轻重的地位。从简单的 react-thunk 到 redux-promise 再到 redux-saga等等，都代表这各自解决redux异步流管理问题的方案</p>
<h4>3.1 redux-thunk</h4>
<p>前面我们已经对redux-thunk进行了讨论，它通过多参数的 currying 以实现对函数的惰性求值，从而将同步的 action 转为异步的 action。在理解了redux-thunk后，我们在实现数据请求时，action就可以这么写了：</p>
<pre><code class="language-JavaScript">function getWeather(url, params) {
    return (dispatch, getState) =&gt; {
        fetch(url, params)
            .then(result =&gt; {
                dispatch({
                    type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: result,
                });
            })
            .catch(err =&gt; {
                dispatch({
                    type: &#x27;GET_WEATHER_ERROR&#x27;, error: err,
                });
            });
        };
}
</code></pre>
<p>尽管redux-thunk很简单，而且也很实用，但人总是有追求的，都追求着使用更加优雅的方法来实现redux异步流的控制，这就有了redux-promise。</p>
<h4>3.2 redux-promise</h4>
<p>不同的中间件都有着自己的适用场景，react-thunk 比较适合于简单的API请求的场景，而 Promise 则更适合于输入输出操作，比较fetch函数返回的结果就是一个Promise对象，下面就让我们来看下最简单的 Promise 对象是怎么实现的：</p>
<pre><code class="language-JavaScript">import { isFSA } from &#x27;flux-standard-action&#x27;;

function isPromise(val) {
  return val &amp;&amp; typeof val.then === &#x27;function&#x27;;
}

export default function promiseMiddleware({ dispatch }) {
  return next =&gt; action =&gt; {
    if (!isFSA(action)) {
      return isPromise(action)
        ? action.then(dispatch)
        : next(action);
    }

    return isPromise(action.payload)
      ? action.payload.then(
          result =&gt; dispatch({ ...action, payload: result }),
          error =&gt; {
            dispatch({ ...action, payload: error, error: true });
            return Promise.reject(error);
          }
        )
      : next(action);
  };
}
</code></pre>
<p>它的逻辑也很简单主要是下面两部分：</p>
<ol>
<li>先判断是不是标准的 flux action。如果不是，那么判断是否是 promise, 是的话就执行 action.then(dispatch)，否则执行 next(action)。</li>
<li>如果是, 就先判断 payload 是否是 promise，如果是的话 payload.then 获取数据，然后把数据作为 payload 重新 dispatch({ ...action, payload: result}) ；不是的话就执行 next(action)</li>
</ol>
<p>结合 redux-promise 我们就可以利用 es7 的 async 和 await 语法，来简化异步操作了，比如这样：</p>
<pre><code class="language-JavaScript">const fetchData = (url, params) =&gt; fetch(url, params)
async function getWeather(url, params) {
    const result = await fetchData(url, params)
    if (result.error) {
        return {
            type: &#x27;GET_WEATHER_ERROR&#x27;, error: result.error,
        }
    }
        return {
            type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: result,
        }
    }
</code></pre>
<h4>3.3 redux-saga</h4>
<p>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。对于Saga，我们可简单定义如下：</p>
<blockquote>
<p>Saga = Worker + Watcher</p>
</blockquote>
<p>redux-saga相当于在Redux原有数据流中多了一层，通过对Action进行监听，从而捕获到监听的Action，然后可以派生一个新的任务对state进行维护（这个看项目本身的需求），通过更改的state驱动View的变更。如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/15/16402829f9ac4180?w=718&amp;h=428&amp;f=png&amp;s=16806" alt="image" /></p>
<p>saga特点：</p>
<ol>
<li>saga 的应用场景是复杂异步。</li>
<li>可以使用 takeEvery 打印 logger（logger大法好），便于测试。</li>
<li>提供 takeLatest/takeEvery/throttle 方法，可以便利的实现对事件的仅关注最近实践还是关注每一次实践的时间限频。</li>
<li>提供 cancel/delay 方法，可以便利的取消或延迟异步请求。</li>
<li>提供 race(effects)，[...effects] 方法来支持竞态和并行场景。</li>
<li>提供 channel 机制支持外部事件。</li>
</ol>
<pre><code class="language-JavaScript">function *getCurrCity(ip) {
    const data = yield call(&#x27;/api/getCurrCity.json&#x27;, { ip })
    yield put({
        type: &#x27;GET_CITY_SUCCESS&#x27;, payload: data,
    })
}
function * getWeather(cityId) {
    const data = yield call(&#x27;/api/getWeatherInfo.json&#x27;, { cityId })
    yield put({
        type: &#x27;GET_WEATHER_SUCCESS&#x27;, payload: data,
    })
}
function loadInitData(ip) {
    yield getCurrCity(ip)
    yield getWeather(getCityIdWithState(state))
    yield put({
        type: &#x27;GET_DATA_SUCCESS&#x27;,
    })
}
</code></pre>
<p>总的来讲Redux Saga适用于对事件操作有细粒度需求的场景，同时它也提供了更好的可测试性，与可维护性，比较适合对异步处理要求高的大型项目，而小而简单的项目完全可以使用 redux-thunk 就足以满足自身需求了。毕竟 react-thunk 对于一个项目本身而言，毫无侵入，使用极其简单，只需引入这个中间件就行了。而 react-saga 则要求较高，难度较大，但胜在优雅（虽然我觉得asycn await的写法更优雅）。我现在也并没有掌握和实践这种异步流的管理方式，因此较为底层的东西先就不讨论了。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入浅出React和Redux》</li>
<li>《深入React技术栈》</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/7" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:56:41+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/6</id><title>初探 HTML5 Web Workers</title><updated>2023-03-02T09:44:06.857141+00:00</updated><content type="html"><![CDATA[<h3>一、Web Workers是什么</h3>
<blockquote>
<p>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和通道属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序 (反之亦然)。 —— MDN</p>
</blockquote>
<p>众所周知，JavaScript是单线程的编程语言，也就是说，当我们在页面中进行一个较为耗时的计算的JavaScript代码时，在这段代码执行完毕之前，页面是无法响应用户操作的。也正是出于这个原因，HTML5为我们提供了 Web Workers 以解决这种问题，当我们需要在JavaScript中来进行耗时的计算或诸如此类的问题时，我们可以使用 Web Workers 在浏览器的后台启动一个独立的 Worker 线程来专门负责这段代码的运行，而不会阻碍后面代码的运行。</p>
<h3>二、Web Workers的使用</h3>
<h4>1. 实例化一个 Worker</h4>
<p>实例化运行一个 Worker 很简单，我们只需要 new 一个 Worker 全局对象即可。</p>
<pre><code class="language-JavaScript">var worker = new Worker(&#x27;./worker.js&#x27;)
</code></pre>
<p>它接受一个 filepathname String 参数，用于指定 Worker 脚本文件的路径。然后我们就可以在 worker.js 中写下一些代码:</p>
<pre><code class="language-JavaScript">console.log(&#x27;my_WOEKER:&#x27;, &#x27;srtian&#x27;)
</code></pre>
<p>另外，通过URL.createObjectURL()创建URL对象，也可以实现创建内嵌的worker:</p>
<pre><code class="language-JavaScript">var myTask = `
    var i = 0;
    var timedCount = () =&gt; {
        i = i+1;
        postMessage(i);
        setTimeout(timedCount, 1000);
    }
    timedCount();
`;

var myblob = new Blob([myTask]);
var myWorker = new Worker(window.URL.createObjectURL(myblob));
</code></pre>
<blockquote>
<p>需要注意的是，传入 Worker 构造函数的参数 URI 必须遵循同源策略。</p>
</blockquote>
<p>此外因为Worker线程的创建的是异步的，所以主线程代码不会阻塞在这里等待 worker 线程去加载、执行指定的脚本文件，而是会立即向下继续执行后面代码这点也需要注意。</p>
<h4>2. 数据通信</h4>
<p>当我们实例化一个 Worker 线程后，Worker不会相互，或者与主程序共享任何作用域或资源——那会将所有的多线程编程的噩梦带到我们面前——取而代之的是一种连接它们的基本事件消息机制。因此他们需要通过基于事件监听机制的message来进行通信，我们在new Worker()后悔返回一个实例对象，它包含了一个postMessage的方法，我们可以通过调用这个方法来给worker线程传递信息，我们也可以给这个对象监听事件，从而在worker线程中出发事件通信的时候能接收到数据。</p>
<pre><code class="language-JavaScript">var worker = new worker(&#x27;./worker.js&#x27;)
worker.addEventListener(&#x27;message&#x27;, function(e) {
    console.log(&#x27;worker receive:&#x27;, e.data )
}
worker.postMessage(&#x27;hello worker,this is main.js&#x27;)
</code></pre>
<p>然后在worker.js这个脚本中，我们就可以调用全局函数postMessage和全局的onmessage赋值来发送和监听数据和事件了。</p>
<pre><code class="language-JavaScript">// 监听事件
onmessage = function (e) {
  console.log(&#x27;WORKER RECEIVE：&#x27;, e.data);
  // 发送数据事件
  postMessage(&#x27;Hello, this is worker.js&#x27;);
}
</code></pre>
<p>需要注意的是 worker 支持 JavaScript 中所有类型的数据传递，可以传递一个 Object 数据；但这里的数据传递（主要是 Object 类型）并不是共享，而是复制。发送端的数据和接收端的数据是复制而来，并不指向同一个对象，此外这里的复制不是简单的拷贝，而是通过两端的序列化/解序列化来实现的，一般来说浏览器会通过 JSON 编码/解码；当然，这里的更多细节部分会由浏览器来处理，我们并不需要关心这些，只需要明白两端的数据是复制而来，互相独立的就行了。</p>
<h4>3. 错误处理机制</h4>
<p>当 worker 出现运行中错误时，它的 onerror 事件处理函数会被调用。它会收到一个扩展了 ErrorEvent 接口的名为 error的事件。</p>
<p>该事件不会冒泡并且可以被取消；为了防止触发默认动作，worker 可以调用错误事件的 preventDefault() 方法。</p>
<p>错误事件有以下三个用户关心的字段：</p>
<ul>
<li>message: 可读性良好的错误消息。</li>
<li>filename: 发生错误的脚本文件名。</li>
<li>lineno: 发生错误时所在脚本文件的行号。 </li>
</ul>
<p>实际操作如下：</p>
<pre><code class="language-JavaScript">var worker = new Worker(&#x27;./worker.js&#x27;);

// 监听消息事件
worker.addEventListener(&#x27;message&#x27;, function (e) {
  console.log(&#x27;MAIN RECEIVE： &#x27;, e.data);
});
// 也可以使用 onMessage 来监听事件：


// 监听 error 事件
worker.addEventListener(&#x27;error&#x27;, function (e) {
  console.log(&#x27;MAIN ERROR：&#x27;, e);
  console.log(&#x27;MAIN ERROR：&#x27;, &#x27;filename:&#x27; + e.filename + &#x27;---message:&#x27; + e.message + &#x27;---lineno:&#x27; + e.lineno);
});


// 触发事件，传递信息给 Worker
worker.postMessage({
  m: &#x27;Hello Worker, this is main.js&#x27;
});
</code></pre>
<h4>4. 终止 Worker</h4>
<p>当我们在不需要 Worker 继续运行时，我就需要终止掉这个线程，这时候我们就可以调用 worker 的 terminate 方法:</p>
<pre><code class="language-javascript">worker.terminate()
</code></pre>
<p>worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p>
<p>而在worker线程中，workers 也可以调用自己的 close  方法进行关闭：</p>
<pre><code>close()
</code></pre>
<h3>三. Web Workers的兼容</h3>
<p>由于Web Workers是HTML5所提供的，因此从兼容性上来说，还是需要注意的。总的兼容情况如下图所示：
<img src="https://user-gold-cdn.xitu.io/2018/7/21/164bb60041e07800?w=2360&amp;h=1190&amp;f=png&amp;s=52309" alt="image" />
图片来源：<a href="https://caniuse.com/#feat=webworkers">https://caniuse.com/#feat=webworkers</a></p>
<p>我们可以看到，虽然web worker很不错，但如果我们的代码执行在较老的浏览器中时，是缺乏支持的。但由于worker是一个API而不是语法，因此我门还是可以去填补它的。</p>
<p>这一块的详情可以去看——《你不知道的JavaScript中卷》关于 web worker 的那一节。</p>
<h3>四、Web Workers支持的JavaScript特性</h3>
<p>由于在 Worker 线程的运行环境中没有 window 全局对象，也无法访问 DOM 对象，所以一般来说我们在这只能执行纯JavaScript的计算操作，当然1我们那：</p>
<ul>
<li>setTimeout()， clearTimeout()， setInterval()， clearInterval()：有了设计个函数，就可以在 Worker 线程中执行定时操作了；</li>
<li>XMLHttpRequest 对象：意味着我们可以在 Worker 线程中执行 ajax 请求；</li>
<li>navigator 对象：可以获取到 ppName，appVersion，platform，userAgent 等信息；</li>
<li>location 对象（只读）：可以获取到有关当前 URL 的信息；</li>
<li>应用缓存</li>
<li>使用 importScripts() 引入外部 script</li>
<li>创建其他的 Web Worker</li>
</ul>
<h3>五、Web Worker 的实践</h3>
<p>总的来说，Web Worker为我们带来了强大的计算能力，我们可以加载一个JavaScript进行大量的复杂计算，而用不挂起主进程。并通过postMessage，onmessage进行通信，这也解决了大量计算对UI渲染的阻塞问题。</p>
<h4>应用场景</h4>
<h5>1、数学运算</h5>
<p>Web Worker最简单的应用应该就是用来进行后台计算了，这对CPU密集型的场景再适合不过了。</p>
<h5>2、图像处理</h5>
<p>通过使用从 canvas 中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同Workers来做计算，对图像进行像素级的处理，再把处理完成的图像数据返回给主页面。</p>
<h5>3、大数据的处理</h5>
<p>目前mvvm框架越来越普及，基于数据驱动的开发模式也越愈发流行，未来大数据的处理也可能转向到前台，因此我们将大数据的处理交给在Web Worker也是很好的。</p>
<h5>4. 数据预处理</h5>
<p>为优化的网站或 web 应用的数据加载时长，我们可以使用 Web Worker 预先获取一些数据，存储起来以备后续使用，因为它绝不会影响应用的 UI 体验。</p>
<h5>5. 大量的 ajax 请求或者网络服务轮询</h5>
<p>由于在主线程中每启动一个XMLHttpRequest请求都会消耗资源，虽然在请求过程中浏览器另外开了一个线程，但是在交互过程中还是需要消耗主线程资源；而使用worker则不会过多占用主线程，只是启动worker过程时比较耗资源。</p>
<blockquote>
<p>原文：<a href="http://srtian96.gitee.io/blog/2018/07/21/%E5%88%9D%E6%8E%A2%20HTML5%20Web%20Workers/">初探 HTML5 Web Workers</a></p>
</blockquote>
<p>参考资料：</p>
<ol>
<li>《你不知道的JavaScript中卷》</li>
<li><a href="https://juejin.im/post/59c1b3645188250ea1502e46">https://juejin.im/post/59c1b3645188250ea1502e46</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers</a></li>
<li><a href="https://qiutc.me/post/the-multithread-in-javascript-web-worker.html">https://qiutc.me/post/the-multithread-in-javascript-web-worker.html</a></li>
<li><a href="https://juejin.im/post/5a90233bf265da4e92683de3">https://juejin.im/post/5a90233bf265da4e92683de3</a></li>
</ol>
]]></content><link href="https://github.com/srtian/Blog/issues/6" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:54:12+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/5</id><title>浅谈HTTP缓存</title><updated>2023-03-02T09:44:07.251180+00:00</updated><content type="html"><![CDATA[<h3>一、HTTP缓存概述（HTTP Cache）</h3>
<p>要搞清楚HTTP缓存，首先当然是要搞清楚缓存是啥，按照MDN的描述，缓存是这样的：</p>
<blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
</blockquote>
<p>上面已经将会缓存是什么描述的很清楚了，而HTTP缓存顾名思义，就是通过HTTP协议，来实现对资源缓存的目的。总的来说，HTTP缓存主要通过两个HTTP头来实现的，其中Expires是由HTTP1.0提供的，而Cache-Control则是由HTTP1.1所提供的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b78d14ea59?w=372&amp;h=321&amp;f=png&amp;s=6680" alt="HTTP缓存图1.PNG" /></p>
<p>下面我们就来对这两个头进行一个了解。</p>
<h3>二、Expires</h3>
<p>Expires是由HTTP1.0所提供的支持HTTP缓存的头部，由服务器返回，用GMT格式的字符串表示：</p>
<pre><code class="language-HTTP">expires: Tue, 14 Aug 2018 14:32:49 GMT
</code></pre>
<p>而读取缓存的条件则是：缓存过期时间（服务器的时间）&lt; 当前时间（客户端的时间）</p>
<p>值得注意的是，我们在expires所设置的时间是一个绝对的时间，而且所参照的是用户电脑上所设置的时间。这种绝对的时间很容易出问题，当用户本地的时间不准确，或用户进行跨时区的移动时，这个时间很可能就会过期，而无法发挥它本应该发挥的作用。</p>
<p>其次，在HTTP1.0里，没有提供相应的配置缓存的方法，只是提供了这个强缓存的头部而已，不足以满足项目对缓存多样化的需求。也正是出于以上两个原因，在HTTP1.1中对HTTP缓存又进行了升级。</p>
<h3>三、 Cache-Control</h3>
<p>正是由于Expires存在着很多不足，所以HTTP1.1又为我们提供了 </p>
<p>Cache-Control主要可配置的参数有以下几个：</p>
<ol>
<li>max-age 会指定从请求的时间开始，允许获取的响应被重用的最长时间（单位：秒）。例如，“max-age=60”表示可在接下来的 60 秒缓存和重用响应。</li>
<li>Public 表示响应可被任何缓存区缓存</li>
<li>Private 表示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这些响应通常只为单个用户缓存，因此不允许任何中间缓存对其进行缓存。例如，用户的浏览器可以缓存包含用户私人信息的 HTML 网页，但 CDN 却不能缓存。</li>
<li>no-cache 表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。因此，如果存在合适的验证，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。</li>
<li>no-store则要简单得多。它直接禁止浏览器以及所有中间缓存存储任何版本的返回响应，例如，包含个人隐私数据或银行业务数据的响应。每次用户请求该资产时，都会向服务器发送请求，并下载完整的响应。</li>
<li>min-fresh 表示客户端可以接收响应时间小于当前时间加上指定时间的响应。（用的不多）</li>
<li>max-stale 表示客户端可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。（用的不多）</li>
</ol>
<h3>四、强缓存</h3>
<p>上面已经将Catch-Control做了一个简单的介绍，而具体使用它们二者进行缓存操作的具体实现又分为强缓存与协商缓存。首先来聊一聊强缓存。</p>
<p>强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。在这个有效期内当浏览器对某个资源的请求命中了强缓存时，其返回的http状态为200，并且不会去对服务器进行请求，而是直接使用其本地的缓存。</p>
<p>具体实现如下：</p>
<pre><code>expires: Tue, 21 Aug 2018 10:17:45 GMT
cache-control: max-age=691200
</code></pre>
<p>只要存在以上两个头部信息的其中一个，我们就可以对资源进行强缓存了。另外需要注意的是，当Catch-Control的优先级是要高于expires的。</p>
<p>总的来说，强缓存是前端性能优化的一大助力。当我们页面存在很多长期不变的静态资源时，都应该对其进行强缓存的处理，我们通常可以为这些静态资源全部配置一个超时时间很长的Expires或Cache-Control。当用户在访问网页时，就只会在第一次加载时从服务器请求静态资源，在往后访问该页面时，就只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。这样既节省了资源加载的时间的消耗，又不会去访问服务器，可以有效地为服务器减压。</p>
<p>不过强缓存也存在一个很大的弊端，那就是对于动态资源它就有点力不从心了。因为如果我们对动态资源进行了强缓存，那么很可能会在这动态资源更改后，浏览器还是会直接去请求没有更改前的动态资源。也这是由于这方面的考虑，在强缓存外还存在着协商缓存的缓存方案。</p>
<h3>五、协商缓存</h3>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串；
若未命中请求，则将资源返回客户端，并更新本地缓存数据，并返回200的状态码。</p>
<p>除此之外，我们也可以设置为协商缓存，以解决动态资源缓存与更新的问题，首先我们来看一张关于协商缓存的图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b788163d06?w=1074&amp;h=588&amp;f=png&amp;s=36570" alt="输入图片说明" /></p>
<p>可以看到，在这个实现了协商缓存的Cache-Control中，设置了no-catch，当我们设置为no-catch时，我们就是可以直接去访问服务器，去查看该资源的更改情况，已确定是是否需要使用缓存。而在校验的这一步我们就需要使用以下几个头来帮助验证资源的更改情况了：</p>
<ul>
<li>Last-Modified：表示这个响应资源的最后修改时间。web服务器在响应请求时，会告诉浏览器该资源的最后修改时间，但它的最小单位是秒级，也就是如果我们在1秒内多次修改该资源，那么Last-Modified也无法发挥其应有的作用。</li>
<li>If-Modified-Since：当资源过期时（强缓存失效），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li>
</ul>
<p>也正是由于 Last-Modified存在着缺陷，我们就需要ETag来帮助我们来对资源的更改进行判断：</p>
<ul>
<li>Etag：当Web服务器响应请求时，会告诉浏览器当前资源在服务器的唯一标识（生成规则是由服务器决定的）。就比如在Apache中，ETag的值，其默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li>If-None-Match：当资源过期时，如果发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。Web服务器收到请求后发现有头If-None-Match， 就会将其被请求的资源的相应校验字段进行对比，然后再决定返回200或304。</li>
</ul>
<p>这就是强缓存与协商缓存的大部分情况了，具体的流程可见下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785" alt="image" /></p>
<p>原图链接：<a href="https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785">https://user-gold-cdn.xitu.io/2018/8/16/165411b79180df27?w=1041&amp;h=650&amp;f=png&amp;s=85785</a></p>
<h4>六、定义最佳 Cache-Control 策略</h4>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/16/165411b88bae2f00?w=595&amp;h=600&amp;f=png&amp;s=14914" alt="image" /></p>
<p>通常我们可以按照上面这张流程图来对HTTP缓存进行相应的配置，详情可以看这篇文章：</p>
<blockquote>
<p><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a>?</p>
</blockquote>
<p>这位大佬对缓存的配置做了一个很好的阐述。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching</a>?</li>
<li><a href="https://www.cnblogs.com/lyzg/p/5125934.html#_label3">https://www.cnblogs.com/lyzg/p/5125934.html#_label3</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/5" rel="alternate"/><category term="FE"/><category term="Web"/><category term="Basis"/><published>2019-09-28T09:52:53+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/4</id><title>五分钟，简单聊一聊React Component的发展历程</title><updated>2023-03-02T09:44:07.354360+00:00</updated><content type="html"><![CDATA[<h3>一、 前言</h3>
<p>随着 react 最新的一个大版本中，给我们带来了 Hooks：<a href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html">React v16.8: The One With Hooks</a>，从而将 Function component 的能力提高了一大截，成功的拥有了可以与 Class component 抗衡的能力。但话说回来，虽然 Hooks 看起来很美好，最近也有不少文章都讲解了Hooks这一“黑魔法”，但技术的不断演进，本身就是一个解决以往所存在问题的过程，因此我个人认为着眼于现在，回望过去，去看一看 react component 的发展之路，去看看 Class component 以及 Function component 为什么会出现以及它们出现的意义，所要解决的问题，也对于我们全面了解 react 是很有帮助的。</p>
<p>从 react component 的发展历程上来看，它主要是经历了一下三个阶段：</p>
<ol>
<li>createClass Component </li>
<li>Class Component </li>
<li>Function Component</li>
</ol>
<p>这个三个阶段也是react的组件不断走向轻量级的一个过程。其中 Class Component 完全替代了 createClass Component 成为了现在我们开发 react 组件的主流，而 Function Component 也在 Hooks 推出后磨刀霍霍，准备大干一场。下面就让我们去看看三者的具体情况吧~</p>
<blockquote>
<p>注：这篇文章整体只是对React Component的发展历程的一个概括或者说是我自己学习后的一个整理，想要详细了解，还请看看我在文章贴的那些链接。</p>
</blockquote>
<h3>二、 createClass Component</h3>
<p>说实话，createClass Component 我也没用过，因为我接触到 react 的时候已经是2017年下半年了，那时候 ES6 已经大行其道，class component 也已经完全取代了 createClass Component。但现在看来 createClass Component 的语法也很简单，并不复杂：</p>
<pre><code class="language-JavaScript">import React from &#x27;react&#x27;

const MyComponent = React.createClass({
  // 通过proTypes对象和getDefaultProps()方法来设置和获取props
  propTypes: {
    name: React.PropTypes.string
  },
  getDefaultProps() {
    return {

    }
  },
  // 通过getInitialState()方法返回一个包含初始值的对象
  getInitialState(){ 
        return {
            sayHello: &#x27;Hello Srtian&#x27;
        }
    }
  render() {
    return (
      &lt;p&gt;&lt;/p&gt;
    )
  }
})

export default MyComponent
</code></pre>
<p>react.createClass的语法并不复杂，它通过 createClass 来创建一个组件，并通过propTypes和getDefaultProps来获取props，通过通过getInitialState()方法返回一个包含初始值的对象，虽然从现在看来还是有点麻烦，但总体上来看代码也比较清晰，跟现在的 Class Component差别并不是太大。但 react.createClass 自从 react 15.5版本就不再为 react 官方所推介，而是想让大家的使用 class component 来代替它。而且在 react 16版本发布后，createClass 更是被废弃，当我们使用它的时候，会提示报错，也就是说，在 react 团队看来 createClass 已经完全没有存在的必要了。</p>
<p>其实 Class Component 完全替代 React.createClass 并不是说 React.createClass 有多坏，相反它还有一些 class Component 所没有的特性。它的废弃是由于ES6的出现，新增了 class 这一语法糖，让我们在 JavaScript 的开发中可以直接使用 extends 来扩展我们的对象，因此为了与标准的ES6接轨，原有的只在 react 中使用的 createClass 自然而然也成为了被抛弃的对象。但 class Component 在刚出现的时候也仍然存在的不小的争议，因为这两者还是存在一定的差别的，比如当时在Stack Overflow便出现了关于这两者的讨论，感兴趣的朋友可以去看看：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></p>
</blockquote>
<p>总的来说，除了语法上存在差异外，Class Component 和 React.createClass 的区别主要是以下两点（详情可以看看上面的回答）：</p>
<ul>
<li>React.createClass 会正确绑定 this，而 React.Component 则不行，我们需要在 constructor 里面使用 bind 或者直接使用箭头函数来绑定 this。</li>
<li>React.Component 不能使用 React mixins 特性，这一方面我们可以使用高阶组件来弥补。</li>
</ul>
<h3>三、Class Component</h3>
<p>Class Component创建的方式也很简单，就是普通的ES6的class的语法，通过extends来创建一个新的对象来创建react组件，下面是使用class Component创建一个组件的例子（由于为了给后面聊一聊hooks，所以在这里我使用了antd的例子）</p>
<pre><code class="language-JavaScript">class Modal extends React.Component {
  state = { visible: false }

  showModal = () =&gt; {
    this.setState({
      visible: true,
    });
  }
  handleOk = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  handleCancel = (e) =&gt; {
    console.log(e);
    this.setState({
      visible: false,
    });
  }
  render() {
    return (
      &lt;div&gt;
        &lt;Button type=&quot;primary&quot; onClick={this.showModal}&gt;
          Open Modal
        &lt;/Button&gt;
        &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={this.state.visible}
          onOk={this.handleOk}
          onCancel={this.handleCancel}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>上面就是antd中一个简单的 modal 组件的例子，其内部就是通过维护 visible 的状态来控制这个 modal 是否显示。我们可以看到，其中的一些方法都是使用箭头函数的方式来将 this 绑定到正确的属性。（具体为什么要这么做，不清楚的朋友可以看看下面这篇文章：）</p>
<blockquote>
<p><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></p>
</blockquote>
<p>而类似于上面的这种组件，也是近两年来我们在日常开发中使用最多的组件开发的方式。那为什么到了现在，我们又开始要强调使用 Function Component 来进行开发了呢？主要是由于 Class Component 所开发的组件仍然存在以下一些问题：</p>
<ol>
<li>this 绑定的问题：
我们前面也提到了，我们在使用原本的 React.createClass 时并不需要去考虑this绑定的问题，而现在我们却要时刻注意使用bind或者箭头函数来让this正确绑定，同时也让一些新上手react的同学的上手成本有所提升。虽然这不是React的锅，但这方面的问题仍然客观存在。</li>
<li>嵌套地狱： 这种情况则多发生于需要用到Context的场景下，在这种场景下，数据是同步的，因为需要通知更新所有有引用到数据的地方，因此我们就需要通过render-props 的形式定义在Context.Consumer的children中，而使用到越多的Context 就会导致嵌套层级越多，这很容易让人看代码看的一脸懵逼。比如这样：</li>
</ol>
<pre><code class="language-JavaScript">&lt;FirstContext.Consumer&gt;
  {first =&gt; (
    &lt;SecondContext.Consumer&gt;
      {second =&gt; (
        &lt;ThirdContext.Consumer&gt;
          {third =&gt; (
            &lt;Component /&gt;
          )}
        &lt;/ThirdContext.Consumer&gt;
      )}
    &lt;/SecondContext.Consumer&gt;
  )}
&lt;/FirstContext.Consumer&gt;
</code></pre>
<ol start="3">
<li>Life-cycles 的问题：生命周期函数也是我们在日常开发所经常使用到的东西。虽然生命周期函数用起来很方便，但一旦组件的逻辑变得复杂起来，这些生命周期函数也会变得难以理解和维护；同时如何让这些生命周期函数与react渲染有效结合也是一个不小的问题，这往往可能会让一些刚上手的人摸不着头脑。此外使用这些生命周期函数时也可能会出现一些预料之外的事情发生（比如在某些生命周期函数中进行数据请求，而导致组件被重复渲染多次的问题等等，这些都是有可能发生的）</li>
</ol>
<blockquote>
<p>详细可以去看看知乎上的这个回答：<a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></p>
</blockquote>
<h3>四、Function Component</h3>
<p>看到这里，大家对class Component所存在的一些问题也算是有一些了解了，但为什么它还能横行如此之久，一直占据着主流的地位呢？其本质上就是因为没有竞争对手嘛，Function Component 长期没有内部状态管理机制，只能通过外部来管理状态，因此组件的可测试性非常的高，写起来也简洁明了，符合现在前端函数式的大潮流，是个好同志。但也正是因为没有状态管理机制，所以无法和Class Component相抗衡，毕竟一旦组件内部的逻辑变得复杂之后，内部的状态管理机制是必须的。</p>
<p>因此 React 团队基于 Function Component 提出 Hooks 的概念，用以解决 Function Component 的内部状态管理，同时也希望通过 Hooks 来解决 Class Component 所存在的问题。下面就是使用 Hooks 针对 antd 中的 modal 进行的改写，大家可以自行感受一下：</p>
<pre><code class="language-JavaScript">const Modal = () =&gt; {
  const [visible , changeVisible] = useState(false)
  return (
    &lt;div&gt;
      &lt;Button type=&quot;primary&quot; onClick={()=&gt;changeVisible(true)}&gt;open&lt;/Button&gt;
      &lt;Modal
          title=&quot;Basic Modal&quot;
          visible={visible}
          onOk={()=&gt;changeVisible(false)}
          onCancel={()=&gt;changeVisible(false)}
        &gt;
          &lt;p&gt;this is a modal&lt;/p&gt;
        &lt;/Modal&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>我们可以看到，基于 Function Component 与 Hooks 所编写出来的组件代码是相当简洁明了的，也直接避免了我们上面所提到的 this 指向的问题。而对于上面所提到的嵌套地狱以及 Life-cycles 的问题，Hooks也提供了 useContext 和 useEffect（这个倒还是存在一些问题） 来解决，在这里我也不详细说了，详情可以去看官方文档或者是 Dan 的博客：</p>
<blockquote>
<p><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></p>
</blockquote>
<p>好了，看到这里我想大家都以为上面 Class Component 的问题都已经得到圆满解决了，Function Component好像已经圆满了，我们只管放心的使用它就好了。但世界上哪有这么好的事情，Function Component 仍然存在着下面几个 tip 是我们在使用前要知道的：</p>
<ol>
<li>Function Component 与 Class Component 表现不同，这块不清楚的可以直接去看Dan的文章，他对这方面做了很明白的阐述：</li>
</ol>
<blockquote>
<p><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></p>
</blockquote>
<ol start="2">
<li>使用useState需要注意的是，它的执行顺序要在每次 render 时必须保持一致，不可以进判断和循环，必须写在最前面，关于这一点看视频：</li>
</ol>
<blockquote>
<p><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></p>
</blockquote>
<ol start="3">
<li>Function Component 中，外部对与函数式组件的操作只能通过 props 来进行控制，不能通过函数式组件内部暴露方法来对组件进行操作。</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://ultimatecourses.com/blog/react-create-class-versus-component">https://ultimatecourses.com/blog/react-create-class-versus-component</a></li>
<li><a href="https://overreacted.io/how-are-function-components-different-from-classes/">https://overreacted.io/how-are-function-components-different-from-classes/</a></li>
<li><a href="https://www.youtube.com/watch?v=dpw9EHDh2bM">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></li>
<li><a href="https://overreacted.io/a-complete-guide-to-useeffect/">https://overreacted.io/a-complete-guide-to-useeffect/</a></li>
<li><a href="https://www.zhihu.com/question/300049718">https://www.zhihu.com/question/300049718</a></li>
<li><a href="https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass">https://stackoverflow.com/questions/30668464/react-component-vs-react-createclass</a></li>
<li><a href="http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/">http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/</a></li>
<li><a href="https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/">https://www.freecodecamp.org/news/this-is-why-we-need-to-bind-event-handlers-in-class-components-in-react-f7ea1a6f93eb/</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/4" rel="alternate"/><category term="FE"/><category term="React"/><published>2019-09-28T09:52:12+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/3</id><title>浅析 Rematch 源码</title><updated>2023-03-02T09:44:07.479875+00:00</updated><content type="html"><![CDATA[<h3>前言</h3>
<p>入职后公司用的技术栈还是 react，但状态管理由我原本熟悉的 redux 进化成了在 redux 基础上封装而成的 rematch。用起来也着实方便不少，减少了很多样板代码的编写，同时也不用引入中间件来管理异步请求了，但在用起来的过程中难免就会引起了我对 rematch 的一些小疑问：</p>
<ul>
<li>它是怎么封装 诸如action creator这些以往在 redux 中繁琐的“样本”代码的？</li>
<li>它是如何区分 reducer action 以及 effect action 的？</li>
<li>等等</li>
</ul>
<p>带着上面的这些疑问，我翻开了 rematch 的源码开始读了起来</p>
<h3>一、总览</h3>
<p>打开 rematch 的文件目录，来到 src 文件夹下，可以看到其文件的主要层级如下：</p>
<pre><code>.src
├── plugins     
│    ├── dispatch.ts    //  同于生成 dispatch
│    ├── effects.ts  //  同于处理异步 action
├── typings   //  类型约束文件
├── utils   //  工具函数 
├── index.ts    //  入口文件      
├── pluginFactory.ts  
├── redux.ts    //  基础redux
├── rematch.ts  //  Rematch基类
</code></pre>
<p>然后打开 index.ts 文件，rematch 的 index 文件非常精简，现版本只存在两个具有实际应用价值的函数：</p>
<pre><code class="language-TypeScript">// 为给定对象创建model，然后返回作为参数接收的对象
export function createModel&lt;S = any, M extends R.ModelConfig&lt;S&gt; = any&gt;(model: M) {
	return model
}

let count = 0

export const init = (initConfig: R.InitConfig = {}): R.RematchStore =&gt; {
	// 如果不指定 name，就将其迭代的次数作为 name
	const name = initConfig.name || count.toString()
	count += 1
	// 配置的对象，在这里使用 mergeConfig 来合并
	const config: R.Config = mergeConfig({ ...initConfig, name })
	// 在这里会先将 config 的信息传入 Rematch 函数中，然后会被 init 函数会执行，而它的结果也在此被返回，也就是我们新生成的 store
	return new Rematch(config).init()
}

export default {
	init,
}
</code></pre>
<p>index 文件中最为核心的就是 init 函数了，它主要做了以下工作：</p>
<ul>
<li>初始化 store 的 name</li>
<li>将 name 与传入的 config 对象，并返回新的 config 对象</li>
<li>把新的 config 对象作为参数传入，返回 new Rematch(config).init()</li>
</ul>
<h3>二、Rematch</h3>
<p>上面的 index 文件到了 new Rematch(config).init() 就截然而止了，虽然我们知道他已经在此过程中，完成了一个 store 的创建，但这个过程我却并不知晓，因此接下来就是要去翻阅 rematch.ts 文件，首先扫一眼这个文件的大概情况，为后面的阅读做个铺垫:</p>
<pre><code class="language-javascript">import pluginFactory from &#x27;./pluginFactory&#x27;
import dispatchPlugin from &#x27;./plugins/dispatch&#x27;
import effectsPlugin from &#x27;./plugins/effects&#x27;
import createRedux from &#x27;./redux&#x27;
import * as R from &#x27;./typings&#x27;
import validate from &#x27;./utils/validate&#x27;

const corePlugins: R.Plugin[] = [dispatchPlugin, effectsPlugin]

/**
 * Rematch class
 *
 * an instance of Rematch generated by &quot;init&quot;
 */
export default class Rematch {
	protected config: R.Config
	protected models: R.Model[]
	private plugins: R.Plugin[] = []
	private pluginFactory: R.PluginFactory

	constructor(config: R.Config) {
		
	}
	public forEachPlugin(method: string, fn: (content: any) =&gt; void) {
		
	}
	public getModels(models: R.Models): R.Model[] {
		
	}
	public addModel(model: R.Model) {
		
	}
	public init() {
	
    }
}
</code></pre>
<p>首先来看 rematch.ts 的类的声明部分：</p>
<pre><code class="language-JavaScript">export default class Rematch {
	protected config: R.Config
	protected models: R.Model[]
	private plugins: R.Plugin[] = []
	private pluginFactory: R.PluginFactory

	constructor(config: R.Config) {
	    // 这里的 config 就是从 index.ts 里传入的 config
		this.config = config
		this.pluginFactory = pluginFactory(config)
		// 遍历 corePlugins 以及 config 中的 plugins
		// 对其中的每个 plugins 通过 pluginFactor.create 生成 plugins 数组
		for (const plugin of corePlugins.concat(this.config.plugins)) {
			this.plugins.push(this.pluginFactory.create(plugin))
		}
		// preStore: middleware, model hooks
		// 将 middleware 执行一遍，并将 middleware 添加到 this.config.redux.middlewares 这个数组中
		this.forEachPlugin(&#x27;middleware&#x27;, (middleware) =&gt; {
			this.config.redux.middlewares.push(middleware)
		})
	}
	... ... 
}
</code></pre>
<p>通过上面的代码我们可以发现，当我们去实例化 Rematch 时，首先会去执行这里的构造函数。这个构造函数主要是为了处理 plugin，并对两类不同的 plugin 分别进行处理：</p>
<ul>
<li>一种是 corePlugin，也就是核心插件 dispatchPlugin 以及 effectsPlugin ，这里会将他们 push 到 this.plugin 数组中存储起来。</li>
<li>而对于中间件插件，由于中间件插件本身都是“不纯”的，因此本身就属于 effectsPlugin ，这里会将 effectsPlugin 中的 middleWares push 到 this.config.redux.middlewares 中去进行存储。</li>
</ul>
<p>接下来就是 rematch 中定义的三个方法了：</p>
<pre><code class="language-JavaScript">    public forEachPlugin(method: string, fn: (content: any) =&gt; void) {
        for (const plugin of this.plugins) {
            if (plugin[method]) {
                fn(plugin[method])
            }
        }
    }
    public getModels(models: R.Models): R.Model[] {
        return Object.keys(models).map((name: string) =&gt; ({
            name,
            ...models[name],
            reducers: models[name].reducers || {},
        }))
    }
    public addModel(model: R.Model) {
        validate([
            [!model, &#x27;model config is required&#x27;],
            [typeof model.name !== &#x27;string&#x27;, &#x27;model &quot;name&quot; [string] is required&#x27;],
            [model.state === undefined, &#x27;model &quot;state&quot; is required&#x27;],
        ])
        // run plugin model subscriptions
        this.forEachPlugin(&#x27;onModel&#x27;, (onModel) =&gt; onModel(model))
    }
</code></pre>
<p>从这三个方法的名字我们就不难看出这是哪个方法的具体作用了，这三个方法主要是为了协助上面的构造函数以及下面 init() ，因此在此就不一一赘述了。下面就来重头戏 init() :</p>
<pre><code class="language-JavaScript">public init() {
		// collect all models
		// 通过 getModels 获取所有的 models
		this.models = this.getModels(this.config.models)
		// 遍历所有的 models 执行 addModels 
		for (const model of this.models) {
			this.addModel(model)
		}
		// create a redux store with initialState
		// merge in additional extra reducers
		// 这里就是更新 state 的 reducer 了，后面具体会有分析
		const redux = createRedux.call(this, {
			redux: this.config.redux,
			models: this.models,
		})

		const rematchStore = {
			name: this.config.name,
			...redux.store,
			// dynamic loading of models with `replaceReducer`
			model: (model: R.Model) =&gt; {
				this.addModel(model)
				redux.mergeReducers(redux.createModelReducer(model))
				redux.store.replaceReducer(redux.createRootReducer(this.config.redux.rootReducers))
				redux.store.dispatch({ type: &#x27;@@redux/REPLACE &#x27;})
			},
		}

		this.forEachPlugin(&#x27;onStoreCreated&#x27;, (onStoreCreated) =&gt; {
			const returned = onStoreCreated(rematchStore)
			// if onStoreCreated returns an object value
			// merge its returned value onto the store
			if (returned) {
				Object.keys(returned || {}).forEach((key) =&gt; {
					rematchStore[key] = returned[key]
				})
			}
		})

		return rematchStore
	}
</code></pre>
<p>init() 会先执行 getModels 从而获取所有的 models ，并返回给 this.model, 然后通过遍历 this.model，对其中的每个 models 都执行 addModel ，然后就会去调用 forEachPlugin。这块的执行逻辑稍微有点深，但其实本质上就是为了让所有的 models 都这么执行一次:</p>
<pre><code class="language-JavaScript">plugin.onModel(model)
</code></pre>
<p>同时这里也会根据 model 的不同的情况，去执行两种plugin：dispatchPlugin 和 effectPlugin。</p>
<p>其中 dispatchPlugin 的 onModel 处理如下：</p>
<pre><code class="language-JavaScript">// dispatch.ts
onModel(model: R.Model) {
		this.dispatch[model.name] = {}
		if (!model.reducers) {
			return
		}
		for (const reducerName of Object.keys(model.reducers)) {
			this.validate([
				[
					!!reducerName.match(/\/.+\//),
					`Invalid reducer name (${model.name}/${reducerName})`,
				],
				[
					typeof model.reducers[reducerName] !== &#x27;function&#x27;,
					`Invalid reducer (${model.name}/${reducerName}). Must be a function`,
				],
			])
			// 根据 model Name 和 reducer Name 生成相应的 dispatch 函数
			this.dispatch[model.name][reducerName] = this.createDispatcher.apply(
				this,
				[model.name, reducerName]
			)
		}
	}
</code></pre>
<p>我们可以看到 onModel 函数会遍历所有的 reducer，然后生成相应的 dispatch 函数（如何实现后面讨论）</p>
<p>而 effectsPlugin 的 onModel 则是这样的：</p>
<pre><code class="language-JavaScript">onModel(model: R.Model): void {
		if (!model.effects) {
			return
		}

		const effects =
			typeof model.effects === &#x27;function&#x27;
				? model.effects(this.dispatch)
				: model.effects

		for (const effectName of Object.keys(effects)) {
			this.validate([
				[
					!!effectName.match(/\//),
					`Invalid effect name (${model.name}/${effectName})`,
				],
				[
					typeof effects[effectName] !== &#x27;function&#x27;,
					`Invalid effect (${model.name}/${effectName}). Must be a function`,
				],
			])
			this.effects[`${model.name}/${effectName}`] = effects[effectName].bind(
				this.dispatch[model.name]
			)
			// add effect to dispatch
			// is assuming dispatch is available already... that the dispatch plugin is in there
			this.dispatch[model.name][effectName] = this.createDispatcher.apply(
				this,
				[model.name, effectName]
			)
			// tag effects so they can be differentiated from normal actions
			this.dispatch[model.name][effectName].isEffect = true
		}
	},
</code></pre>
<p>这两者的 onModel 其实都差不多，最大的却别就是 effectsPlugin 的 onModel 在最后标记了 isEffect 为 true 。然后我们就可以来看 this.createDispatcher 到底做了什么：</p>
<pre><code class="language-JavaScript">/**
		 * createDispatcher
		 *
		 * genereates an action creator for a given model &amp; reducer
		 * @param modelName string
		 * @param reducerName string
		 */
createDispatcher(modelName: string, reducerName: string) {
			return async (payload?: any, meta?: any): Promise&lt;any&gt; =&gt; {
				const action: R.Action = { type: `${modelName}/${reducerName}` }
				if (typeof payload !== &#x27;undefined&#x27;) {
					action.payload = payload
				}
				if (typeof meta !== &#x27;undefined&#x27;) {
					action.meta = meta
				}
				return this.dispatch(action)
			}
		}
</code></pre>
<p>createDispatcher 函数的作用注释里说的很清楚，为 model 和 reducer 生成相应的 action creator，其内部实现是返回一个 async 函数，内部有由 model name 以及 reducer name 组成的套路化的 action type，然后再返回 dispatch(action) 的执行结果。这个 dispatch 又会到哪去呢？让我们将目光回到 rematch.ts 中的 init() 中去，我在上面的代码中有提到这么一段代码：</p>
<pre><code class="language-JavaScript">// 这里就是更新 state 的 reducer 了，后面具体会有分析
const redux = createRedux.call(this, {
	redux: this.config.redux,
	models: this.models,
})
</code></pre>
<p>实际上我们这段代码就相当于我们在 redux 中的 reducer ，他会接收到 dispatch(action) 从而变动 state。它的详情代码在 redux 中：</p>
<pre><code class="language-JavaScript">import * as Redux from &#x27;redux&#x27;
import * as R from &#x27;./typings&#x27;
import isListener from &#x27;./utils/isListener&#x27;

const composeEnhancersWithDevtools = (
	devtoolOptions: R.DevtoolOptions = {}
): any =&gt; {
	const { disabled, ...options } = devtoolOptions
	/* istanbul ignore next */
	return !disabled &amp;&amp;
		typeof window === &#x27;object&#x27; &amp;&amp;
		window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__
		? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(options)
		: Redux.compose
}

export default function({
	redux,
	models,
}: {
	redux: R.ConfigRedux,
	models: R.Model[],
}) {
	const combineReducers = redux.combineReducers || Redux.combineReducers
	const createStore: Redux.StoreCreator = redux.createStore || Redux.createStore
	const initialState: any =
		typeof redux.initialState !== &#x27;undefined&#x27; ? redux.initialState : {}

	this.reducers = redux.reducers

	// combine models to generate reducers
	this.mergeReducers = (nextReducers: R.ModelReducers = {}) =&gt; {
		// merge new reducers with existing reducers
		// 将已经新的 reducers 和 存在的 reducer 合并
		this.reducers = { ...this.reducers, ...nextReducers }
		// 如果没有 reducers 就直接返回 state
		if (!Object.keys(this.reducers).length) {
			// no reducers, just return state
			return (state: any) =&gt; state
		}
		//  执行合并操作
		return combineReducers(this.reducers)
	}

	this.createModelReducer = (model: R.Model) =&gt; {
		const modelBaseReducer = model.baseReducer
		const modelReducers = {}
		// 遍历 model.reducers ，为其中的每个 reducer 创造一个命名空间，并将其赋值到 modelReducer 中去
		for (const modelReducer of Object.keys(model.reducers || {})) {
			const action = isListener(modelReducer)
				? modelReducer
				: `${model.name}/${modelReducer}`
			modelReducers[action] = model.reducers[modelReducer]
		}
		const combinedReducer = (state: any = model.state, action: R.Action) =&gt; {
			// handle effects
			if (typeof modelReducers[action.type] === &#x27;function&#x27;) {
				return modelReducers[action.type](state, action.payload, action.meta)
			}
			return state
		}

		this.reducers[model.name] = !modelBaseReducer
			? combinedReducer
			: (state: any, action: R.Action) =&gt;
					combinedReducer(modelBaseReducer(state, action), action)
	}
	// initialize model reducers
	// 创建 model 的 reducer
	for (const model of models) {
		this.createModelReducer(model)
	}

	this.createRootReducer = (
		rootReducers: R.RootReducers = {}
	): Redux.Reducer&lt;any, R.Action&gt; =&gt; {
		const mergedReducers: Redux.Reducer&lt;any&gt; = this.mergeReducers()
		if (Object.keys(rootReducers).length) {
			return (state, action) =&gt; {
				const rootReducerAction = rootReducers[action.type]
				if (rootReducers[action.type]) {
					return mergedReducers(rootReducerAction(state, action), action)
				}
				return mergedReducers(state, action)
			}
		}
		return mergedReducers
	}

	const rootReducer = this.createRootReducer(redux.rootReducers)

	const middlewares = Redux.applyMiddleware(...redux.middlewares)
	const enhancers = composeEnhancersWithDevtools(redux.devtoolOptions)(
		...redux.enhancers,
		middlewares
	)
    // 创建一个 redux store，并返回 this 对象
	this.store = createStore(rootReducer, initialState, enhancers)

	return this
}
</code></pre>
<h3>三、小结</h3>
<p>总的来说，rematch 其实就是在 redux 的基础上进行了封装，将我们本来在 redux 中要写的诸如action creator等诸多样本代码给予封装，只需要关心 model 的划分以及写出合理的 reducers 以及 effects 即可。因此简单回答上面我看源码时所带的那两个问题：</p>
<ol>
<li>如何区分reducer action以及 effect action</li>
</ol>
<ul>
<li>rematch 在内部有两种 plugin，一种是 dispatchPlugin，一种是 effectPlugin，前者只会让 reducers 进入逻辑代码，后者只会让 effects 进入逻辑代码，并且会标记 isEffect = true</li>
</ul>
<ol start="2">
<li>它是怎么封装 诸如action creator这些以往在 redux 中繁琐的“样本”代码的？</li>
</ol>
<ul>
<li>rematch 在内部的 createDispatch 函数内部会根据 model name 以及 reducer name 创建相应的 action.type，以及对应的 action.payload，然后 dispatch 到 reducer 中去即可，同时也在这个函数内部内置的 async 来支持异步的 action。</li>
</ul>
<h4>扩展阅读</h4>
<ul>
<li><a href="https://juejin.im/post/5b13fe155188257d6c046728">Redux 源码解读</a></li>
<li><a href="https://juejin.im/post/5b237569f265da59bf79f3e9">深入理解 Redux 中间件</a></li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/3" rel="alternate"/><category term="FE"/><category term="JavaScript"/><category term="React"/><published>2019-09-28T09:41:20+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/2</id><title>《Don't Make Me Think》读书笔记</title><updated>2023-03-02T09:44:07.579980+00:00</updated><content type="html"><![CDATA[<h3>一、别让我思考</h3>
<p>网页的易用性最重要的一点就是无需用户去思考。这也代表着交互一般劲量趋向于简单化，平整化，以减少用户的认知负担，减少对用户的干扰。</p>
<p>示例：亚马逊搜索没有提及一定要去搜索什么内容，只会对你所输入的进行分析，这样就会减少用户的思考的成本（淘宝也是如此，通过自然语言处理来对用户的输入进行分析）</p>
<p>比较典型的地方：</p>
<ul>
<li>按钮是否明显</li>
<li>相同的信息是否集中</li>
<li>搜索是否便捷</li>
<li>关键功能的位置是否显眼、是否易用</li>
</ul>
<h3>二、扫描，满意即可，勉强应付</h3>
<p>根据我自身使用web的时候，突然觉得这个很有道理。往往当我们在web上进行浏览的时候，只会对我们所关注的信息进行仔细的观察。也就是说，我们在访问一个网页时，会首先对整个网页进行一次扫描，在这个扫描的过程中，我们会对我们感兴趣的知识进行提取，而那些我们在扫描过程中不是很在意的东西就会进行忽略。</p>
<p>为什么扫描：</p>
<ul>
<li>我们总是处于忙碌中</li>
<li>我们知道自己不必阅读所有内容</li>
<li>我们善于扫描</li>
</ul>
<p>也真是由于用户只是扫描页面，因此其实用户并不会去真正的寻找最佳结构，而是满意即可，即选择第一个合理的选项。（我们在作出决策也是如此，只会寻找第一个合理的决策就可能去执行）</p>
<h3>三、 广告牌设计101法则（为扫描设计，不为阅读设计）</h3>
<p>正是由于我们是扫描页面的，因此要采取以下五个原则：</p>
<ol>
<li>在每个页面上建立清楚的视觉层次</li>
<li>尽量利用习惯用法</li>
<li>把页面划分成明确定义的区域</li>
<li>明显表示可以点击的地方</li>
<li>最大限度降低干扰</li>
</ol>
<h4>3.1 建立清楚的视觉层次</h4>
<p>一个视觉层次清楚的页面有三个特点：</p>
<ol>
<li>越重要的部分越突出（h1-h6/p1-p6）</li>
<li>逻辑上相关的部分在视觉上也相关</li>
<li>逻辑上包含的部分在视觉上进行嵌套</li>
</ol>
<h4>3.2 关于习惯用法</h4>
<p>首先他们很重要，正是由于习惯、所以符合用户的习惯。但由于设计师们需要造轮子来证明自己（其实工程师也是这样），所以他们一般不想直接使用习惯用法，而是设计出属于自己的一套方法论。</p>
<h4>3.3 把页面划分为明确定义的区域</h4>
<p>这可以让用户快速决定关注页面的那些位置（即重点扫描的区域）</p>
<h4>3.4 明显表示可以点击的地方</h4>
<p>颜色不同、质感不同等方式。别让用户到处去找</p>
<h4>3.5 降低视觉噪声</h4>
<p>页面的难以理解最大的原因就在于视觉噪声，视觉噪声大致分为两大类：</p>
<ul>
<li>眼花缭乱：满眼惊叹号，毫无层次等</li>
<li>背景噪声</li>
</ul>
<h3>第四章 为什么用户喜欢无需思考的选择</h3>
<p>一般来说用户在达到目标前所需要的点击次数不应过多（很多网站规定点击次数不应该超过5次）（通常来说网页越平整化越好）</p>
<blockquote>
<p>注：三次无需思考，明确无误的点击相当与一次需要思考的地点击</p>
</blockquote>
<h3>第五章 省略不必要的文字</h3>
<blockquote>
<p>去掉每个页面上一半的文字，然后把剩下的文字再去掉一般 —— krug可用性第三定律</p>
</blockquote>
<p>去掉多余文字的好处：</p>
<ul>
<li>可以降低页面的噪声</li>
<li>让有用的内容更突出</li>
<li>让页面更尖端，让用户在浏览时可以扫描的内容更多，无需滚屏</li>
</ul>
<p>那么我们可以做下面一些事情：</p>
<ol>
<li>欢迎词必须消灭</li>
<li>知识说明必须要消灭</li>
</ol>
<h3>第六章 设计导航</h3>
<p>如果网页上让大家找不到方向，人们就不会使用你的网站。</p>
<p>那么重要的事情首先要做的事就是让相关的事物集中在一块，这样当用户在浏览网页的时候，就能快速定位自己所需要找的内容的大体位置。</p>
<h4>6.1 网络导航101法则</h4>
<p>我们浏览一个网页的过程：</p>
<ul>
<li>你通常是为了寻找某个目标</li>
<li>如果选择浏览，你将通过标志的引导在层次结构中穿行</li>
<li>找不到我们就会跑路</li>
</ul>
<p>导航的作用：</p>
<ol>
<li>他给了我们一些固定的感觉</li>
<li>他告诉我们当前的位置</li>
<li>他告诉我们如何使用网站</li>
<li>他给了我们对网站建造者的信心</li>
</ol>
<p>重要的是由这两者元素：主页和表单</p>
<ul>
<li>主页：我们可以直接通过主页来确定我们当前的位置</li>
<li>表单：可以将栏目、工具都汇聚在这里，但依然要注意相关性的原则，且层级不应该过深（尽量少于3次）</li>
</ul>
<p>此外要注意的是要保证，无论用户到哪都给他一个可以直接返回主页的按钮，这可以给用户安全感，不会迷失方向。</p>
<p>此外我们还有以下几点需要避免的：</p>
<ul>
<li>花哨的用词</li>
<li>指示说明</li>
<li>选项</li>
</ul>
<p>页面名称需要注意的：</p>
<ul>
<li>大小应该要大于其他的文字</li>
<li>应该出现在合适的位置</li>
<li>每个页面都需要一个名称</li>
<li>名称要引人注意</li>
<li>名称要和点击的链接一致</li>
</ul>
<h4>6.2 层级导航</h4>
<p>除了主页面的导航外，还有就是使用层级导航来帮助用户导航。关于层级导航有以下几点最佳实践：</p>
<ul>
<li>把他们放在最顶端</li>
<li>使用&gt;对层级进行分隔</li>
<li>使用小字体</li>
<li>使用了文字“你在这里”</li>
<li>将最后一个元素加粗</li>
<li>没有把他们用作页面的名称</li>
</ul>
<h4>6.3 标签</h4>
<p>标签的好处：</p>
<ol>
<li>它们不言而喻</li>
<li>它们很难错过</li>
<li>它们很灵活</li>
<li>它们暗示了一个物理空间</li>
</ol>
<p>标签的绘制方法：</p>
<ol>
<li>正确绘制</li>
<li>颜色编码（选中的与没选中的不一样）</li>
<li>当你进入网站时，有一个标签已经选中</li>
</ol>
<h4>6.4 后备箱测试</h4>
<p>所谓的后备箱测试指的是页面设计良好，我们就能快速的答出以下的一些问题：</p>
<ul>
<li>这是什么网站</li>
<li>我在哪个网页上</li>
<li>这个网站的主要栏目是哪些</li>
<li>在这个层次上我有哪些选择</li>
<li>我在导航系统的什么位置</li>
<li>我怎么搜索</li>
</ul>
<p><strong>降低用户好感的方式：</strong></p>
<ul>
<li>隐藏我想要的信息</li>
<li>因为没有按照你们的方式行事而惩罚我</li>
<li>向我询问不必要的信息</li>
<li>敷衍我，欺骗我</li>
<li>给我设置障碍</li>
<li>你的网站看起来不专业</li>
</ul>
<p><strong>提高好感的几种方式：</strong></p>
<ul>
<li>知道人们在你网站上像做什么，并让他们明白简易</li>
<li>告诉我我想知道的</li>
<li>尽量减少步骤</li>
<li>花点心思</li>
<li>知道我可能有哪些疑问，并且给予解答</li>
<li>为我提供协助</li>
<li>容易从错误中恢复</li>
<li>如有不确定，记得道歉</li>
</ul>
]]></content><link href="https://github.com/srtian/Blog/issues/2" rel="alternate"/><category term="Notes"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:34:00+00:00</published></entry><entry><id>https://github.com/srtian/Blog/issues/1</id><title>浅析浏览器进程发展历程</title><updated>2023-03-02T09:44:07.817703+00:00</updated><content type="html"><![CDATA[<h3>一、浏览器的多进程概括</h3>
<p>要想搞明白什么是浏览器的多进程，首先得知道什么是进程。按照维基百科的说法：</p>
<blockquote>
<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>
</blockquote>
<p>简单来讲，进程就是CPU资源分配的最小单位，而线程则是CPU调度的最小单位。那什么又是单线程和多线程呢，我们来看一小段代码：</p>
<pre><code>var a = 1 + 10086
var b = 100 * 2
var c = (20 + 1) * 2
var d = 100/10
var e = a + b + c + d
console.log(e)
</code></pre>
<p>譬如上面的代码，如果是在单线程的运行环境比如JavaScript，就会需要将上面的计算一个个的去执行完成，然后得出运行结果，也就需要进行六步才能将e打印出来，但如果是在多线程的运行环境中则只需要使用四个线程来同时计算上面的四个运算，待上面的四个运算全部完成后再把他们相加，然后再打印出来。因此使用多线程的并行运算可以大大的提高程序的性能以及效率。</p>
<p>但虽然多线程可以有效的提高程序的运行效率，但它是不能单独存在的，它需要进程的启动与管理。简单来说，进程与线程之间会存在以下四种关系：</p>
<ul>
<li>进程中的任意一线程执行出错，都会导致整个进程的崩溃。很常见就是JavaScript出现的执行线程出错时会导致整个页面进程的崩溃，而导致页面白屏。</li>
<li>线程之间共享同进程中的数据。</li>
<li>当一个进程关闭之后，操作系统会回收进程所占用的内存。</li>
<li>进程之间的内容会相互隔离。每个进程都只能访问自己访问的数据，这可以有效的避免一个进程的崩溃而影响到其他的进程。如果进程之间有进行数据通信的需要，这时候就需要进程通信（IPC）机制了。</li>
</ul>
<h3>二、浏览器进程发展过程</h3>
<p>现在我们都知道浏览器都是多进程的，但其实回顾历史发展的历程，浏览器也经历了一个由单进程到多进程的发展历程。现在就让我们来理一理浏览器单线程到多线程的发展历程。</p>
<h4>2.1 青铜时代---单进程的浏览器</h4>
<p>2007年之前，所有的浏览器都是单进程的，其中的典型代表就是IE6了。在ID6的时代，页面还是单标签的，一个页面一个窗口，一个窗口一个主线程。因此顾名思义，单进程的浏览器就是指打开一个浏览器，其中包含一个页面，而这个页面的所有的功能模块都运行在同一个进程里，这个模块包括但不限于：网络、渲染引擎、JavaScript运行环境、第三方插件等。具体架构如下图所示：
<img src="https://github.com/srtian/2018-08-14-04-14-25-1534220065/blob/master/main/%E5%8D%95%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="image" />
基于这种情况，单进程的浏览器就存在以下一些问题：</p>
<h5>1. 不稳定</h5>
<p>早期的浏览器都是通过各式各样的插件来实现诸如视频、游戏等功能的，而插件本身又很不靠谱，由于插件运行在浏览器进程之中，因此一个插件的意外崩溃就会导致整个浏览器的奔溃。同样的，渲染引擎也是这个道理，往往一个JavaScript的bu就可能导致整个页面崩溃。</p>
<h5>2. 不流畅</h5>
<p>因为所有页面的JavaScript线程、渲染模块、以及第三方插件都运行在同一个线程之中，因此同一时刻只有一个模块可以执行，这就很有可能出现一个模块发生阻塞的时候而导致其他模块无法运行的情况。此外当时国产的浏览器其实都是基于IE6来进行二次开发的，因此这些国产浏览器虽然基于自身需要，都采用的多标签页的形式，但这些多标签页其实也是跑在同一个线程里的，这就会导致其中一个标签页的卡顿会影响到整个浏览器。</p>
<h5>3. 不安全</h5>
<p>不安全主要是处于两个方面的，一个是插件一个是页面脚本。页面中运行的插件可以读取电脑的资源，执行一些命令。而页面脚本则可以通过浏览器漏洞来获取系统权限，从而应发一系列安全问题</p>
<h4>2.2 白银时代---多进程浏览器时代</h4>
<p>终于随着 Chrome 浏览器的发布，浏览器架构终于来到了多进程的时代。其中 Chrome 浏览器的进程架构如下：
<img src="https://github.com/srtian/2018-08-14-04-14-25-1534220065/blob/master/main/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8.png?raw=true" alt="image" />
其主要作用如下：</p>
<ol>
<li>Browser进程（浏览器进程）：这是浏览器的主进程。有且只有一个，它主要有以下几个作用：</li>
</ol>
<ul>
<li>负责浏览器页面的显示与页面交互</li>
<li>负责个页面的管理。创建和销毁其他进程</li>
<li>将 Renderer 进程得到的内存中的 Bitmap ，绘制到用户页面上。</li>
<li>网络资源的管理，下载等。</li>
</ul>
<ol start="2">
<li>第三方插件进程：主要负责插件的运行，每种类型的插件都对应着一个进程，只有当使用该插件时才会创建该进程，这样就做到了隔离插件的效果，保证插件的崩溃不会影响到浏览器以及页面。</li>
<li>GPU进程：最多一个，用于3D绘制。这个进程在最初是没有的。但为了实现 3D CSS 的效果，GPU进程成为了浏览器的普遍需求，因此Chrome浏览器也在其多进程的架构上引入了GPU进程。</li>
<li>浏览器渲染进程，也就是浏览器内核，Renderer进程，内部是多线程的：默认每个Tab页面都是一个进程，互相不影响。主要作用是页面渲染，脚本执行，事件处理等。</li>
<li>网络进程：主要负责页面的网络资源的加载，之前是作为一个模块运行在浏览器进程中的，最近几年才独立出来，作为一个单独的进程存在。</li>
</ol>
<p>然后基于以上的架构，我们来看看他们是如何解决单进程浏览器所存在的问题的：</p>
<h5>1. 解决不稳定</h5>
<p>首先浏览器渲染进程本省就是分离开来的，每个Tab也面都是一个单独的进程，互不影响。其次将第三方插件进程也单独拎了出来，这样就算一个页面的插件出现可问题，也不会影响到这个页面的渲染进程，也就不会对浏览器造成影响了。</p>
<h5>2. 解决不流畅</h5>
<p>在多进程的架构下，JavaScript 只是运行在自己的渲染进程中的，因此即使 JavaScript 代码阻塞了渲染进程，受到影响的也只是当前所渲染的页面。脚本运行也是同样的道理。而对于常常引发性能问题的内存泄漏，在这种架构下，关闭一个页面，会将整个渲染进程给关闭，这时候操作系统就会回收这个进程所占用的内存，也就会不会存在内存泄漏的问题了。</p>
<h5>3. 解决不安全</h5>
<p>采用多金策的架构的一个好处就是可以使用安全沙盒，沙盒通常严格控制其中的程序所能访问的资源，比如，沙盒可以提供用后即回收的磁盘及内存空间。在沙盒中，网络访问、对真实系统的访问、对输入设备的读取通常被禁止或是严格限制。而charome浏览器就将插件进程以及渲染进程所在了沙盒之中，这样即使插件进程以及渲染进程有恶意程序在执行，也无法突破沙盒去获取系统权限，对我们的电脑造成影响。</p>
<p>虽然现在的多进程的浏览器看起来很美好，解决了原先单进程浏览器所存在的诸多的问题，但同样不可避免的存在着一些问题：</p>
<ul>
<li>资源占用更多了</li>
<li>更为复杂的体系结构</li>
</ul>
<h4>2.3  黄金时代---SOA架构</h4>
<p>为了解决现在浏览器所存在的资源占用高，体系更为复杂的问题，2016年 Chrome 团队就开始使用 “面向服务的架构”（SOA)的思想来设计新的 Chrome 架构。</p>
<p>那什么是SOA呢，简单来说SOA就是一种组件模型，他将应用程序的不同功能单元通过这些服务之间所定义好的接口或者契约联系起来。接口采用中立的方式来进行定义，独立于硬件平台、操作系统以及编程语言。这使得构建各种各样的系统中的服务都可以以一种统一和通用的方式来进行交互。</p>
<p>也就是说， Chrome要做的就是将UI进程、设备、文件、Audio等等模块都编程基础服务，每个服务都可以在独立的进程中运行，而访问这些服务也必须使用定义好的接口，并通过IPC来进行通信。从而构建一个更内聚、松耦合、更易维护和扩展的系统。</p>
<p><img src="https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png" alt="image" /></p>
]]></content><link href="https://github.com/srtian/Blog/issues/1" rel="alternate"/><category term="FE"/><category term="Web"/><published>2019-09-28T09:12:37+00:00</published></entry></feed>